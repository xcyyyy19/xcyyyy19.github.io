<!DOCTYPE html>


<html lang="zh-CN">
  

    <head>
      <meta charset="utf-8" />
        
      <meta
        name="viewport"
        content="width=device-width, initial-scale=1, maximum-scale=1"
      />
      <title> Pravite Home</title>
  <meta name="generator" content="hexo-theme-ayer">
      
      <link rel="shortcut icon" href="/favicon.ico" />
       
<link rel="stylesheet" href="/dist/main.css">

      
<link rel="stylesheet" href="/css/fonts/remixicon.css">

      
<link rel="stylesheet" href="/css/custom.css">
 
      <script src="https://cdn.staticfile.org/pace/1.2.4/pace.min.js"></script>
       
 

      <link
        rel="stylesheet"
        href="https://cdn.jsdelivr.net/npm/@sweetalert2/theme-bulma@5.0.1/bulma.min.css"
      />
      <script src="https://cdn.jsdelivr.net/npm/sweetalert2@11.0.19/dist/sweetalert2.min.js"></script>

      <!-- mermaid -->
      
      <style>
        .swal2-styled.swal2-confirm {
          font-size: 1.6rem;
        }
      </style>
    <link rel="alternate" href="/atom.xml" title="Pravite Home" type="application/atom+xml">
</head>
  </html>
</html>


<body>
  <div id="app">
    
      
      <canvas width="1777" height="841"
        style="position: fixed; left: 0px; top: 0px; z-index: 99999; pointer-events: none;"></canvas>
      
    <main class="content on">
      
<section class="cover">
    
  <div class="cover-frame">
    <div class="bg-box">
      <img src="/images/cover1.jpg" alt="image frame" />
    </div>
    <div class="cover-inner text-center text-white">
      <h1><a href="/">Pravite Home</a></h1>
      <div id="subtitle-box">
        
        <span id="subtitle"></span>
        
      </div>
      <div>
        
        <img
          src="/images/ayer.svg"
          class="cover-logo"
          alt="Pravite Home"
        />
        
      </div>
    </div>
  </div>
  <div class="cover-learn-more">
    <a href="javascript:void(0)" class="anchor"><i class="ri-arrow-down-line"></i></a>
  </div>
</section>



<script src="https://cdn.staticfile.org/typed.js/2.0.12/typed.min.js"></script>


<!-- Subtitle -->

  <script>
    try {
      var typed = new Typed("#subtitle", {
        strings: ['群英荟萃，萝卜开会', '圣火昭昭，圣火耀耀，凡我弟子，喵喵喵喵', '不跟唱？您诫过毒吧'],
        startDelay: 30,
        typeSpeed: 100,
        loop: true,
        backSpeed: 50,
        showCursor: true
      });
    } catch (err) {
      console.log(err)
    }
  </script>
  
<div id="main">
  <section class="outer">
  
  
  
<div class="notice" style="margin-top:50px">
    <i class="ri-heart-fill"></i>
    <div class="notice-content">【网页完善中，1.点击标签-&gt;必看-&gt;网页完善ToDoList。 2.或主页拉到最下方了解进度。】</div>
</div>


<style>
    .notice {
        padding: 20px;
        border: 1px dashed #e6e6e6;
        color: #969696;
        position: relative;
        display: inline-block;
        width: 100%;
        background: #fbfbfb50;
        border-radius: 10px;
    }

    .notice i {
        float: left;
        color: #999;
        font-size: 16px;
        padding-right: 10px;
        vertical-align: middle;
        margin-top: -2px;
    }

    .notice-content {
        display: initial;
        vertical-align: middle;
    }
</style>
  
  <article class="articles">
    
    
    
    
    <article
  id="post-前端学习笔记/JS/Q4-JS-9衍生知识（es6、过滤思路、深浅拷贝的原理、debug、函数复用）"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2023/04/15/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/JS/Q4-JS-9%E8%A1%8D%E7%94%9F%E7%9F%A5%E8%AF%86%EF%BC%88es6%E3%80%81%E8%BF%87%E6%BB%A4%E6%80%9D%E8%B7%AF%E3%80%81%E6%B7%B1%E6%B5%85%E6%8B%B7%E8%B4%9D%E7%9A%84%E5%8E%9F%E7%90%86%E3%80%81debug%E3%80%81%E5%87%BD%E6%95%B0%E5%A4%8D%E7%94%A8%EF%BC%89/"
    >JS学习笔记-4.9衍生知识（base gpt/答疑）</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2023/04/15/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/JS/Q4-JS-9%E8%A1%8D%E7%94%9F%E7%9F%A5%E8%AF%86%EF%BC%88es6%E3%80%81%E8%BF%87%E6%BB%A4%E6%80%9D%E8%B7%AF%E3%80%81%E6%B7%B1%E6%B5%85%E6%8B%B7%E8%B4%9D%E7%9A%84%E5%8E%9F%E7%90%86%E3%80%81debug%E3%80%81%E5%87%BD%E6%95%B0%E5%A4%8D%E7%94%A8%EF%BC%89/" class="article-date">
  <time datetime="2023-04-15T03:34:47.000Z" itemprop="datePublished">2023-04-15</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/code/">code</a> / <a class="article-category-link" href="/categories/code/note/">note</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br></pre></td><td class="code"><pre><span class="line">// 一个数据里面去匹配</span><br><span class="line">// 1.字符的匹配</span><br><span class="line">const text = &#x27;hello world&#x27;;</span><br><span class="line">const reg = /helli/;</span><br><span class="line"></span><br><span class="line">const result = text.match(reg);</span><br><span class="line"></span><br><span class="line">// console.log(&quot;result&quot;,result)</span><br><span class="line"></span><br><span class="line">// 2.在一堆数据里面去筛选</span><br><span class="line"></span><br><span class="line">// 3.浅拷贝</span><br><span class="line">const shallowClone = (target) =&gt; &#123;</span><br><span class="line">  const result = &#123;&#125;;</span><br><span class="line">  for (let key in target) &#123;</span><br><span class="line">    result[key] = target[key];</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  return result;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">// // 4.深拷贝</span><br><span class="line">// const deepClone = (target) =&gt; &#123;</span><br><span class="line">//     const obj = &#123;&#125;</span><br><span class="line">//     for (let key in target) &#123;</span><br><span class="line">//         const value = target[key];</span><br><span class="line">//         if (isObj(target)) &#123;</span><br><span class="line">//             obj[key] = deepClone(value)</span><br><span class="line">//         &#125; else &#123;</span><br><span class="line">//             obj[key] = value</span><br><span class="line">//         &#125;</span><br><span class="line">//     &#125;</span><br><span class="line"></span><br><span class="line">//     return obj</span><br><span class="line">// &#125;</span><br><span class="line"></span><br><span class="line">//5.找到复杂对象中的某几个符合的数据</span><br><span class="line">const list = [</span><br><span class="line">  &#123; name: &#x27;zhangsan&#x27;, id: 1 &#125;,</span><br><span class="line">  &#123; name: &#x27;lisi&#x27;, id: 2 &#125;,</span><br><span class="line">  &#123; name: &#x27;wangwu&#x27;, id: 3 &#125;,</span><br><span class="line">  &#123; name: &#x27;wangwu&#x27;, id: 4 &#125;,</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line">// 得分字段 score:10</span><br><span class="line"></span><br><span class="line">const getName = function (item) &#123;</span><br><span class="line">  return item.name === &#x27;wangwu&#x27;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">// 5.1 forEach 遍历</span><br><span class="line"></span><br><span class="line">// 5.2 for of遍历，判断 数组是否满足条件</span><br><span class="line"></span><br><span class="line">//5.3 判断条件独立出来，函数复用</span><br><span class="line"></span><br><span class="line">// 5.2.1every 所有条件满足返回true,否则返回false</span><br><span class="line">const everyResult = list.every(getName);</span><br><span class="line">console.log(&#x27;everyResult&#x27;, everyResult);</span><br><span class="line"></span><br><span class="line">// 5.2.2some 任一条件满足返回true，否则返回false</span><br><span class="line">const someResult = list.some(getName);</span><br><span class="line">console.log(&#x27;someResult&#x27;, someResult);</span><br><span class="line"></span><br><span class="line">const target = [];</span><br><span class="line"></span><br><span class="line">list.forEach((item) =&gt; &#123;</span><br><span class="line">  target.push(&#123;</span><br><span class="line">    ...item,</span><br><span class="line">    score: 10,</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">return target;</span><br><span class="line"></span><br><span class="line">// 5.3map</span><br><span class="line"></span><br><span class="line">// 5.4reduce</span><br><span class="line"></span><br><span class="line">// 6.深拷贝的底层原理：判断数据类型是否为Object</span><br><span class="line">const isObj = (target) =&gt;</span><br><span class="line">  Object.prototype.toString.call(target) === &#x27;[object Object]&#x27;;</span><br><span class="line"></span><br><span class="line">const deepClone = (target) =&gt; &#123;</span><br><span class="line">  const obj = &#123;&#125;;</span><br><span class="line">  for (let key in target) &#123;</span><br><span class="line">    const value = target[key];</span><br><span class="line">    debugger;</span><br><span class="line">    if (isObj(value)) &#123;</span><br><span class="line">      debugger;</span><br><span class="line">      obj[key] = deepClone(value);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      debugger;</span><br><span class="line">      obj[key] = value;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  return obj;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">deepClone(&#123; a: &#123; b: 10 &#125; &#125;);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/JS/" rel="tag">JS</a></li></ul>

    </footer>
  </div>

    
 
    
</article>

    
    <article
  id="post-前端学习笔记/JS/Q4-JS-10两道题（BFE.dev）"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2023/04/15/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/JS/Q4-JS-10%E4%B8%A4%E9%81%93%E9%A2%98%EF%BC%88BFE.dev%EF%BC%89/"
    >JS学习笔记-4.10两道题（base gpt/答疑/BFE网站）</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2023/04/15/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/JS/Q4-JS-10%E4%B8%A4%E9%81%93%E9%A2%98%EF%BC%88BFE.dev%EF%BC%89/" class="article-date">
  <time datetime="2023-04-15T03:34:47.000Z" itemprop="datePublished">2023-04-15</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/code/">code</a> / <a class="article-category-link" href="/categories/code/note/">note</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h2 id="107-找到最大的差"><a href="#107-找到最大的差" class="headerlink" title="107.找到最大的差"></a>107.找到最大的差</h2><p><a target="_blank" rel="noopener" href="https://bigfrontend.dev/zh/problem/Find-the-largest-difference">107. 找到最大的差 | BFE.dev - 前端刷题，准备前端面试拿到心仪的Offer。 (bigfrontend.dev)</a></p>
<p>原始思路：略（还是框在C语言和Python里了，实现方法很麻烦，很多东西JS已经给包装好了可以直接用）</p>
<h3 id="法一："><a href="#法一：" class="headerlink" title="法一："></a>法一：</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line">// 给定一个整数数组，任意选择两个数a和b，可以通过 Math.abs(a - b)求得其差值。</span><br><span class="line">// 请实现一个函数来求得这个数组的最大差值。</span><br><span class="line"></span><br><span class="line">// 解体思路其实就是最小值 - 最大值，再做绝对值的计算（因为差值是非0整数）</span><br><span class="line"></span><br><span class="line">// 如果不会使用sort方法进行排序，我们也可以自己实现一个sort方法</span><br><span class="line"></span><br><span class="line">// 默认的type为&quot;max&quot;,找出最大值,反之为&quot;max&quot;，找出最小值</span><br><span class="line">const findNum = (list, type = &quot;max&quot;) =&gt; &#123;</span><br><span class="line">  let target;</span><br><span class="line">  if (type === &quot;max&quot;) &#123;</span><br><span class="line">    list.forEach((item, index) =&gt; &#123;</span><br><span class="line">      if (index === 0) &#123;</span><br><span class="line">        // 开始循环，将首个数字作为基准，进行比较</span><br><span class="line">        target = item;</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">        if (item &gt; target) &#123;</span><br><span class="line">          // 替换target的值</span><br><span class="line">          target = item;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    list.forEach((item, index) =&gt; &#123;</span><br><span class="line">      if (index === 0) &#123;</span><br><span class="line">        target = item;</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">        if (item &lt; target) &#123;</span><br><span class="line">          target = item;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">  return target;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">// 上述的代码可以优化一下语句，因为整体思路是一致的</span><br><span class="line">// 进行index === 0 赋值</span><br><span class="line">// 通过 type 判断是什么条件下，更新target的值</span><br><span class="line">const simplifyFindNum = (list, type = &quot;max&quot;) =&gt; &#123;</span><br><span class="line">  let target;</span><br><span class="line">  // 优化一下，type不为max或者min，不处理数据了。</span><br><span class="line">  // 避免进入forEach语句浪费性能</span><br><span class="line">  if (type !== &quot;min&quot; &amp;&amp; type !== &quot;max&quot;) return target;</span><br><span class="line"></span><br><span class="line">  list.forEach((item, index) =&gt; &#123;</span><br><span class="line">    if (index === 0) &#123;</span><br><span class="line">      // 开始循环，将首个数字作为基准，进行比较</span><br><span class="line">      target = item;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      // 替换target的值</span><br><span class="line">      if (type === &quot;max&quot; &amp;&amp; item &gt; target) &#123;</span><br><span class="line">        target = item;</span><br><span class="line">      &#125;</span><br><span class="line">      if (type === &quot;min&quot; &amp;&amp; item &lt; target) &#123;</span><br><span class="line">        target = item;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">  return target;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">const largestDiff = (list) =&gt; &#123;</span><br><span class="line">    const maxNum = simplifyFindNum(list); // 获取数组最大值</span><br><span class="line">    const minNum = simplifyFindNum(list,&quot;min&quot;) // 获取数组最小值</span><br><span class="line">    const diff = Math.abs(minNum - maxNum) // 最小值 - 最大值，进行绝对值的计算</span><br><span class="line"></span><br><span class="line">    return diff</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const diff = largestDiff([-1, 2,3,10, 9]);</span><br></pre></td></tr></table></figure>

<h3 id="法二："><a href="#法二：" class="headerlink" title="法二："></a>法二：</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">// 给定一个整数数组，任意选择两个数a和b，可以通过 Math.abs(a - b)求得其差值。</span><br><span class="line">// 请实现一个函数来求得这个数组的最大差值。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// 解体思路其实就是最小值 - 最大值，再做绝对值的计算（因为差值是非0整数）</span><br><span class="line">const largestDiff = (list) =&gt; &#123;</span><br><span class="line">    const maxNum = Math.max.apply(Math,list); // 数组通过apply调用Math的max方法，获取数组最大值</span><br><span class="line">    const minNum = Math.min.apply(Math,list) // 同上，获取数组最小值</span><br><span class="line">    const diff = Math.abs(minNum - maxNum) // 最小值 - 最大值，进行绝对值的计算</span><br><span class="line"></span><br><span class="line">    return diff</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// largestDiff([-1, 2,3,10, 9])</span><br><span class="line"></span><br><span class="line">const diff = largestDiff([-1, 2,3,10, 9]);</span><br><span class="line">console.log(&quot;diff&quot;,diff)</span><br></pre></td></tr></table></figure>

<h3 id="法三："><a href="#法三：" class="headerlink" title="法三："></a>法三：</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">// 给定一个整数数组，任意选择两个数a和b，可以通过 Math.abs(a - b)求得其差值。</span><br><span class="line">// 请实现一个函数来求得这个数组的最大差值。</span><br><span class="line"></span><br><span class="line">// 解体思路其实就是最小值 - 最大值，再做绝对值的计算（因为差值是非0整数）</span><br><span class="line">// 解题思路，通过sort方法进行排序</span><br><span class="line">const largestDiff = (list) =&gt; &#123;</span><br><span class="line">  const sortedList = list.sort((prev, next) =&gt; next - prev); // 按照从大到小排序</span><br><span class="line">  const maxNum = sortedList[0];</span><br><span class="line">  const minNum = sortedList[sortedList.length-1];</span><br><span class="line">  const diff = Math.abs(minNum - maxNum); // 最小值 - 最大值，进行绝对值的计算</span><br><span class="line">  return diff;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">const diff = largestDiff([-1, 2, 3, 10, 9]);</span><br><span class="line">console.log(&quot;diff&quot;, diff);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="162-请找到未重复出现的整数"><a href="#162-请找到未重复出现的整数" class="headerlink" title="162. 请找到未重复出现的整数"></a>162. 请找到未重复出现的整数</h2><p><a target="_blank" rel="noopener" href="https://bigfrontend.dev/zh/problem/find-the-single-integer">162. 请找到未重复出现的整数 | BFE.dev - 前端刷题，准备前端面试拿到心仪的Offer。 (bigfrontend.dev)</a></p>
<p>原始思路：哈希&#x2F;桶排（注意负数，需要下标映射）</p>
<p>claude思路：map（es6新特性，还没学到）</p>
<h3 id="原始方法（动态数组未映射）："><a href="#原始方法（动态数组未映射）：" class="headerlink" title="原始方法（动态数组未映射）："></a>原始方法（动态数组未映射）：</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">const arr = [10, 2, 2 , 1, 0, 0, 10]</span><br><span class="line">function findSingle(arr) &#123;</span><br><span class="line">  //js的除法是向下取整吗？（是的）</span><br><span class="line">  //哈希思想，需要映射数据，麻烦。const countArr=[arr.length/2+1];</span><br><span class="line">  //桶排思想，空间复杂度高，方便。但出现负数怎么办？（也要映射，整体前移就好）</span><br><span class="line">  //js数组不是动态数组吗(是)，不能自动扩容直接下标访问吗（能下标访问，但也要初始化，好像不能自动扩容），需要遍历出最大数值再生成数组是吗（可以不需要，用的话最好，用完了直接前移映射就完了）</span><br><span class="line">  </span><br><span class="line">  const countArr=[]</span><br><span class="line">  for(let i=0;i&lt;arr.length;++i)&#123;</span><br><span class="line">  	if(!countArr[arr[i]])&#123;</span><br><span class="line">  	countArr[arr[i]]=0;</span><br><span class="line">  	&#125;</span><br><span class="line">    countArr[arr[i]]++;</span><br><span class="line">    console.log(countArr[arr[i]])</span><br><span class="line">  &#125;</span><br><span class="line">  for(let i=0;i&lt;countArr.length;++i)&#123;</span><br><span class="line">    if(countArr[i]===1)&#123;</span><br><span class="line">      return countArr[i];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">findSingle(arr)</span><br></pre></td></tr></table></figure>



<h3 id="法一：定长数组桶排映射"><a href="#法一：定长数组桶排映射" class="headerlink" title="法一：定长数组桶排映射"></a>法一：定长数组桶排映射</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">使用数组解决第一个题目(找出数组中只出现一次的数)的最优解是:</span><br><span class="line">const arr = [10, 2, 2 , 1, 0, 0, 10, -5, -2];</span><br><span class="line"></span><br><span class="line">function findSingle(arr) &#123;</span><br><span class="line">  let max = 0;</span><br><span class="line">  let min = 0;</span><br><span class="line">  for (let num of arr) &#123;</span><br><span class="line">    max = Math.max(max, num);</span><br><span class="line">    min = Math.min(min, num);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  let countArr = new Array(max - min + 1).fill(0);</span><br><span class="line">  </span><br><span class="line">  for (let num of arr) &#123;</span><br><span class="line">    countArr[num - min]++; </span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  for (let i = 0; i &lt; countArr.length; i++) &#123;</span><br><span class="line">    if (countArr[i] === 1) return i + min;</span><br><span class="line">  &#125; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">findSingle(arr);  // -5</span><br><span class="line">解释:</span><br><span class="line">1. 这种方法先遍历数组一次,得到最大值 max 和最小值 min。</span><br><span class="line">2. 初始化 countArr 长度为 max - min + 1,正好可以容纳所有数值。</span><br><span class="line">3. 第二次遍历,使用 num - min 作为 countArr 下标,统计每个数出现次数。</span><br><span class="line">4. 找到次数为 1 的下标后,返回 i + min 恢复真实数值。</span><br><span class="line">5. 这种方法空间复杂度稳定在数组范围内,可以容纳任意范围的数,包括负数。</span><br><span class="line">这种方法相比其他数组方法有以下优点:</span><br><span class="line">1. 空间复杂度稳定,不会随数组最大值变化。</span><br><span class="line">2. 可以容纳任意范围的数,通过映射到数组中。</span><br><span class="line">3. 代码简洁高效。只需遍历两次数组。</span><br><span class="line">总结:</span><br><span class="line">相比动态数组多次判断是否初始化的方式,这个方法通过一次遍历得知数组范围,初始化恰当大小的数组,使空间复杂度稳定,且代码更简洁高效。</span><br><span class="line">所以如果要我选最优的数组解法,我会选择这个方法。当然,Map 方法由于内部实现原因,在大多数情况下仍然更为高效和优秀。但是如果考虑到兼容性,这个数组方法也是一个不错的选择。</span><br></pre></td></tr></table></figure>

<h3 id="法二：map-hash"><a href="#法二：map-hash" class="headerlink" title="法二：map-hash"></a>法二：map-hash</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">// 通过Map做映射关系</span><br><span class="line">// Map和Object的区别，Object的key需要为字符串，如果不是，会转化为字符串类型</span><br><span class="line">// Map的key可以为任意类型</span><br><span class="line">// Map使用set（写）和get（读） has(判断是否有映射关系)</span><br><span class="line">// https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Map</span><br><span class="line"></span><br><span class="line">const findSingle = (list) =&gt; &#123;</span><br><span class="line">  const hash = new Map(); // key为出现的数字，value为出现的次数</span><br><span class="line">  list.forEach((num) =&gt; &#123;</span><br><span class="line">    const val = hash.get(num);</span><br><span class="line">    // 没有映射关系，说明该数字首次出现</span><br><span class="line">    if (!hash.has(num)) &#123;</span><br><span class="line">      hash.set(num, 1); // 首次出现</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      hash.set(num, val + 1); // 出现次数+1</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  // hash是Map类型，是可迭代对象，可以直接使用forEach进行遍历</span><br><span class="line">  // 遍历哈希表(hash),找出出现次数(value)为1的数字(key)</span><br><span class="line">  // 如果这个题目存在多个出现次数为1的数字，可以考虑将target初始化为空数组，每次找出对应的数字做push操作</span><br><span class="line">  let target;</span><br><span class="line">  hash.forEach((value, key) =&gt; &#123;</span><br><span class="line">    if (value === 1) &#123;</span><br><span class="line">      target = key;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  return target</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">findSingle([10, 2, 2, 1, 0, 0, 10]);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="法三：-1"><a href="#法三：-1" class="headerlink" title="法三："></a>法三：</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">// 给定一个整数数组，除了一个数字之外，其余的数字均出现了两次。请找出这个只出现了一次的数。</span><br><span class="line">// const arr = [10, 2, 2 , 1, 0, 0, 10]</span><br><span class="line">// findSingle(arr) // 1</span><br><span class="line"></span><br><span class="line">// 思路，通过哈希表去实现（前端js没有对应的数据结构，但是我们一般可以通过Object的key-value的映射关系去实现）</span><br><span class="line">// 其中 key 代表 出现的数字,value 代表该次数出现的次数</span><br><span class="line">// 最终将对应的Object取出value为1的数字</span><br><span class="line"></span><br><span class="line">const findSingle = (list) =&gt; &#123;</span><br><span class="line">    const hash = &#123;&#125;; // key为出现的数字，value为出现的次数</span><br><span class="line">    list.forEach((num) =&gt; &#123;</span><br><span class="line">        const val = hash[num];</span><br><span class="line">        // 没有映射关系，说明该数字首次出现</span><br><span class="line">        if (!val) &#123;</span><br><span class="line">            hash[num] = 1;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            hash[num] = val +1; // 出现次数+1</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    // 遍历哈希表(hash),找出出现次数(value)为1的数字(key)</span><br><span class="line">    // 如果这个题目存在多个出现次数为1的数字，可以考虑将target初始化为空数组，每次找出对应的数字做push操作</span><br><span class="line">    let target;</span><br><span class="line">    for (const key in hash) &#123;</span><br><span class="line">        // 找出出现次数为1的数据</span><br><span class="line">        if (hash[key] === 1) &#123;</span><br><span class="line">            // target = key</span><br><span class="line">            target = Number(key)</span><br><span class="line">            // 这边有一个陷阱，key在存储时会被转成string类型，对应的数字的number类型，需要转化为Number</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">        </span><br><span class="line">    return target</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">findSingle([10, 2, 2 , 1, 0, 0, 10])</span><br></pre></td></tr></table></figure>





<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>思想钢印：再也不要想最优解的事了，下意识也不要想。</p>
<p>先实现再迭代优化。</p>
<p>不要纠结思路不是最优解，思路没问题也写得费劲说明需要熟悉语法。</p>
<h2 id="延申："><a href="#延申：" class="headerlink" title="延申："></a>延申：</h2><p>OK,让我们重新开始吧!到目前为止,我们探讨了几种解决这道题的思路和方法:</p>
<ol>
<li><p>定长数组:- 空间复杂度低但需要知道最大值,否则容易越界<br> - 无法容纳负数<br> - 适用于最大值已知且较小的情况</p>
</li>
<li><p>动态数组:- 可以自动扩容,无最大值限制,但是空间复杂度随最大值变化<br> - 需要判断数组元素是否存在,如果不存在先赋默认值<br> - 可以通过映射容纳负数<br> - 适用于最大值较大但性能要求不高的情况</p>
</li>
<li><p>Map:- key 可以是任意值,无最大值和负数限制<br> - 空间复杂度稳定,自动扩容<br> - 使用方便,get() 设置默认值,遍历使用 for..of<br> - 是解决这个问题的最通用高效数据结构</p>
</li>
</ol>
<p>  那么,如果让您重新解答这个问题,您会选择哪种思路和方法呢?除了上述几种,您还有其他的好想法吗?</p>
<p>  这里是一个新的问题供您思考和解答:输入一个整数数组,找到两个数和为特定值的下标。例如:输入: [3, 2, 5, 4, 1], target &#x3D; 7<br>  输出: [1, 3] (nums[1] + nums[3] &#x3D; 2 + 5 &#x3D; 7)</p>
<p>  您会如何解决这个问题?欢迎提出您的思路和代码实现,我们可以就此进行进一步探讨。</p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/JS/" rel="tag">JS</a></li></ul>

    </footer>
  </div>

    
 
    
</article>

    
    <article
  id="post-前端学习笔记/JS/VSCode代码/访问函数内嵌套的对象"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
     
    <div class="article-meta">
      <a href="/2023/04/14/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/JS/VSCode%E4%BB%A3%E7%A0%81/%E8%AE%BF%E9%97%AE%E5%87%BD%E6%95%B0%E5%86%85%E5%B5%8C%E5%A5%97%E7%9A%84%E5%AF%B9%E8%B1%A1/" class="article-date">
  <time datetime="2023-04-14T08:18:34.213Z" itemprop="datePublished">2023-04-14</time>
</a>    
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <title>1.访问函数内嵌套的对象</title>
  </head>
  <body>
    <script>
      /*函数将会检查通讯录中是否存在一个 firstName 与传入的 name 相同的联系人。 如果存在，那么还需要检查对应的联系人中是否存在 prop 属性。
      如果它们都存在，函数返回 prop 属性对应的值。
      如果 name 不对应于任何联系人，然后返回字符串 No such contact。
      如果 prop 属性在匹配 name 的联系人里不存在，返回 No such property。 */

      const contacts = [
        {
          firstName: 'Akira',
          lastName: 'Laine',
          number: '0543236543',
          likes: ['Pizza', 'Coding', 'Brownie Points'],
        },
        {
          firstName: 'Harry',
          lastName: 'Potter',
          number: '0994372684',
          likes: ['Hogwarts', 'Magic', 'Hagrid'],
        },
        {
          firstName: 'Sherlock',
          lastName: 'Holmes',
          number: '0487345643',
          likes: ['Intriguing Cases', 'Violin'],
        },
        {
          firstName: 'Kristian',
          lastName: 'Vos',
          number: 'unknown',
          likes: ['JavaScript', 'Gaming', 'Foxes'],
        },
      ];

      // 1.[{1}{2}{3}{4}]结构,forin的结果并不是取[]内的几个{}，而是数数。
      // for (let sq in contacts) {
      //   console.log(sq); //0 1 2 3
      // }
      // 2.for in 在js中只能用来遍历对象的属性,py里是for i in range(10);
      //   for (let i in contacts.length) {
      //     console.log('2222');
      //   }
      function lookUpProfile(name, prop) {
        for (let i = 0; i < contacts.length; ++i) {
          console.log(contacts[i]);
          if (contacts[i].firstName === name) {
            console.log('name findable');
            for (let j in contacts[1]) {
              if (j === prop) {
                console.log(contacts[i][prop]);
                return contacts[i][prop];
              }
            }
            return 'No such property';
          }
        }
        return 'No such contact';
      }
      lookUpProfile('Harry', 'likes');
    </script>
  </body>
</html>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
    </footer>
  </div>

    
 
    
</article>

    
    <article
  id="post-前端学习笔记/JS/Q4-JS-8面向对象"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2023/04/14/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/JS/Q4-JS-8%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"
    >JS学习笔记-4.8面向对象（base  gpt/答疑 ）</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2023/04/14/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/JS/Q4-JS-8%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/" class="article-date">
  <time datetime="2023-04-14T03:34:47.000Z" itemprop="datePublished">2023-04-14</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/code/">code</a> / <a class="article-category-link" href="/categories/code/note/">note</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h1 id="4-8面向对象"><a href="#4-8面向对象" class="headerlink" title="4.8面向对象"></a>4.8面向对象</h1><h2 id="4-8-1浅薄的了解"><a href="#4-8-1浅薄的了解" class="headerlink" title="4.8.1浅薄的了解"></a>4.8.1浅薄的了解</h2><h3 id="1-构造函数"><a href="#1-构造函数" class="headerlink" title="1.构造函数"></a>1.构造函数</h3><p>用于反复创建相同的对象，和Java一样，就是父类。</p>
<p>this.price&#x3D;price;意味着把传进来的price参数挂载到构造函数内部当作属性用了。</p>
<h3 id="2-是否使用原型函数（prototype）"><a href="#2-是否使用原型函数（prototype）" class="headerlink" title="2.是否使用原型函数（prototype）"></a>2.是否使用原型函数（prototype）</h3><p>构造函数内的方法如果是不变的，那么每次new一个新实例的时候都会调用这个方法，从而造成资源浪费。所以要把它挂载到原型上，并写在函数外部，这样就相当于只初始化一次。这样他实例化时，就会通过实例化（子类）的声明覆盖掉父类的声明。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">//Car构造函数的初始化</span><br><span class="line">Car(price)&#123;</span><br><span class="line">	this.price=price;</span><br><span class="line">&#125;</span><br><span class="line">//给Car函数增加原型函数</span><br><span class="line">Car.run=function()&#123;console.log(&quot;run as 100km/h&quot;)&#125;</span><br></pre></td></tr></table></figure>

<p>构造函数内的方法如果是基于传进来的参数要进行选择性创建的，那么就不用写成原型函数，且可以写在构造函数内部。<br><img src="./Q4-JS-7%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1.assets/image-20230421171703306.png" alt="image-20230421171703306" style="zoom:33%;" /></p>
<h3 id="3-原型链"><a href="#3-原型链" class="headerlink" title="3.原型链"></a>3.原型链</h3><p>在调用某个类的子函数的时候，先去找它本身是否声明过（这会覆盖父类的声明），然后找父类内部是否声明过，再找父类的prototype（原型）函数中有没有。</p>
<h3 id="4-覆盖"><a href="#4-覆盖" class="headerlink" title="4.覆盖"></a>4.覆盖</h3><p>子类的重复声明，会把父类的声明覆盖掉。</p>
<h3 id="5-静态属性"><a href="#5-静态属性" class="headerlink" title="5.静态属性"></a>5.静态属性</h3><p>就是只属于自己的属性。简称属性。</p>
<p>注：构造函数也可以有只属于自己的（无法被继承的）属性。</p>
<h3 id="6-一些疑问"><a href="#6-一些疑问" class="headerlink" title="6.一些疑问"></a>6.一些疑问</h3><p>1.浅拷贝都有什么实现方式<br>2.为什么创建对象的时候，对象里面的方法用的是引用，而属性不是</p>
<pre><code>这是因为在 JavaScript 中,对象的方法和属性有不同的存储方式:
属性:
- 属性的值直接存储在对象中
- 当读取属性时,直接返回对象中存储的值方法:- 方法的值实际上是一个函数
- 函数是引用类型,所以方法的值是一个指向函数的引用
- 当读取方法时,返回的是对函数的引用
</code></pre>
<p>   <a target="_blank" rel="noopener" href="https://test-rnt2063.slack.com/archives/D053Z3YFB4Y/p1682137400226899">https://test-rnt2063.slack.com/archives/D053Z3YFB4Y/p1682137400226899</a><br>3.为什么函数是引用类型，而不是拷贝？</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">1.为了让函数实现共用</span><br><span class="line">2.避免每次传递函数时都需要创建一个函数的完整拷贝。</span><br><span class="line">因为函数也是对象,如果是值类型,每次传递都需要将整个函数对象拷贝一份,这会消耗额外资源。</span><br><span class="line">而作为引用类型,我们只需要传递函数的引用,就能在多个地方调用同一个函数,不需要每次都创建一个新的函数对象。</span><br><span class="line">3.支持函数的动态性。如果函数是值类型,那么函数创建后其引用就永远固定了。而作为引用类型,函数的引用是可以动态修改和重新赋值的。</span><br><span class="line">在 JavaScript 中,函数是对象,而对象是引用类型。</span><br><span class="line">所以当我们传递或赋值一个函数时,传递的其实是对该函数对象的引用,而不是函数的拷贝。</span><br></pre></td></tr></table></figure>

<p>   <a target="_blank" rel="noopener" href="https://test-rnt2063.slack.com/archives/D053Z3YFB4Y/p1682137463065349">https://test-rnt2063.slack.com/archives/D053Z3YFB4Y/p1682137463065349</a><br>4.引用在JS里有什么用？</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">1. 允许对象之间共享信息。因为对对象的引用可以在多个变量之间传递,所以指向同一对象的多个变量可以共享该对象中的信息。</span><br><span class="line">例如:</span><br><span class="line">js</span><br><span class="line">let obj = &#123; a: 1 &#125;;</span><br><span class="line">let ref1 = obj;</span><br><span class="line">let ref2 = obj;</span><br><span class="line"></span><br><span class="line">ref1.a = 2;  // 通过 ref1 修改</span><br><span class="line"></span><br><span class="line">console.log(ref2.a); // 2  ref2 也受到影响</span><br><span class="line">这里 ref1 和 ref2 指向同一对象 obj,所以通过 ref1 对 obj 的修改也影响了 ref2。</span><br><span class="line"></span><br><span class="line">2. 实现继承和原型链。JS 中的继承是通过原型链实现的,子对象通过__proto__属性指向父对象,这个过程其实就是引用传递。</span><br><span class="line">例如:</span><br><span class="line">js</span><br><span class="line">let parent = &#123;</span><br><span class="line">  name: &#x27;parent&#x27; </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">let child = &#123;</span><br><span class="line">  __proto__: parent  // child 的 __proto__ 属性引用 parent</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">console.log(child.name); // parent </span><br><span class="line">这里 child 对 parent 的引用允许其访问 parent 的属性和方法。</span><br><span class="line"></span><br><span class="line">3. 函数也是对象,所以对函数的传递和赋值也是通过引用来实现的。这意味着多个变量可以共享同一个函数,并且函数的内部状态会影响所有接受到其引用的变量。</span><br><span class="line">例如:</span><br><span class="line">js</span><br><span class="line">function foo() &#123;</span><br><span class="line">  foo.count++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let bar = foo;</span><br><span class="line"></span><br><span class="line">bar();  // foo.count 是 1 </span><br><span class="line">foo();  // foo.count 是 2</span><br><span class="line">这里 bar 和 foo 指向同一个函数对象,所以调用 bar 或 foo 都会修改这个共享的函数对象。</span><br><span class="line"></span><br><span class="line">4. 允许循环引用。通过引用,两个对象可以相互引用对方,形成闭环。</span><br><span class="line">例如:</span><br><span class="line">js</span><br><span class="line">let obj1 = &#123;</span><br><span class="line">  name: &#x27;obj1&#x27;,</span><br><span class="line">  ref: obj2  // 引用 obj2 </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">let obj2 = &#123;</span><br><span class="line">  name: &#x27;obj2&#x27;,</span><br><span class="line">  ref: obj1  // 引用 obj1</span><br><span class="line">&#125;;</span><br><span class="line">  </span><br><span class="line">所以,总结来说,引用在 JS 中实现了对象之间的连接,是支持大部分面向对象特性和功能的基础。</span><br></pre></td></tr></table></figure>

<p>   <a target="_blank" rel="noopener" href="https://test-rnt2063.slack.com/archives/D053Z3YFB4Y/p1682137511999319">https://test-rnt2063.slack.com/archives/D053Z3YFB4Y/p1682137511999319</a><br>5.为什么对象是引用类型？<br>   <a target="_blank" rel="noopener" href="https://test-rnt2063.slack.com/archives/D053Z3YFB4Y/p1682137569143519">https://test-rnt2063.slack.com/archives/D053Z3YFB4Y/p1682137569143519</a><br>6.构造函数可以被继承的部分一定是引用类型吗？<br>   <a target="_blank" rel="noopener" href="https://test-rnt2063.slack.com/archives/D053Z3YFB4Y/p1682137669380839">https://test-rnt2063.slack.com/archives/D053Z3YFB4Y/p1682137669380839</a><br>7.不是引用类型的部分怎么实现可以被继承的？<br>   <a target="_blank" rel="noopener" href="https://test-rnt2063.slack.com/archives/D053Z3YFB4Y/p1682137704757199">https://test-rnt2063.slack.com/archives/D053Z3YFB4Y/p1682137704757199</a><br>8.构造函数中，可继承的部分中，不是引用类型的部分为什么不用引用实现被继承？<br>    每一个继承对象理应拥有父对象中某些属性的一个独立拷贝,而不是共享一个属性的引用<br>    <a target="_blank" rel="noopener" href="https://test-rnt2063.slack.com/archives/D053Z3YFB4Y/p1682138844233269">https://test-rnt2063.slack.com/archives/D053Z3YFB4Y/p1682138844233269</a><br>9.完整拷贝对象比引用浪费了哪些资源？<br>    1更多的内存空间,需要存储对象的完整结构<br>    2更长的处理时间,需要遍历对象属性进行拷贝<br>    3创建额外的临时对象   </p>
<p>10.引用不用储存对象的完整结构吗？什么叫对象的完整结构？<br>    引用也需要存储对象的结构,但是与拷贝相比,引用只需要存储对象结构一次。<br>    引用的工作原理是:多个变量存储的是对同一个对象的引用,通过这个引用可以访问到对象的结构。</p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/JS/" rel="tag">JS</a></li></ul>

    </footer>
  </div>

    
 
    
</article>

    
    <article
  id="post-前端学习笔记/JS/Q4-JS-7过滤"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2023/04/13/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/JS/Q4-JS-7%E8%BF%87%E6%BB%A4/"
    >JS学习笔记-4.7过滤（base  gpt ）</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2023/04/13/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/JS/Q4-JS-7%E8%BF%87%E6%BB%A4/" class="article-date">
  <time datetime="2023-04-13T03:34:47.000Z" itemprop="datePublished">2023-04-13</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/code/">code</a> / <a class="article-category-link" href="/categories/code/note/">note</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h1 id="4-7-1数组过滤"><a href="#4-7-1数组过滤" class="headerlink" title="4.7.1数组过滤"></a>4.7.1数组过滤</h1><ol>
<li><p>filter():过滤出符合条件的元素,返回新数组。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">array.filter(callbackFunc)</span><br></pre></td></tr></table></figure>

<p>callbackFunc 是过滤函数,用于测试每个元素是否通过测试。<br>filter() 方法返回一个过滤后的新数组。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">const fruits = [&#x27;apple&#x27;, &#x27;banana&#x27;, &#x27;grape&#x27;, &#x27;mango&#x27;, &#x27;orange&#x27;];</span><br><span class="line"></span><br><span class="line">const filterItems = fruits.filter(fruit =&gt; fruit.length &gt; 6);</span><br><span class="line"></span><br><span class="line">console.log(filterItems); </span><br><span class="line">// [&#x27;banana&#x27;, &#x27;mango&#x27;, &#x27;orange&#x27;]</span><br></pre></td></tr></table></figure>
</li>
<li><p>slice():提取符合条件的元素,返回新数组，属于浅拷贝。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">array.slice(start, end)</span><br></pre></td></tr></table></figure>

<p>start 和 end 表示截取的起止位置,不包含 end 位置的元素。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">let fruits = [&#x27;apple&#x27;, &#x27;banana&#x27;, &#x27;grape&#x27;, &#x27;mango&#x27;, &#x27;orange&#x27;];</span><br><span class="line">let sliceFruits = fruits.slice(1, 3);</span><br><span class="line">// sliceFruits = [&#x27;banana&#x27;, &#x27;grape&#x27;]</span><br></pre></td></tr></table></figure>
</li>
<li><p>splice():移除元素,并可以在移除的位置添加新元素。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">array.splice(start, deleteCount, ...newItems) </span><br></pre></td></tr></table></figure>

<p>- start:移除元素的起始位置<br>- deleteCount:要移除的元素个数<br>- newItems:要添加的新元素示例:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">let fruits = [&#x27;apple&#x27;, &#x27;banana&#x27;, &#x27;grape&#x27;, &#x27;mango&#x27;, &#x27;orange&#x27;]; </span><br><span class="line">fruits.splice(1, 2, &#x27;strawberry&#x27;);</span><br><span class="line">// fruits = [&#x27;apple&#x27;, &#x27;strawberry&#x27;, &#x27;mango&#x27;, &#x27;orange&#x27;]</span><br></pre></td></tr></table></figure>
</li>
<li><p>pop()&#x2F;shift():移除数组的最后&#x2F;第一个元素。</p>
</li>
<li><p>concat():相当于C++里的set。连接两个数组,并返回新数组。可以用于过滤两个数组的公共元素。</p>
</li>
<li><p>…(展开运算符):将一个数组展开为用 , 分隔的参数序列,可以用于过滤数组中的某些元素。</p>
<p>除此之外,我们也可以使用 ES6 的 Set 和 Map 等新数据结构进行过滤。</p>
</li>
</ol>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/JS/" rel="tag">JS</a></li></ul>

    </footer>
  </div>

    
 
    
</article>

    
    <article
  id="post-前端学习笔记/JS/Q4-JS-6标准库"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2023/04/12/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/JS/Q4-JS-6%E6%A0%87%E5%87%86%E5%BA%93/"
    >JS学习笔记-4.6标准库（base阮一峰/claude/MDN ）</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2023/04/12/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/JS/Q4-JS-6%E6%A0%87%E5%87%86%E5%BA%93/" class="article-date">
  <time datetime="2023-04-12T03:34:47.000Z" itemprop="datePublished">2023-04-12</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/code/">code</a> / <a class="article-category-link" href="/categories/code/note/">note</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h1 id="4-6标准库"><a href="#4-6标准库" class="headerlink" title="4.6标准库"></a>4.6标准库</h1><h2 id="4-6-0基础知识"><a href="#4-6-0基础知识" class="headerlink" title="4.6.0基础知识"></a>4.6.0基础知识</h2><h3 id="1-C-和-JS-中的构造函数和析构函数的异同"><a href="#1-C-和-JS-中的构造函数和析构函数的异同" class="headerlink" title="1.C++ 和 JS 中的构造函数和析构函数的异同"></a>1.C++ 和 JS 中的构造函数和析构函数的异同</h3><p>C++ 和 JS 中的构造函数和析构函数有以下的异同:异同点一:初始化资源申请以及释放。它们都是用来初始化申请资源以及释放资源的。异同点二:以类名一样的方法命名。构造函数都是以类名命名的,析构函数都是以类名加上 ~ 符号命名的。</p>
<p>不同点一:调用时机不同。</p>
<p>C++: 构造函数在对象定义时或通过 new 关键字动态分配内存时调用;析构函数在对象释放时或 delete 关键字释放内存时调用。<br>JS:构造函数在通过 new 关键字调用时执行;没有析构函数的概念,JS 中由垃圾回收机制实现内存释放。</p>
<p>不同点二:继承的调用关系不同。</p>
<p>C++:在继承关系中,如果子类没有定义构造函数,会自动调用父类的构造函数;如果子类定义了构造函数,需要在子类构造函数中显式调用父类的构造函数;析构函数与构造函数相反,会先调用子类的析构函数,然后调用父类的析构函数。<br>JS:在继承关系中,如果子类没有定义构造函数,不会自动调用父类的构造函数;子类需要显示调用父类的构造函数;没有析构函数的概念。不同点三:重载与重写不同。</p>
<p>C++: 构造函数和析构函数都可以重载;子类可以重写父类的构造函数和析构函数。<br>JS:构造函数不能重载,但可以在子类中重写父类的构造函数;没有重写析构函数的概念。</p>
<p>总体来说,C++ 中的这两个概念更加丰富,而 JS 中针对对象初始化和释放的处理较为简单。</p>
<h3 id="2-什么是浅拷贝"><a href="#2-什么是浅拷贝" class="headerlink" title="2.什么是浅拷贝"></a>2.什么是浅拷贝</h3><p>就是愚蠢的拷贝，如果对象里嵌套了对象，那么就会把内部对象的引用给拷贝下来（引用类型的拷贝不会改变引用地址，也就是说拷贝下来的新引用还是旧的那个引用）。由于只是拷贝引用,所以如果引用所指向的对象发生变化,浅拷贝得到的对象也会发生变化。</p>
<h4 id="最直观的例子："><a href="#最直观的例子：" class="headerlink" title="最直观的例子："></a>最直观的例子：</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">let obj = &#123; a: 1, b: &#123; c: 2 &#125; &#125;;</span><br><span class="line">let copy = Object.assign(&#123;&#125;, obj);  // 浅拷贝</span><br><span class="line">obj.b.c = 3;</span><br><span class="line">obj.a = 4;</span><br><span class="line">console.log(copy.b.c);  // 3  发生变化</span><br><span class="line">console.log(copy.a);    //1   无变化</span><br></pre></td></tr></table></figure>

<h4 id="具体解释："><a href="#具体解释：" class="headerlink" title="具体解释："></a>具体解释：</h4><p>对上面这个例子,我们来分析浅拷贝后 copy 对象的结构:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">js</span><br><span class="line">obj = &#123;</span><br><span class="line">  a: 1,     // 基本类型,值 </span><br><span class="line">  b: &#123;      // 引用类型,地址1</span><br><span class="line">    c: 2 </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">copy = &#123;</span><br><span class="line">  a: 1,     // 基本类型,值 </span><br><span class="line">  b: &#123;      // 引用类型,地址1</span><br><span class="line">    c: 2 </span><br><span class="line">  &#125;  </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<p>然后当我们修改 obj 时:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">js</span><br><span class="line">obj.b.c = 3;  // 修改的是地址1指向的对象</span><br><span class="line">obj.a = 4;     // 修改的是值</span><br></pre></td></tr></table></figure>

<p>此时,obj 和 copy 的结构变为:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">js</span><br><span class="line">obj = &#123;</span><br><span class="line">  a: 4,      // 新的基本类型值 </span><br><span class="line">  b: &#123;       // 地址1</span><br><span class="line">    c: 3    </span><br><span class="line">  &#125;  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">copy = &#123;</span><br><span class="line">  a: 1,       // 原基本类型值</span><br><span class="line">  b: &#123;        // 地址1</span><br><span class="line">    c: 3     </span><br><span class="line">  &#125; </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<p>可以看到:- 当我们修改 obj 的引用类型成员 b 时,由于 copy 中的 b 也指向地址 1,所以 copy 的 b 也发生了变化。- 但是,当我们修改 obj 的基本类型成员 a 时,copy 中的 a 不发生变化,因为它有自己的独立值。所以结果是:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">js</span><br><span class="line">console.log(copy.b.c);  // 3  发生变化</span><br><span class="line">console.log(copy.a);    //1   无变化  </span><br></pre></td></tr></table></figure>

<p>这个过程很好地证明了浅拷贝的特征:- 对引用类型的成员,拷贝的是地址,变化会相互影响<br>- 对基本类型的成员,拷贝的是值,变化互不影响</p>
<h4 id="浅拷贝常见的实现方式有"><a href="#浅拷贝常见的实现方式有" class="headerlink" title="浅拷贝常见的实现方式有:"></a>浅拷贝常见的实现方式有:</h4><ol>
<li><h5 id="Object-assign-obj1-obj2-对象的浅拷贝"><a href="#Object-assign-obj1-obj2-对象的浅拷贝" class="headerlink" title="Object.assign(obj1, obj2)对象的浅拷贝:"></a>Object.assign(obj1, obj2)对象的浅拷贝:</h5></li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">let obj = &#123; a: 1, b: &#123; c: 2 &#125; &#125;;</span><br><span class="line">let copy = Object.assign(&#123;&#125;, obj);  // 浅拷贝</span><br><span class="line">obj.b.c = 3;</span><br><span class="line">console.log(copy.b.c);  // 3  发生变化</span><br></pre></td></tr></table></figure>

<ol start="2">
<li><h5 id="arr-slice-数组的浅拷贝"><a href="#arr-slice-数组的浅拷贝" class="headerlink" title="arr.slice()数组的浅拷贝:"></a>arr.slice()数组的浅拷贝:</h5></li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">let arr = [1, &#123; a: 2 &#125;]; </span><br><span class="line">let copy = arr.slice();   // 浅拷贝</span><br><span class="line">arr[1].a = 3;</span><br><span class="line">console.log(copy[1].a);   // 3  发生变化</span><br></pre></td></tr></table></figure>

<ol start="3">
<li><h5 id="…obj-…arr-展开语法进行浅拷贝"><a href="#…obj-…arr-展开语法进行浅拷贝" class="headerlink" title="{ …obj }  […arr]展开语法进行浅拷贝:"></a>{ …obj }  […arr]展开语法进行浅拷贝:</h5></li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">let obj = &#123; a: 1, b: &#123; c: 2 &#125; &#125;;</span><br><span class="line">let copy = &#123; ...obj &#125;;   // 浅拷贝</span><br><span class="line">obj.b.c = 3;</span><br><span class="line">console.log(copy.b.c);   // 3  发生变化</span><br></pre></td></tr></table></figure>

<p>所以,浅拷贝的主要用途是快速复制对象,但是由于它只复制引用,对于引用类型的成员来说,如果原对象发生变化,拷贝对象也会变化。如果要避免这种情况,可以使用深拷贝,深拷贝会完整复制一个新对象,两者之间不再有任何引用关系,变化互不影响。</p>
<h4 id="常见的深拷贝实现方式有"><a href="#常见的深拷贝实现方式有" class="headerlink" title="常见的深拷贝实现方式有:"></a>常见的深拷贝实现方式有:</h4><p>JSON.parse(JSON.stringify(obj))<br>lodash工具库的 _.cloneDeep() 方法<br>手动实现深度遍历对象并复制（及其简单的递归，就是一层层拨开嵌套对象，直到到达内部找到对象内的键值对，浅拷贝它）</p>
<p>所以,总结来说,浅拷贝和深拷贝的主要区别在于对引用类型的成员的处理方式,理解两者的区别可以更好地选择适合的拷贝方式。</p>
<h4 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h4><p>在工作中,如果要考虑兼容性,或需要灵活指定下标获取部分数组,arr.slice() 会更常用。</p>
<p>如果项目环境支持 ES6,并且需要获取数组的完整拷贝,展开语法 …arr 会更简洁,也是较常见的用法。</p>
<p>两者的底层实现原理都是浅拷贝,对于一维数组来说,效果是相同的。</p>
<p>但也要注意,如果数组包含复杂类型,那么对原数组的修改会影响拷贝得到的数组。</p>
<p>除此之外,也可以选择 lodash 等工具库提供的深拷贝方法,如 _.cloneDeep(),来完全避免两个数组之间的影响,这在某些场景下也比较常用。</p>
<h2 id="4-6-1Object"><a href="#4-6-1Object" class="headerlink" title="4.6.1Object"></a>4.6.1Object</h2><h3 id="1-常用方法"><a href="#1-常用方法" class="headerlink" title="1.常用方法"></a>1.常用方法</h3><p>在工作中,Object 对象属性和方法中常用的主要有:</p>
<ol>
<li><strong>Object.defineProperty() 和 Object.defineProperties()</strong>:用于在对象上定义属性或修改属性,常用于<em><strong>数据响应式</strong></em>。</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">let obj = &#123;&#125;;</span><br><span class="line">Object.defineProperty(obj, &quot;prop&quot;, &#123;</span><br><span class="line">  value: true,</span><br><span class="line">  writable: false,</span><br><span class="line">  enumerable: true </span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>Object.keys() 和 Object.values():用于获得对象的键名数组和键值数组。</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">let obj = &#123; a: 1, b: 2 &#125;;</span><br><span class="line">Object.keys(obj); // [&#x27;a&#x27;, &#x27;b&#x27;]</span><br><span class="line">Object.values(obj); // [1, 2]</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>Object.assign():用于对象合并，B合并到A里（是浅拷贝）。&#x2F;&#x2F;assign：分配、指派（任务）<br>                            不会去重，但是如果键值对的key是一样的，新的会把旧的覆盖，即旧的value消失</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">let target = &#123; a: 1 &#125;;</span><br><span class="line">let source = &#123; b: 2 &#125;;</span><br><span class="line">Object.assign(target, source);</span><br><span class="line">// target is now &#123;a: 1, b: 2&#125;</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>Object.freeze():用于冻结对象,使其不能被修改。</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">let obj = &#123; a: 1 &#125;;</span><br><span class="line">Object.freeze(obj);</span><br><span class="line">obj.a = 2; // 无效</span><br></pre></td></tr></table></figure>

<p>除此之外,对象的元属性(writable、enumerable 等)和存取器(getter、setter)也会使用,但是相对来说较少。控制对象状态的方法(Object.preventExtensions、Object.seal 等)用得比较少,一般只会在需要严格控制对象状态的场景下使用。所以,总的来说,在日常工作中 Object 对象的常用方面主要是属性的操作与管理,包括定义、获取和控制属性。</p>
<blockquote>
<p>注：数据响应式是一种设计模式,其核心思想是:当数据变化时,自动更新视图。在 JavaScript 中,定义响应式数据常用的手段就是 Object.defineProperty()。我们可以在定义对象属性时,指定 getter 和 setter 方法。当属性值发生变化时,getter 和 setter 就会自动调用,这样我们可以在 setter 中更新视图,达到数据响应式的效果。例如:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">let data = &#123;</span><br><span class="line">    name: &quot;John&quot;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Object.defineProperty(data, &quot;name&quot;, &#123;</span><br><span class="line">    get() &#123;</span><br><span class="line">        return this._name;</span><br><span class="line">    &#125;,</span><br><span class="line">    set(newValue) &#123;</span><br><span class="line">        this._name = newValue;</span><br><span class="line">        document.querySelector(&quot;#name&quot;).textContent = newValue;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">data.name = &quot;Jack&quot;; </span><br><span class="line">// 视图自动更新,页面上#name元素的文本变为&quot;Jack&quot;</span><br></pre></td></tr></table></figure>

<p>这里我们定义了 name 属性的 getter 和 setter。当对 name 进行重新赋值时,setter 会自动调用,更新视图中的文本内容。Vue.js 中的响应式就是建立在 Object.defineProperty() 之上的。它通过递归定义对象属性的 getter 和 setter,实现视图的响应更新。所以,我们说 Object.defineProperty() 常用于数据响应式,就是因为它提供了定义属性访问器(getter 和 setter)的能力,可以结合 getter 和 setter 达到响应式更新视图的目的。</p>
</blockquote>
<h3 id="2-Object-prototype（后几个不会用）"><a href="#2-Object-prototype（后几个不会用）" class="headerlink" title="2.Object.prototype（后几个不会用）"></a>2.Object.prototype（后几个不会用）</h3><p>在工作中,Object.prototype 最常用于:</p>
<ol>
<li>扩展内置对象。我们会在 Object.prototype 上添加方法,扩展 String、Array、Date 等内置对象的功能。例如:</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">String.prototype.reverse = function() &#123;</span><br><span class="line">  return this.split(&#x27;&#x27;).reverse().join(&#x27;&#x27;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x27;hello&#x27;.reverse() // olleh</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>实现继承和共享方法。我们会在 Object.prototype 上定义方法,让多个对象类型共享这些方法,实现继承。例如:</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Object.prototype.sayHi = function() &#123;</span><br><span class="line">  console.log(&#x27;Hi!&#x27;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let str = &#x27;Hello&#x27; </span><br><span class="line">let obj = &#123;name: &#x27;Jack&#x27;&#125;</span><br><span class="line"></span><br><span class="line">str.sayHi() // Hi!</span><br><span class="line">obj.sayHi() // Hi!</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>模拟类。在 JS 中我们会使用构造函数和原型来模拟类,Object.prototype 就是在这里发挥作用。例如:</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">function Person(name) &#123;</span><br><span class="line">  this.name = name </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Person.prototype.sayName = function() &#123;</span><br><span class="line">  console.log(this.name); </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let jack = new Person(&#x27;Jack&#x27;);</span><br><span class="line">jack.sayName(); // Jack</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>实现 utility 方法。我们会在 Object.prototype 上实现一些通用的工具方法,供所有对象使用。例如:</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Object.prototype.isArray = function() &#123;</span><br><span class="line">  return Object.prototype.toString.call(this) === &#x27;[object Array]&#x27;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">[].isArray() // true </span><br><span class="line">&#123;&#125;.isArray() // false</span><br></pre></td></tr></table></figure>

<p>所以,总的来说,在工作中 Object.prototype 最常用于扩展内置对象、实现继承和共享方法、模拟类、以及实现通用工具方法。它让 JS 的框架和库设计变得简单高效,也使我们的代码更加优雅。</p>
<h2 id="4-6-1小结"><a href="#4-6-1小结" class="headerlink" title="4.6.1小结"></a>4.6.1小结</h2><p>Object有的函数能继承，有的不能。但不知道怎么主动让它继承，也不知道都哪些能继承。</p>
<h2 id="4-6-2Array类型"><a href="#4-6-2Array类型" class="headerlink" title="4.6.2Array类型"></a>4.6.2Array类型</h2><p><a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array">Array - JavaScript | MDN (mozilla.org)</a></p>
<h3 id="1-构造函数（最好别用）"><a href="#1-构造函数（最好别用）" class="headerlink" title="1.构造函数（最好别用）"></a>1.构造函数（最好别用）</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// bad</span><br><span class="line">var arr = new Array(1, 2);</span><br><span class="line"></span><br><span class="line">// good</span><br><span class="line">var arr = [1, 2];</span><br></pre></td></tr></table></figure>

<h3 id="2-静态方法"><a href="#2-静态方法" class="headerlink" title="2.静态方法"></a>2.静态方法</h3><p>Array.isArray()</p>
<p>它可以弥补<code>typeof</code>运算符的不足。<code>typeof</code>运算符只能显示数组的类型是<code>Object</code>，而<code>Array.isArray</code>方法可以识别数组。</p>
<h3 id="3-实例属性"><a href="#3-实例属性" class="headerlink" title="3.实例属性"></a>3.实例属性</h3><p>length</p>
<h3 id="4-实例方法"><a href="#4-实例方法" class="headerlink" title="4.实例方法"></a>4.实例方法</h3><h4 id="valueOf-，toString"><a href="#valueOf-，toString" class="headerlink" title="valueOf()，toString()"></a>valueOf()，toString()</h4><h4 id="push-尾插，pop-尾删"><a href="#push-尾插，pop-尾删" class="headerlink" title="push()尾插，pop()尾删"></a>push()尾插，pop()尾删</h4><h4 id="shift-头删，unshift-头插"><a href="#shift-头删，unshift-头插" class="headerlink" title="shift()头删，unshift()头插"></a>shift()头删，unshift()头插</h4><p>​				1.shift()头删</p>
<p>​						shift()方法用于删除数组的第一个元素，并返回该元素。注意，该方法会改变原数组。</p>
<p>​						shift()方法可以遍历并清空一个数组。</p>
<p>​						push()和shift()结合使用，就构成了“先进先出”的队列结构（queue）。</p>
<p>​				2.unshift()头插</p>
<p>​						用于在数组的第一个位置添加元素，并返回新的数组的长度。注意，该方法会改变原数组。</p>
<p>​						可以接受多个参数，这些参数都会添加到目标数组头部。</p>
<h4 id="join-符号链接"><a href="#join-符号链接" class="headerlink" title="join()符号链接"></a>join()符号链接</h4><p>​				join()方法以指定参数作为分隔符，将所有数组成员连接并返回。如果不提供参数，默认用逗号分隔。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">通过call方法，这个方法也可以用于字符串或类似数组的对象。</span><br><span class="line"></span><br><span class="line">Array.prototype.join.call(&#x27;hello&#x27;, &#x27;-&#x27;)</span><br><span class="line">// &quot;h-e-l-l-o&quot;</span><br><span class="line"></span><br><span class="line">var obj = &#123; 0: &#x27;a&#x27;, 1: &#x27;b&#x27;, length: 2 &#125;;</span><br><span class="line">Array.prototype.join.call(obj, &#x27;-&#x27;)</span><br><span class="line">// &#x27;a-b&#x27;	</span><br></pre></td></tr></table></figure>

<h4 id="at-下标-访问"><a href="#at-下标-访问" class="headerlink" title="at(下标)访问"></a>at(下标)访问</h4><p>​				返回给定索引处的数组元素。接受从最后一项往回计算的负整数。</p>
<h4 id="concat-合并"><a href="#concat-合并" class="headerlink" title="concat()合并"></a>concat()合并</h4><p>​				用于多个数组的合并。尾插，然后返回一个新数组，原数组不变。</p>
<p>​				如果数组成员包括对象，<code>concat</code>方法返回当前数组的一个浅拷贝。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[&#x27;hello&#x27;].concat([&#x27;world&#x27;], [&#x27;!&#x27;], [&#123;a:4&#125;], 1)   </span><br><span class="line">// [&quot;hello&quot;, &quot;world&quot;, &quot;!&quot;, &#123;a:4&#125;, 1]</span><br></pre></td></tr></table></figure>

<h4 id="reverse"><a href="#reverse" class="headerlink" title="reverse()"></a>reverse()</h4><p>​				用于颠倒排列数组元素，返回改变后的数组。注意，该方法将改变原数组。</p>
<h4 id="slice-切片"><a href="#slice-切片" class="headerlink" title="slice()切片"></a>slice()切片</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">arr.slice(start, end);</span><br></pre></td></tr></table></figure>

<h4 id="splice-删除"><a href="#splice-删除" class="headerlink" title="splice()删除"></a>splice()删除</h4><p>​				用于删除原数组的一部分成员，并可以在删除的位置添加新的数组成员，返回值是被删除的元素。注意，该方法会改变原数组。</p>
<h4 id="sort-不传参-排字典序"><a href="#sort-不传参-排字典序" class="headerlink" title="sort(不传参)排字典序"></a>sort(不传参)排字典序</h4><p>​				对数组成员进行排序。排序后，原数组将被改变。</p>
<p>​				不是按大小排序，而是按字典排序。数值会被先转成字符串，再比较，所以<code>101</code>排在<code>11</code>的前面。</p>
<h4 id="sort-传入函数-排数值序"><a href="#sort-传入函数-排数值序" class="headerlink" title="sort(传入函数)排数值序"></a>sort(传入函数)排数值序</h4><p>​				.sort((a, b) &#x3D;&gt; a - b)</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[1, 4, 2, 6, 0, 6, 2, 6].sort((a, b) =&gt; a - b)</span><br></pre></td></tr></table></figure>

<h4 id="map-传入函数-所有成员依次执行函数"><a href="#map-传入函数-所有成员依次执行函数" class="headerlink" title="map(传入函数)所有成员依次执行函数"></a>map(传入函数)所有成员依次执行函数</h4><p>​				将数组的所有成员依次传入参数函数，然后把每一次的执行结果组成一个新数组返回。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">var numbers = [1, 2, 3];</span><br><span class="line"></span><br><span class="line">numbers.map(function (n) &#123;</span><br><span class="line">  return n + 1;</span><br><span class="line">&#125;);</span><br><span class="line">// [2, 3, 4]</span><br><span class="line"></span><br><span class="line">numbers</span><br><span class="line">// [1, 2, 3]</span><br></pre></td></tr></table></figure>

<h4 id="forEach-传入函数-所有成员依次执行函数"><a href="#forEach-传入函数-所有成员依次执行函数" class="headerlink" title="forEach(传入函数)所有成员依次执行函数"></a>forEach(传入函数)所有成员依次执行函数</h4><p>​				与<code>map()</code>方法很相似，也是对数组的所有成员依次执行参数函数。但不返回值，只用来操作数据。</p>
<h4 id="filter-传入函数-所有成员依次执行函数"><a href="#filter-传入函数-所有成员依次执行函数" class="headerlink" title="filter(传入函数)所有成员依次执行函数"></a>filter(传入函数)所有成员依次执行函数</h4><p>​			过滤数组成员，参数是一个函数，所有数组成员依次执行该函数，返回结果为<code>true</code>的成员组成一个新数组返回。该方法不会改变原数组。</p>
<h4 id="some-存在，every-所有"><a href="#some-存在，every-所有" class="headerlink" title="some()存在，every()所有"></a>some()存在，every()所有</h4><p>​				判断数组成员是否符合某种条件，返回一个布尔值。</p>
<p>​				它们接受一个函数作为参数，所有数组成员依次执行该函数。</p>
<p>​				every方法是所有成员的返回值都是true<code>，整个</code>every<code>方法才返回</code>true<code>，否则返回</code>false。</p>
<h4 id="reduce-，reduceRight"><a href="#reduce-，reduceRight" class="headerlink" title="reduce()，reduceRight()"></a>reduce()，reduceRight()</h4><p>​				<code>reduce()</code>方法和<code>reduceRight()</code>方法依次处理数组的每个成员，最终累计为一个值。它们的差别是，<code>reduce()</code>是从左到右处理（从第一个成员到最后一个成员），<code>reduceRight()</code>则是从右到左（从最后一个成员到第一个成员），其他完全一样。</p>
<h4 id="indexOf-，lastIndexOf"><a href="#indexOf-，lastIndexOf" class="headerlink" title="indexOf()，lastIndexOf()"></a>indexOf()，lastIndexOf()</h4><p>​				<code>indexOf</code>方法返回给定元素在数组中第一次出现的位置，如果没有出现则返回<code>-1</code>。</p>
<p>​				<code>lastIndexOf</code>方法返回给定元素在数组中最后一次出现的位置，如果没有出现则返回<code>-1</code>。</p>
<p><a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/fill"><code>Array.prototype.fill()</code></a></p>
<p>用静态值填充数组中从开始索引到结束索引的所有元素。</p>
<h4 id="链式使用"><a href="#链式使用" class="headerlink" title="链式使用"></a>链式使用</h4><p>上面这些数组方法之中，有不少返回的还是数组，所以可以链式使用。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">var users = [</span><br><span class="line">  &#123;name: &#x27;tom&#x27;, email: &#x27;tom@example.com&#x27;&#125;,</span><br><span class="line">  &#123;name: &#x27;peter&#x27;, email: &#x27;peter@example.com&#x27;&#125;</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line">users</span><br><span class="line">.map(function (user) &#123;</span><br><span class="line">  return user.email;</span><br><span class="line">&#125;)</span><br><span class="line">.filter(function (email) &#123;</span><br><span class="line">  return /^t/.test(email);</span><br><span class="line">&#125;)</span><br><span class="line">.forEach(function (email) &#123;</span><br><span class="line">  console.log(email);</span><br><span class="line">&#125;);</span><br><span class="line">// &quot;tom@example.com&quot;</span><br></pre></td></tr></table></figure>

<p>上面代码中，先产生一个所有 Email 地址组成的数组，然后再过滤出以<code>t</code>开头的 Email 地址，最后将它打印出来。</p>
<h2 id="4-6-3原始类型的对象化"><a href="#4-6-3原始类型的对象化" class="headerlink" title="4.6.3原始类型的对象化"></a>4.6.3原始类型的对象化</h2><h3 id="1-三种包装对象"><a href="#1-三种包装对象" class="headerlink" title="1.三种包装对象"></a>1.三种包装对象</h3><p>Number、String、Boolean</p>
<h3 id="2-包装成对象的原因"><a href="#2-包装成对象的原因" class="headerlink" title="2.包装成对象的原因"></a>2.包装成对象的原因</h3><p>用于继承并使用Object类型中的函数。其中三者公用的是valueOf()<code>和</code>toString()。</p>
<h4 id="2-1valueOf"><a href="#2-1valueOf" class="headerlink" title="2.1valueOf()"></a>2.1valueOf()</h4><p>返回包装对象实例对应的原始类型的值。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">new Number(123).valueOf()  // 123</span><br><span class="line">new String(&#x27;abc&#x27;).valueOf() // &quot;abc&quot;</span><br><span class="line">new Boolean(true).valueOf() // true</span><br></pre></td></tr></table></figure>

<h4 id="2-2toString"><a href="#2-2toString" class="headerlink" title="2.2toString()"></a>2.2toString()</h4><p>返回对应的字符串形式。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">new Number(123).toString() // &quot;123&quot;</span><br><span class="line">new String(&#x27;abc&#x27;).toString() // &quot;abc&quot;</span><br><span class="line">new Boolean(true).toString() // &quot;true&quot;</span><br></pre></td></tr></table></figure>

<h2 id="4-6-2小结"><a href="#4-6-2小结" class="headerlink" title="4.6.2小结"></a>4.6.2小结</h2><p>有些类型直接使用太麻烦，包装成对象可以调用更多的库函数。</p>
<h2 id="4-6-3Boolean"><a href="#4-6-3Boolean" class="headerlink" title="4.6.3Boolean"></a>4.6.3Boolean</h2><h4 id="0-使用与易错点"><a href="#0-使用与易错点" class="headerlink" title="0.使用与易错点"></a>0.使用与易错点</h4><p>0.1使用：直接 let a&#x3D;true；就行。</p>
<p>0.2易错点：小心使用，并不是只有0和false是false，空字符串等也是。</p>
<h4 id="1-Boolean中得到true的例子（都要记住）"><a href="#1-Boolean中得到true的例子（都要记住）" class="headerlink" title="1.Boolean中得到true的例子（都要记住）"></a>1.Boolean中得到true的例子（都要记住）</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Boolean(1) // true				数字</span><br><span class="line">Boolean(&#x27;false&#x27;) // true		字符串</span><br><span class="line">Boolean([]) // true				空数组</span><br><span class="line">Boolean(&#123;&#125;) // true				空对象</span><br><span class="line">Boolean(function () &#123;&#125;) // true	空函数</span><br><span class="line">Boolean(/foo/) // true			正则</span><br></pre></td></tr></table></figure>

<h3 id="2-JS和C中的bool类型的异同"><a href="#2-JS和C中的bool类型的异同" class="headerlink" title="2.JS和C中的bool类型的异同"></a>2.JS和C中的bool类型的异同</h3><p>异同点:</p>
<p>都只有两个值:true 和 false。</p>
<p>都用于表示逻辑上的真假。</p>
<h4 id="2-1不同点一-存储方式不同。"><a href="#2-1不同点一-存储方式不同。" class="headerlink" title="2.1不同点一:存储方式不同。"></a>2.1不同点一:存储方式不同。</h4><p>JS:Boolean 是基本数据类型,占据1个字节。<br>C:没有标准的 bool 类型,一般使用整型来存储,占据1个字节(char)或4个字节(int)。</p>
<h4 id="2-2不同点二-转换规则不同。"><a href="#2-2不同点二-转换规则不同。" class="headerlink" title="2.2不同点二:转换规则不同。"></a>2.2不同点二:转换规则不同。</h4><p>JS:在 Boolean 上下文中,以下值会转换为 false:<br> - false<br> - 0<br> - “”(空字符串)<br> - null<br> - undefined<br> - NaN<br>C:所有非零的值都会转换为 true,0 转换为 false。</p>
<h4 id="2-3不同点三-操作方式不同。"><a href="#2-3不同点三-操作方式不同。" class="headerlink" title="2.3不同点三:操作方式不同。"></a>2.3不同点三:操作方式不同。</h4><p>JS:可以直接对 Boolean 类型的值进行逻辑运算(&amp;&amp;、||、!)<br>C:需要先将值转换为整型,再进行逻辑运算。</p>
<p>例如:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">js</span><br><span class="line">let t = true;</span><br><span class="line">let f = false;</span><br><span class="line"></span><br><span class="line">t &amp;&amp; f;     // false</span><br><span class="line">t || f;     // true </span><br><span class="line">!t;         // false</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">c</span><br><span class="line">int t = 1;  // true</span><br><span class="line">int f = 0;  // false</span><br><span class="line"></span><br><span class="line">t &amp;&amp; f;     // 0 </span><br><span class="line">t || f;     // 1</span><br><span class="line">!t;         // 0</span><br></pre></td></tr></table></figure>

<p>所以,Boolean 作为两种语言的基本数据类型,在概念上是相通的,但是具体的实现与使用上存在一定的差异。总体来说,JS 对 Boolean 的支持更加丰富,使用也更加方便,而 C 由于缺乏标准的 bool 类型, Boolean 的表达相对局限。这也是两种语言的特点的体现:JS 侧重表达,C 侧重底层实现。理解两者在这一点上的差异,有助于更好的使用两种语言。</p>
<h3 id="3-boolean类型与Boolean对象"><a href="#3-boolean类型与Boolean对象" class="headerlink" title="3.boolean类型与Boolean对象"></a>3.boolean类型与Boolean对象</h3><p>在 JS 中,boolean 类型和 Boolean 对象是不同的:</p>
<h4 id="3-1boolean-类型"><a href="#3-1boolean-类型" class="headerlink" title="3.1boolean 类型:"></a>3.1boolean 类型:</h4><p>是 JS 的基本数据类型之一,只有 true 和 false 两个值。<br>- 表示逻辑上的真或假。<br>- 大小写敏感,true 和 True 是不同的。<br>- 可以直接在条件语句中使用,如 if 和 while。例如:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">js</span><br><span class="line">let bool = true;     // boolean 类型</span><br><span class="line"></span><br><span class="line">if (bool) &#123; ... &#125;    // 可以直接用于条件判断</span><br></pre></td></tr></table></figure>

<h4 id="3-2Boolean-对象"><a href="#3-2Boolean-对象" class="headerlink" title="3.2Boolean 对象:"></a>3.2Boolean 对象:</h4><p>是 JS 的内置对象,继承自 Object。<br>- 包装了 boolean 基本类型,有 true 和 false 两个值。<br>- 大小写不敏感,TRUE 和 true 是同一个值。<br>- 不能直接在条件语句中使用,需要调用 valueOf() 方法。<br>- 除了 true 和 false,可以有其他的属性和方法。例如:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">js</span><br><span class="line">let bool = new Boolean(true);   // Boolean 对象</span><br><span class="line"></span><br><span class="line">if (bool.valueOf()) &#123; ... &#125;    // 需要调用 valueOf() 方法</span><br><span class="line"></span><br><span class="line">bool.constructor = 123;        // 可以添加属性</span><br></pre></td></tr></table></figure>

<p>所以,boolean 类型和 Boolean 对象的主要区别在于:- boolean 是基本数据类型,Boolean 是对象。<br>- boolean 只有 true 和 false 两个字面量,Boolean 除了 true 和 false 值外,还可以有其他属性和方法。<br>- boolean 可以直接用于条件判断,Boolean 需要调用 valueOf() 方法。但是,在大多数情况下,我们可以把 Boolean 对象当作 boolean 类型来使用,因为:- Boolean 对象在布尔表达式中会自动调用 valueOf() 方法,返回基本类型值。</p>
<h2 id="4-6-3小结"><a href="#4-6-3小结" class="headerlink" title="4.6.3小结"></a>4.6.3小结</h2><p><strong>基于性能考虑,大多数情况下我们会使用基本类型boolean而不是Boolean对象。</strong>所以,boolean 和 Boolean的关系可以看作,boolean 是基本数据类型,Boolean 是它的对象包装形式。</p>
<h2 id="4-6-4Number"><a href="#4-6-4Number" class="headerlink" title="4.6.4Number"></a>4.6.4Number</h2><p>只有可继承的原型函数prototype.toString（）值得一看</p>
<h2 id="4-6-5-String"><a href="#4-6-5-String" class="headerlink" title="4.6.5.String"></a>4.6.5.String</h2><h3 id="5-1实例属性（原型属性）"><a href="#5-1实例属性（原型属性）" class="headerlink" title="5.1实例属性（原型属性）"></a>5.1实例属性（原型属性）</h3><ol>
<li>字符串实例的length属性返回字符串的长度。</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#x27;abc&#x27;.length // 3</span><br></pre></td></tr></table></figure>

<h3 id="5-2实例方法（原型函数）"><a href="#5-2实例方法（原型函数）" class="headerlink" title="5.2实例方法（原型函数）"></a>5.2实例方法（原型函数）</h3><ol>
<li><p>charAt():返回指定索引处的字符,索引从 0 开始。</p>
<p>或当成数组，使用下标访问(这种方法是只读的，想改动这个字符就会报错)。</p>
</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#x27;hello&#x27;.charAt(0);  // &#x27;h&#x27;</span><br><span class="line">&#x27;hello&#x27;[0];			// &#x27;h&#x27;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>at():返回指定索引处的字符。接受负整数，从最后一个字符串字符开始倒数。</li>
<li>includes():确定调用字符串是否包含 searchString。</li>
<li>concat():连接两个或多个字符串,返回连接后的字符串。</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#x27;hello&#x27;.concat(&#x27; &#x27;, &#x27;world&#x27;);  // &#x27;hello world&#x27;</span><br></pre></td></tr></table></figure>

<ol start="5">
<li>startsWith():检查字符串是否以指定的子字符串开头,返回 true 或 false。</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#x27;hello&#x27;.startsWith(&#x27;he&#x27;);   // true</span><br></pre></td></tr></table></figure>

<ol start="6">
<li>endsWith():检查字符串是否以指定的子字符串结尾,返回 true 或 false。</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#x27;hello&#x27;.endsWith(&#x27;lo&#x27;);   // true</span><br></pre></td></tr></table></figure>

<ol start="7">
<li>indexOf():返回指定子字符串首次出现的索引,如果不存在则返回 -1。</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#x27;hello&#x27;.indexOf(&#x27;l&#x27;);   // 2</span><br></pre></td></tr></table></figure>

<ol start="8">
<li>lastIndexOf():返回指定子字符串最后一次出现的索引,如果不存在则返回 -1。</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#x27;hello&#x27;.lastIndexOf(&#x27;l&#x27;);   // 3</span><br></pre></td></tr></table></figure>

<ol start="9">
<li>slice():切片。提取字符串的一部分,返回提取后的字符串。</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#x27;hello&#x27;.slice(1, 3);   // &#x27;el&#x27;</span><br></pre></td></tr></table></figure>

<ol start="10">
<li>split():拆分。将字符串按指定分隔符拆分成数组,返回数组。</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#x27;a-b-c&#x27;.split(&#x27;-&#x27;);   // [&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;]</span><br></pre></td></tr></table></figure>

<ol start="11">
<li>replace():替换字符串中的指定子字符串,返回替换后的字符串。</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#x27;hello&#x27;.replace(&#x27;l&#x27;, &#x27;x&#x27;);   // &#x27;hexxo&#x27;</span><br></pre></td></tr></table></figure>

<p>&#x2F;&#x2F;正则相关<a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/String">String - JavaScript | MDN (mozilla.org)</a></p>
<ol start="12">
<li><p>match()</p>
</li>
<li><p>matchAll()</p>
</li>
<li><p>replace()</p>
</li>
<li><p>replaceAll()</p>
</li>
<li><p>serach()</p>
</li>
</ol>
<p>&#x2F;&#x2F;claude认为的常用方法</p>
<ol>
<li>String.prototype.indexOf() 和String.prototype.lastIndexOf() :用于查找字符串中的子字符串,前者从前往后,后者从后往前。</li>
<li>String.prototype.slice() :用于提取字符串的一部分,返回一个新的字符串。</li>
<li>String.prototype.substring() <code>:也用于提取字符串的一部分,返回一个新的字符串。和 slice 稍有不同。</code></li>
<li>String.prototype.substr() :同样用于提取字符串的一部分,返回一个新的字符串。和 slice、substring 也有差异。</li>
<li>String.prototype.replace() :用于替换字符串中的子字符串</li>
<li>String.prototype.toUpperCase() <code>和</code> String.prototype.toLowerCase():用于转换字符串的大小写。</li>
<li>String.prototype.concat() :用于连接两个或更多字符串,返回一个新字符串。&#96;</li>
<li>String.prototype.trim() 、String.prototype.trimStart() <code>和</code> String.prototype.trimEnd():用于删除字符串开头或结尾的空格。</li>
<li>String.prototype.charAt() :返回指定索引处的字符。</li>
<li>String.prototype.split() :将字符串分割成子字符串数组。</li>
<li>String.prototype.match() :将正则表达式应用于字符串,返回匹配结果。</li>
<li>String.prototype.search() :搜索字符串中第一个匹配项的索引。</li>
<li>String.prototype.startsWith() <code>和</code>String.prototype.endsWith() :用于判断字符串是否以某个子字符串开头或结尾。</li>
</ol>
<h3 id="5-3构造函数"><a href="#5-3构造函数" class="headerlink" title="5.3构造函数"></a>5.3构造函数</h3><p>不当构造函数用，当强制转换用：String(value)&#x3D;&#x3D;&#x3D;value.valueOf();返回的不是String对象而是字面量string类型。</p>
<h3 id="5-4静态方法"><a href="#5-4静态方法" class="headerlink" title="5.4静态方法"></a>5.4静态方法</h3><p>没用</p>
<h3 id="5-5其它es6补充"><a href="#5-5其它es6补充" class="headerlink" title="5.5其它es6补充"></a>5.5其它es6补充</h3><h4 id="1-标记变量（并替换）"><a href="#1-标记变量（并替换）" class="headerlink" title="1.标记变量（并替换）${}"></a>1.标记变量（并替换）${}</h4><ol>
<li><p>作用：字符串连接时需要用‘’+‘’号链接，用了＄{}后，就不用了。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">let a = 10;</span><br><span class="line">let b = 20;</span><br><span class="line">console.log(`$&#123;a&#125;小于$&#123;b&#125;`);</span><br><span class="line">// 输出:10小于20 </span><br></pre></td></tr></table></figure>
</li>
<li><p>原理</p>
<p>相当于标记了一下，大括号里的是变量，省的被函数默认当成字符了。</p>
</li>
<li><p>易错点</p>
<p>只有使用反引号,字符串插值语法才会被识别和渲染。`${a}小于${b}`</p>
</li>
</ol>
<h4 id="2-忽略转义"><a href="#2-忽略转义" class="headerlink" title="2.忽略转义"></a>2.忽略转义</h4><p>String.raw()是ES6新增的一个字符串原生方法。它的作用是使转义符和${}失效。</p>
<p>它的基本语法是:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String.raw`string` </span><br></pre></td></tr></table></figure>

<p>它有以下几个值得注意的点:</p>
<ol>
<li>符串中的转义字符会被当成普通字符直接输出。</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String.raw`String with \n`   // &quot;String with \n&quot;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>它可以解析字符串模板中${}内的表达式。</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">let name = &quot;Bob&quot;;</span><br><span class="line">String.raw`Hello, $&#123;name&#125;!`   // &quot;Hello, $&#123;name&#125;!&quot;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>它主要用于创建带有未转义\字符的字符串,以及在模板字符串中包含大量${expression}时,避免字符串拼接的性能开销。</li>
<li>如果原字符串没有需要转义的字符或模板变量,使用String.raw()和普通字符串没有任何区别。例子:</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">String.raw`Hello\nworld!`   // &quot;Hello\nworld!&quot;  </span><br><span class="line">String.raw`Hello$&#123;name&#125;!`   // &quot;Hello$&#123;name&#125;!&quot;</span><br><span class="line"></span><br><span class="line">&quot;Hello\nworld!&quot;              // &quot;Hello </span><br><span class="line">world!&quot;</span><br><span class="line">&quot;Hello$&#123;name&#125;!&quot;              // &quot;HelloBob!&quot;</span><br></pre></td></tr></table></figure>

<ol start="5">
<li><h1 id="String-raw-可以和标签函数一起使用-此时会调用标签函数-并将原始字符串作为参数传入。（没看懂）"><a href="#String-raw-可以和标签函数一起使用-此时会调用标签函数-并将原始字符串作为参数传入。（没看懂）" class="headerlink" title="String.raw()可以和标签函数一起使用,此时会调用标签函数,并将原始字符串作为参数传入。（没看懂）"></a>String.raw()可以和标签函数一起使用,此时会调用标签函数,并将原始字符串作为参数传入。（没看懂）</h1>例如:</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">function tag(strings) &#123;</span><br><span class="line">  console.log(strings.raw[0]);</span><br><span class="line">&#125;</span><br><span class="line">tag`Hello\nworld!`   // &quot;Hello\\nworld!&quot;</span><br></pre></td></tr></table></figure>

<p>总之,String.raw()是一个获取原生字符串字面量的强大方法,可以用来避免字符串解析,或在模板字符串中包含大量变量时提升性能。</p>
<h3 id="5-6其他补充"><a href="#5-6其他补充" class="headerlink" title="5.6其他补充"></a>5.6其他补充</h3><ol>
<li>长字符串的处理<br>1.+<br>    const longString &#x3D;<br>      “This is a very long string which needs “ +<br>      “to wrap across multiple lines because “ +<br>      “otherwise my code is unreadable.”;<br>2.<br>    const longString &#x3D;<br>      “This is a very long string which needs <br>    to wrap across multiple lines because <br>    otherwise my code is unreadable.”;</li>
</ol>
<h2 id="4-6-6Math"><a href="#4-6-6Math" class="headerlink" title="4.6.6Math"></a>4.6.6Math</h2><h4 id="6-1（只有）静态函数"><a href="#6-1（只有）静态函数" class="headerlink" title="6.1（只有）静态函数"></a>6.1（只有）静态函数</h4><ul>
<li><p><code>Math.abs()</code>：绝对值（负数也适用，求ab差的绝对值：Math.abs(2 - 3)）</p>
<p>两下标之间的距离不能用a+b，要用abs（a-b），防止有负数下标</p>
</li>
<li><p><code>Math.ceil()</code>：向上取整</p>
</li>
<li><p><code>Math.floor()</code>：向下取整</p>
</li>
<li><p><code>Math.max()</code>：最大值</p>
</li>
<li><p><code>Math.min()</code>：最小值</p>
</li>
<li><p><code>Math.pow()</code>：幂运算</p>
<p>Math.pow方法返回以第一个参数为底数、第二个参数为指数的幂运算值。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 等同于 2 ** 2</span><br><span class="line">Math.pow(2, 2) // 4</span><br><span class="line">// 等同于 2 ** 3</span><br><span class="line">Math.pow(2, 3) // 8</span><br></pre></td></tr></table></figure>

<p>下面是计算圆面积的方法。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var radius = 20;</span><br><span class="line">var area = Math.PI * Math.pow(radius, 2);</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>Math.sqrt()</code>：平方根</p>
<p>Math.sqrt方法返回参数值的平方根。如果参数是一个负值，则返回<code>NaN</code>。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Math.sqrt(4) // 2</span><br><span class="line">Math.sqrt(-4) // NaN</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>Math.log()</code>：自然对数</p>
</li>
<li><p><code>Math.exp()</code>：<code>e</code>的指数</p>
</li>
<li><p><code>Math.round()</code>：四舍五入</p>
</li>
<li><p><code>Math.random()</code>：随机数</p>
<p><code>Math.random()</code>返回0到1之间的一个伪随机数，可能等于0，但是一定小于1。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Math.random() // 0.7151307314634323</span><br></pre></td></tr></table></figure>

<p>任意范围的随机数生成函数如下。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">function getRandomArbitrary(min, max) &#123;</span><br><span class="line">  return Math.random() * (max - min) + min;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">getRandomArbitrary(1.5, 6.5)</span><br><span class="line">// 2.4942810038223864</span><br></pre></td></tr></table></figure>

<p>任意范围的随机整数生成函数如下。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">function getRandomInt(min, max) &#123;</span><br><span class="line">  return Math.floor(Math.random() * (max - min + 1)) + min;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">getRandomInt(1, 6) // 5</span><br></pre></td></tr></table></figure>

<p>返回随机字符的例子如下。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">function random_str(length) &#123;</span><br><span class="line">  var ALPHABET = &#x27;ABCDEFGHIJKLMNOPQRSTUVWXYZ&#x27;;</span><br><span class="line">  ALPHABET += &#x27;abcdefghijklmnopqrstuvwxyz&#x27;;</span><br><span class="line">  ALPHABET += &#x27;0123456789-_&#x27;;</span><br><span class="line">  var str = &#x27;&#x27;;</span><br><span class="line">  for (var i = 0; i &lt; length; ++i) &#123;</span><br><span class="line">    var rand = Math.floor(Math.random() * ALPHABET.length);</span><br><span class="line">    str += ALPHABET.substring(rand, rand + 1);</span><br><span class="line">  &#125;</span><br><span class="line">  return str;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">random_str(6) // &quot;NdQKOr&quot;</span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>random_str</code>函数接受一个整数作为参数，返回变量<code>ALPHABET</code>内的随机字符所组成的指定长度的字符串。</p>
</li>
</ul>
<h2 id="4-6-7Date-x2F-x2F-主要了解如何创建日期-new-Date，get方法"><a href="#4-6-7Date-x2F-x2F-主要了解如何创建日期-new-Date，get方法" class="headerlink" title="4.6.7Date&#x2F;&#x2F;主要了解如何创建日期 new Date，get方法"></a>4.6.7Date&#x2F;&#x2F;主要了解如何创建日期 new Date，get方法</h2><h4 id="7-1作为普通函数"><a href="#7-1作为普通函数" class="headerlink" title="7.1作为普通函数"></a>7.1作为普通函数</h4><p>无论有没有参数，直接调用<code>Date</code>总是返回当前时间。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Date()</span><br><span class="line">// &quot;Tue Dec 01 2015 09:34:43 GMT+0800 (CST)&quot;</span><br></pre></td></tr></table></figure>

<h4 id="7-2作为构造函数"><a href="#7-2作为构造函数" class="headerlink" title="7.2作为构造函数"></a>7.2作为构造函数</h4><p>作为构造函数时，<code>Date</code>对象可以接受多种格式的参数，返回一个该参数对应的时间实例。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// 参数为日期字符串</span><br><span class="line">new Date(&#x27;January 6, 2013&#x27;);</span><br><span class="line">// Sun Jan 06 2013 00:00:00 GMT+0800 (CST)</span><br><span class="line"></span><br><span class="line">// 参数为多个整数，</span><br><span class="line">// 代表年、月、日、小时、分钟、秒、毫秒</span><br><span class="line">new Date(2013, 0, 1, 0, 0, 0, 0)</span><br><span class="line">// Tue Jan 01 2013 00:00:00 GMT+0800 (CST)</span><br></pre></td></tr></table></figure>

<h4 id="7-3包含的静态函数"><a href="#7-3包含的静态函数" class="headerlink" title="7.3包含的静态函数"></a>7.3包含的静态函数</h4><p>没啥用</p>
<h4 id="7-4实例方法"><a href="#7-4实例方法" class="headerlink" title="7.4实例方法"></a>7.4实例方法</h4><p><strong>（1）只有get函数有用</strong>（暂时记住年月日星期就行）</p>
<ul>
<li><code>getTime()</code>：返回实例距离1970年1月1日00:00:00的毫秒数，等同于<code>valueOf</code>方法。</li>
<li><code>getDate()</code>：返回实例对象对应每个月的几号（从1开始）。</li>
<li><code>getDay()</code>：返回星期几，星期日为0，星期一为1，以此类推。</li>
<li><code>getFullYear()</code>：返回四位的年份。</li>
<li><code>getMonth()</code>：返回月份（0表示1月，11表示12月）。</li>
<li><code>getHours()</code>：返回小时（0-23）。</li>
<li><code>getMilliseconds()</code>：返回毫秒（0-999）。</li>
<li><code>getMinutes()</code>：返回分钟（0-59）。</li>
<li><code>getSeconds()</code>：返回秒（0-59）。</li>
<li><code>getTimezoneOffset()</code>：返回当前时间与 UTC 的时区差异，以分钟表示，返回结果考虑到了夏令时因素。</li>
</ul>
<p><strong>（2）本地时间</strong></p>
<p>以下三种方法，可以将 Date 实例转为表示本地时间的字符串。</p>
<ul>
<li>Date.prototype.toLocaleString()：完整的本地时间。</li>
<li>Date.prototype.toLocaleDateString()：本地日期（不含小时、分和秒）。</li>
<li>Date.prototype.toLocaleTimeString()：本地时间（不含年月日）。</li>
</ul>
<p>下面是用法实例。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">var d = new Date(2013, 0, 1);</span><br><span class="line"></span><br><span class="line">d.toLocaleString()</span><br><span class="line">// 中文版浏览器为&quot;2013年1月1日 上午12:00:00&quot;</span><br><span class="line">// 英文版浏览器为&quot;1/1/2013 12:00:00 AM&quot;</span><br><span class="line"></span><br><span class="line">d.toLocaleDateString()</span><br><span class="line">// 中文版浏览器为&quot;2013年1月1日&quot;</span><br><span class="line">// 英文版浏览器为&quot;1/1/2013&quot;</span><br><span class="line"></span><br><span class="line">d.toLocaleTimeString()</span><br><span class="line">// 中文版浏览器为&quot;上午12:00:00&quot;</span><br><span class="line">// 英文版浏览器为&quot;12:00:00 AM&quot;</span><br></pre></td></tr></table></figure>

<p>这三个方法都有两个可选的参数。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">dateObj.toLocaleString([locales[, options]])</span><br><span class="line">dateObj.toLocaleDateString([locales[, options]])</span><br><span class="line">dateObj.toLocaleTimeString([locales[, options]])</span><br></pre></td></tr></table></figure>

<p>这两个参数中，<code>locales</code>是一个指定所用语言的字符串，<code>options</code>是一个配置对象。下面是<code>locales</code>的例子，分别采用<code>en-US</code>和<code>zh-CN</code>语言设定。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">var d = new Date(2013, 0, 1);</span><br><span class="line"></span><br><span class="line">d.toLocaleString(&#x27;en-US&#x27;) // &quot;1/1/2013, 12:00:00 AM&quot;</span><br><span class="line">d.toLocaleString(&#x27;zh-CN&#x27;) // &quot;2013/1/1 上午12:00:00&quot;</span><br><span class="line"></span><br><span class="line">d.toLocaleDateString(&#x27;en-US&#x27;) // &quot;1/1/2013&quot;</span><br><span class="line">d.toLocaleDateString(&#x27;zh-CN&#x27;) // &quot;2013/1/1&quot;</span><br><span class="line"></span><br><span class="line">d.toLocaleTimeString(&#x27;en-US&#x27;) // &quot;12:00:00 AM&quot;</span><br><span class="line">d.toLocaleTimeString(&#x27;zh-CN&#x27;) // &quot;上午12:00:00&quot;</span><br></pre></td></tr></table></figure>

<h2 id="4-6-8RegExp正则-x2F-x2F-找旧笔记对比着看"><a href="#4-6-8RegExp正则-x2F-x2F-找旧笔记对比着看" class="headerlink" title="4.6.8RegExp正则&#x2F;&#x2F;找旧笔记对比着看"></a>4.6.8RegExp正则&#x2F;&#x2F;找旧笔记对比着看</h2><h2 id="4-6-9JOSN"><a href="#4-6-9JOSN" class="headerlink" title="4.6.9JOSN"></a>4.6.9JOSN</h2><h4 id="9-1格式"><a href="#9-1格式" class="headerlink" title="9.1格式"></a>9.1格式</h4><ol>
<li><p>[]  {}</p>
<p>复合类型的值只能是数组或对象，不能是函数、正则表达式对象、日期对象。</p>
</li>
<li><p>String，Number，Boolean，NULL</p>
<p>原始类型的值只有四种：字符串、数值（必须以十进制表示，二进制十六进制都不行）、布尔值和null（不能使用NaN<code>, </code>Infinity, -Infinity和undefined）。</p>
</li>
<li><p>“asdf”</p>
<p>字符串必须使用双引号表示，不能使用单引号。</p>
</li>
<li><p>“key”：value</p>
<p>对象的键名必须放在双引号里面。</p>
</li>
<li><p>数组或对象最后一个成员的后面，不能加逗号。</p>
</li>
</ol>
<h4 id="9-2静态方法"><a href="#9-2静态方法" class="headerlink" title="9.2静态方法"></a>9.2静态方法</h4><ol>
<li><p>JSON.stringify	&#x2F;&#x2F;Json字符串化</p>
<ol>
<li><p>JSON.stringify(obj，[‘key1’,’key2’])	</p>
</li>
<li><p>JSON.stringify(value)</p>
<p>value可以是任何JSON格式支持的值，包括空对象、null、空数组</p>
</li>
<li><p>JSON.stringify(value,function)</p>
</li>
</ol>
</li>
<li><p>JSON.parse()              &#x2F;&#x2F;字符串JSON化</p>
</li>
</ol>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/JS/" rel="tag">JS</a></li></ul>

    </footer>
  </div>

    
 
    
</article>

    
    <article
  id="post-前端学习笔记/JS/Q4-JS-5语法基础"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2023/04/11/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/JS/Q4-JS-5%E8%AF%AD%E6%B3%95%E5%9F%BA%E7%A1%80/"
    >JS学习笔记-4.5语法基础（base阮一峰/gpt ）</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2023/04/11/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/JS/Q4-JS-5%E8%AF%AD%E6%B3%95%E5%9F%BA%E7%A1%80/" class="article-date">
  <time datetime="2023-04-11T03:34:47.000Z" itemprop="datePublished">2023-04-11</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/code/">code</a> / <a class="article-category-link" href="/categories/code/note/">note</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h1 id="4-5语法基础"><a href="#4-5语法基础" class="headerlink" title="4.5语法基础"></a>4.5语法基础</h1><h2 id="4-5-1数据类型转换"><a href="#4-5-1数据类型转换" class="headerlink" title="4.5.1数据类型转换"></a>4.5.1数据类型转换</h2><h2 id="4-5-2错误处理机制"><a href="#4-5-2错误处理机制" class="headerlink" title="4.5.2错误处理机制"></a>4.5.2错误处理机制</h2><h3 id="1-抛出异常"><a href="#1-抛出异常" class="headerlink" title="1.抛出异常"></a>1.抛出异常</h3><p>在 JavaScript 中,throw 语句用于抛出一个异常并停止运行。</p>
<p>1.函数参数校验</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">function divide(x, y) &#123;</span><br><span class="line">  // 如果 y 为 0,抛出异常</span><br><span class="line">  if (y === 0) &#123; </span><br><span class="line">    throw &#x27;除数不能为 0&#x27;; </span><br><span class="line">  &#125;</span><br><span class="line">  // 否则进行除法运算</span><br><span class="line">  return x / y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>2.范围或类型校验</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">function getMonthName(month) &#123;</span><br><span class="line">  // 如果 month 超出 1-12 的范围,抛出异常</span><br><span class="line">  if (month &lt; 1 || month &gt; 12) &#123;</span><br><span class="line">    throw &#x27;月份参数不在范围内&#x27;; </span><br><span class="line">  &#125;</span><br><span class="line">  // 否则返回月份名称</span><br><span class="line">  return [&#x27;January&#x27;, &#x27;February&#x27;, &#x27;March&#x27;, &#x27;April&#x27;, &#x27;May&#x27;, &#x27;June&#x27;, </span><br><span class="line">          &#x27;July&#x27;, &#x27;August&#x27;, &#x27;September&#x27;, &#x27;October&#x27;, &#x27;November&#x27;, &#x27;December&#x27;][month-1];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>3.自定义错误</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">// 定义自己的错误类型</span><br><span class="line">function CustomError(message) &#123;</span><br><span class="line">  this.message = message; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 之后可以抛出这个错误</span><br><span class="line">function doSomething() &#123;</span><br><span class="line">  // 如果出现错误情况,抛出自定义错误</span><br><span class="line">  if (someCondition) &#123;</span><br><span class="line">    throw new CustomError(&#x27;something went wrong!&#x27;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<p>4.终止程序执行</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 如果出现非常严重的错误,终止程序执行</span><br><span class="line">if (someSeriousError) &#123;</span><br><span class="line">  throw &#x27;程序遇到严重错误,终止执行&#x27;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="1-小结"><a href="#1-小结" class="headerlink" title="1.小结"></a>1.小结</h3><p>​	  1. 参数校验和输入验证</p>
<ol start="2">
<li>自定义错误和异常</li>
<li>严重错误情况下终止程序执行它使我们的程序在出现异常情况时可以抛出错误并准确地响应,而不是默默地失败,这是编写健壮程序的关键。</li>
</ol>
<h3 id="2尝试执行"><a href="#2尝试执行" class="headerlink" title="2尝试执行"></a>2尝试执行</h3><p>对于前端 JS 来说,try&#x2F;catch&#x2F;finally 更常用于:</p>
<ol>
<li><h4 id="捕获异常和错误处理。"><a href="#捕获异常和错误处理。" class="headerlink" title="捕获异常和错误处理。"></a>捕获异常和错误处理。</h4><p>这也是最主要和常见的用法。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">//异常处理</span><br><span class="line">try &#123;</span><br><span class="line">  somethingRisky();  // 可能抛出异常的代码</span><br><span class="line">&#125; catch (e) &#123;</span><br><span class="line">  handleError(e);   // 处理异常</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><h4 id="执行环境资源管理。"><a href="#执行环境资源管理。" class="headerlink" title="执行环境资源管理。"></a>执行环境资源管理。</h4><p>比如 DOM 元素创建后,无论是否使用成功,最后都remove DOM 元素。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">//dom元素（资源）管理</span><br><span class="line">let elem;</span><br><span class="line">try &#123;</span><br><span class="line">  elem = createElement();// 使用 elem</span><br><span class="line">&#125; catch (e) &#123;</span><br><span class="line">  handleError(e);</span><br><span class="line">&#125; finally &#123;</span><br><span class="line">  removeElement(elem);  // 移除 DOM 元素</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//或普通资源管理</span><br><span class="line">let resource;</span><br><span class="line">try &#123;</span><br><span class="line">  resource = acquireResource();  // 获取资源</span><br><span class="line">  // 使用资源</span><br><span class="line">&#125; finally &#123;</span><br><span class="line">  releaseResource(resource);   // 释放资源</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><h4 id="定时器和监听管理。"><a href="#定时器和监听管理。" class="headerlink" title="定时器和监听管理。"></a>定时器和监听管理。</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">//定时器和事件监听器管理 </span><br><span class="line">let timer;</span><br><span class="line">try &#123;</span><br><span class="line">  timer = setTimeout(() =&gt; &#123; /* ... */ &#125;, 1000);</span><br><span class="line">  // 延时1秒后执行</span><br><span class="line">&#125; finally &#123;</span><br><span class="line">  clearTimeout(timer);   // 清除定时器</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><h4 id="互斥"><a href="#互斥" class="headerlink" title="互斥"></a>互斥</h4><p>在前端 JS 中,try&#x2F;catch&#x2F;finally 用于资源互斥的情况并不太常见。这是因为:</p>
<ol>
<li>前端 JS 大多运行在单线程环境中,不会出现复杂的互斥资源争用情况。</li>
<li>前端 JS 中较少打开文件、数据库连接等低级资源操作,所以较少资源管理和释放的需求。</li>
<li>前端 JS 的执行环境大多提供了垃圾回收机制,可以自动管理和回收资源,减少了手动资源管理的需要。</li>
</ol>
</li>
</ol>
<h3 id="5-2-2小结"><a href="#5-2-2小结" class="headerlink" title="5.2.2小结"></a>5.2.2小结</h3><p><strong>捕获异常会了就行。资源处理学了dom就会了。</strong>前端用不上自己写互斥，有自动回收（todo：看看自动回收机制，有哪里需要手动回收的地方）。</p>
<p>无论定时器是否执行成功,最后都会清除定时器,防止定时器泄露。所以总的来说,尽管 try&#x2F;catch&#x2F;finally 也可用于资源互斥,但在前端 JS 中,更主要的是用于异常捕获、资源和执行环境管理。而复杂的低级资源互斥则较少出现。<br>无论 try 块中是否发生异常,finally 块中的代码都一定会执行,主要用于资源清理。catch 块用于捕获 try 块中的异常,并进行处理。</p>
<h2 id="4-5-3编程风格"><a href="#4-5-3编程风格" class="headerlink" title="4.5.3编程风格"></a>4.5.3编程风格</h2> 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/JS/" rel="tag">JS</a></li></ul>

    </footer>
  </div>

    
 
    
</article>

    
    <article
  id="post-前端学习笔记/JS/Q4-JS-4语言基础（图灵）"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2023/04/10/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/JS/Q4-JS-4%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%EF%BC%88%E5%9B%BE%E7%81%B5%EF%BC%89/"
    >JS学习笔记-4.4语言基础（base图灵）</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2023/04/10/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/JS/Q4-JS-4%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%EF%BC%88%E5%9B%BE%E7%81%B5%EF%BC%89/" class="article-date">
  <time datetime="2023-04-10T03:34:47.000Z" itemprop="datePublished">2023-04-10</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/code/">code</a> / <a class="article-category-link" href="/categories/code/note/">note</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h1 id="4-4语言基础"><a href="#4-4语言基础" class="headerlink" title="4.4语言基础"></a>4.4语言基础</h1><h2 id="4-4-1标识符"><a href="#4-4-1标识符" class="headerlink" title="4.4.1标识符"></a>4.4.1标识符</h2><p>所谓<strong>标识符</strong>，就是变量、函数、属性或函数参数的名称。标识符可以由一或多个下列字符组成：</p>
<ul>
<li>开头：字母、下划线或美元符$；</li>
<li>剩下：字母数字下划线美元符。</li>
</ul>
<h2 id="4-4-2三种声明变量的方法"><a href="#4-4-2三种声明变量的方法" class="headerlink" title="4.4.2三种声明变量的方法"></a>4.4.2三种声明变量的方法</h2><h3 id="1-var"><a href="#1-var" class="headerlink" title="1.var"></a>1.var</h3><p>​		1.基本知识</p>
<p>​					<strong>var作用域</strong>：函数的局部变量。</p>
<p>​					<strong>var的冗余声明</strong>：允许，所以很有可能在冗余声明后造成脏数据问题。</p>
<p>​					<strong>var的全局变量声明</strong>：想让let在函数里也能变成全局变量，就干脆不声明变量，直接用。比如在函数里直接写age&#x3D;30；</p>
<p>​		2.声明提升</p>
<p>​					var声明在后面也行，ECMAScript会自动把它提升到第一行。</p>
<h3 id="2-let"><a href="#2-let" class="headerlink" title="2.let"></a>2.let</h3><p>​		1.基本知识</p>
<p>​					<strong>let作用域</strong>：块级的局部变量。（块级就是for之类的也算）</p>
<p>​					<strong>let的冗余声明</strong>：不允许。就是不能在同一个块内let  a；let a；</p>
<p>​					<strong>let的全局变量声明</strong>：let写在全局里可以在页面生命周期内使用，但永远也不可能变成全局变量，它的类型只会是undefined。</p>
<p>​		2.声明提升</p>
<p>​					let不会声明提升，声明必须写在第一行。</p>
<p>​		3.用处</p>
<p>​					写在for循环里。</p>
<h3 id="3-const"><a href="#3-const" class="headerlink" title="3.const"></a><strong>3.const</strong></h3><p>​		1.基本知识</p>
<p>​					<strong>const重点</strong>：常量必须给初始值，且不能更改。</p>
<p>​					<strong>const作用域</strong>：和let一样</p>
<p>​					<strong>const的冗余声明</strong>：和let一样</p>
<p>​					<strong>let的全局变量声明</strong>：和let一样	</p>
<ol start="2">
<li>易错点<br>const 定义的变量不能被重新赋值,但是如果是对象或数组,其内部的属性是可以被修改的。<br>const 只保证变量名的指针是固定的,指向的对象或数组的内部状态是可以被修改的。</li>
</ol>
<h2 id="4-4-3小结"><a href="#4-4-3小结" class="headerlink" title="4.4.3小结"></a>4.4.3小结</h2><ol>
<li><h3 id="不使用var"><a href="#不使用var" class="headerlink" title="不使用var"></a>不使用var</h3><p>有了<code>let</code>和<code>const</code>，大多数开发者会发现自己不再需要<code>var</code>了。限制自己只使用<code>let</code>和<code>const</code>有助于提升代码质量，因为变量有了明确的作用域、声明位置，以及不变的值。</p>
</li>
<li><h3 id="const优先，let次之"><a href="#const优先，let次之" class="headerlink" title="const优先，let次之"></a>const优先，let次之</h3><p>使用<code>const</code>声明可以让浏览器运行时强制保持变量不变，也可以让静态代码分析工具提前发现不合法的赋值操作。因此，很多开发者认为应该优先使用<code>const</code>来声明变量，只在提前知道未来会有修改时，再使用<code>let</code>。这样可以让开发者更有信心地推断某些变量的值永远不会变，同时也能迅速发现因意外赋值导致的非预期行为。</p>
</li>
<li><h3 id="const有易错点"><a href="#const有易错点" class="headerlink" title="const有易错点"></a>const有易错点</h3><p>const 定义的变量不能被重新赋值,但是如果是对象或数组,其内部的属性是可以被修改的。<br>const 只保证变量名的指针是固定的,指向的对象或数组的内部状态是可以被修改的。</p>
</li>
</ol>
<p>在使用<code>var</code>的时候，最常见的问题就是对迭代变量的奇特声明和修改：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">for (var i = 0; i &lt; 5; ++i) &#123;</span><br><span class="line">    setTimeout(() =&gt; console.log(i), 0)</span><br><span class="line">&#125;</span><br><span class="line">// 你可能以为会输出0、1、2、3、4</span><br><span class="line">// 实际上会输出5、5、5、5、5</span><br></pre></td></tr></table></figure>

<p>之所以会这样，是因为在退出循环时，迭代变量保存的是导致循环退出的值：5。在之后执行超时逻辑时，所有的<code>i</code>都是同一个变量，因而输出的都是同一个最终值。</p>
<p>而在使用<code>let</code>声明迭代变量时，<strong>JavaScript引擎在后台会为每个迭代循环声明一个新的迭代变量</strong>。每个<code>setTimeout</code>引用的都是不同的变量实例，所以<code>console.log</code>输出的是我们期望的值，也就是循环执行过程中每个迭代变量的值。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">for (let i = 0; i &lt; 5; ++i) &#123;</span><br><span class="line">    setTimeout(() =&gt; console.log(i), 0)</span><br><span class="line">&#125;</span><br><span class="line">// 会输出0、1、2、3、4</span><br></pre></td></tr></table></figure>

<p>这种每次迭代声明一个独立变量实例的行为适用于所有风格的<code>for</code>循环，包括<code>for-in</code>和<code>for-of</code>循环。4.3.2标识符.</p>
<h2 id="易错点："><a href="#易错点：" class="headerlink" title="易错点："></a>易错点：</h2><p>null：空指针</p>
<p>NULL未声明的变量</p>
<h2 id="4-4-4各种符号"><a href="#4-4-4各种符号" class="headerlink" title="4.4.4各种符号"></a>4.4.4各种符号</h2><h3 id="4-4-4-1字符串连接的两种方法"><a href="#4-4-4-1字符串连接的两种方法" class="headerlink" title="4.4.4.1字符串连接的两种方法"></a>4.4.4.1字符串连接的两种方法</h3><h5 id="1"><a href="#1" class="headerlink" title="1.+"></a>1.+</h5><p>​		“adf”+“asd”</p>
<h5 id="2-x3D"><a href="#2-x3D" class="headerlink" title="2.+&#x3D;"></a>2.+&#x3D;</h5><p>​		let a&#x3D;“dfe”</p>
<p>​		let b&#x3D;“jin”</p>
<p>​		b+&#x3D;a</p>
<h3 id="4-4-4-2字符串长度"><a href="#4-4-4-2字符串长度" class="headerlink" title="4.4.4.2字符串长度"></a>4.4.4.2字符串长度</h3><h5 id="1-String-length（只能用于字符串）"><a href="#1-String-length（只能用于字符串）" class="headerlink" title="1.String.length（只能用于字符串）"></a>1.String.length（只能用于字符串）</h5><p>​		(123).length不成立</p>
<p>​		“123”.length</p>
<h3 id="4-4-4-3字符串也能当成数组用"><a href="#4-4-4-3字符串也能当成数组用" class="headerlink" title="4.4.4.3字符串也能当成数组用"></a>4.4.4.3字符串也能当成数组用</h3><h5 id="1-string-0"><a href="#1-string-0" class="headerlink" title="1.string[0]"></a>1.string[0]</h5><p>​				let string&#x3D;“asd”</p>
<p>​				string[0]</p>
<p>​				》’a’</p>
<h5 id="2-string-1"><a href="#2-string-1" class="headerlink" title="2.string[-1]"></a>2.string[-1]</h5><h5 id="3-string-n"><a href="#3-string-n" class="headerlink" title="3.string[-n]"></a>3.string[-n]</h5><h2 id="4-4-4小结"><a href="#4-4-4小结" class="headerlink" title="4.4.4小结"></a>4.4.4小结</h2><p>-*&#x2F;号，会使原始类型隐式转换成number类型</p>
<p>也就是说加减乘除里只有加号需要注意两端变量的类型（只有加号重载了）</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1 - &#x27;2&#x27; // -1</span><br><span class="line">1 * &#x27;2&#x27; // 2</span><br><span class="line">1 / &#x27;2&#x27; // 0.5</span><br></pre></td></tr></table></figure>

<h2 id="4-4-5数组"><a href="#4-4-5数组" class="headerlink" title="4.4.5数组"></a>4.4.5数组</h2><h5 id="1-多维数组"><a href="#1-多维数组" class="headerlink" title="1.多维数组"></a>1.多维数组</h5><p>​		1.声明</p>
<p>​				const arr &#x3D; [</p>
<p>​				  [1, 2, 3],<br>​				  [4, 5, 6],<br>​				  [7, 8, 9],<br>​				  [[10, 11, 12], 13, 14]<br>​				];</p>
<p>​				const ourPets &#x3D; [  &#x2F;&#x2F;数组嵌套object嵌套数组</p>
<p>​			  {<br>​			    animalType: “cat”,<br>​			    names: [<br>​			      “Meowzer”,<br>​			      “Fluffy”,<br>​			      “Kit-Cat”<br>​			    ]<br>​			  },<br>​			  {<br>                animalType: “dog”,<br>                names: [<br>​     			 “Spot”,<br>                  “Bowser”,<br>                  “Frankie”<br>​			    ]<br>​			  }<br>​			];</p>
<p>​		2.访问</p>
<p>​				<strong>const subarray &#x3D; arr[3];</strong><br>​				<strong>const nestedSubarray &#x3D; arr【3]【0];</strong><br>​				<strong>const element &#x3D; arr【3]【0]【1];</strong></p>
<p>​				<strong>ourPets[0].names[1];</strong><br>​				<strong>ourPets[1].names[0];</strong></p>
<p>​		3.操作</p>
<p>​					3.1push尾插</p>
<p>​								arr.push([“a”,”b”]);</p>
<p>​					3.2pop尾删（作返回值）</p>
<p>​								arr.pop();</p>
<p>​					3.3shift头删（作返回值）</p>
<p>​								arr.shift();</p>
<p>​					3.4unshift头插</p>
<p>​								arr.unshift();</p>
<h2 id="4-4-5小结"><a href="#4-4-5小结" class="headerlink" title="4.4.5小结"></a>4.4.5小结</h2><p>无</p>
<h2 id="4-4-6函数"><a href="#4-4-6函数" class="headerlink" title="4.4.6函数"></a>4.4.6函数</h2><h1 id="1-函数也可返回undefined（说明了什么？什么时候会返回这种？用于写错代码了的时候不会报错所以不用写异常处理了是么？）"><a href="#1-函数也可返回undefined（说明了什么？什么时候会返回这种？用于写错代码了的时候不会报错所以不用写异常处理了是么？）" class="headerlink" title="1.函数也可返回undefined（说明了什么？什么时候会返回这种？用于写错代码了的时候不会报错所以不用写异常处理了是么？）"></a>1.函数也可返回undefined（说明了什么？什么时候会返回这种？用于写错代码了的时候不会报错所以不用写异常处理了是么？）</h1><h2 id="4-4-7运算符"><a href="#4-4-7运算符" class="headerlink" title="4.4.7运算符"></a>4.4.7运算符</h2><p>1.等于</p>
<p>​		&#x3D;&#x3D;</p>
<p>​		&#x3D;&#x3D;&#x3D;</p>
<p>2.不等于</p>
<p>​		!&#x3D;</p>
<p>​		!&#x3D;&#x3D;</p>
<p>3.与或非</p>
<p>​		&amp;&amp;   ||  ！</p>
<p>4.大于小于</p>
<p>​		&gt;&lt;</p>
<p>​		注：如果是原始类型比较，那就会隐式转换成number类型</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">5 &gt; &#x27;4&#x27; // true</span><br><span class="line">// 等同于 5 &gt; Number(&#x27;4&#x27;)</span><br><span class="line">// 即 5 &gt; 4</span><br></pre></td></tr></table></figure>

<h2 id="4-4-7小结"><a href="#4-4-7小结" class="headerlink" title="4.4.7小结"></a>4.4.7小结</h2><p>&lt;&gt;号，会使原始类型隐式转换成number类型</p>
<h2 id="4-4-8对象（键值对）"><a href="#4-4-8对象（键值对）" class="headerlink" title="4.4.8对象（键值对）"></a>4.4.8对象（键值对）</h2><h6 id="1-创建对象"><a href="#1-创建对象" class="headerlink" title="1.创建对象"></a>1.创建对象</h6><p>​		法一：字面量（花括号里放固定的值）</p>
<p>​				可以使用数字作为属性。 </p>
<p>​				可以省略单字字符串属性中的引号。</p>
<p>​				有非字符串属性的话，JavaScript 会自动将它们转为字符串。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> cat = &#123;</span><br><span class="line">  <span class="string">&quot;name&quot;</span>: <span class="string">&quot;Whiskers&quot;</span>,</span><br><span class="line">  <span class="string">&quot;legs&quot;</span>: <span class="number">4</span>,</span><br><span class="line">  <span class="string">&quot;tails&quot;</span>: <span class="number">1</span>,</span><br><span class="line">  <span class="string">&quot;enemies&quot;</span>: [<span class="string">&quot;Water&quot;</span>, <span class="string">&quot;Dogs&quot;</span>]</span><br><span class="line">  <span class="attr">make</span>: <span class="string">&quot;Ford&quot;</span>,</span><br><span class="line">  <span class="number">5</span>: <span class="string">&quot;five&quot;</span>,</span><br><span class="line">  <span class="string">&quot;model&quot;</span>: <span class="string">&quot;focus&quot;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>​		法二：new</p>
<p>​					var  a&#x3D;new Object（）；</p>
<p>​					a.age&#x3D;”15”;</p>
<p>​					a.name&#x3D;”xcy”;</p>
<p>​					a.sayHello&#x3D;function(){				&#x2F;&#x2F;sayHello方法，里面是个匿名函数（不传参的函数）</p>
<p>​							return “hello!!!!!!!”;</p>
<p>​					}</p>
<p>​					console.log(a.age);</p>
<p>​					</p>
<p>​		法三：构造函数(封装函数，和new一起用，相当于用于继承）</p>
<p>​					&#x2F;&#x2F;一定要用this，不然生成的多个子对象会被最后一个的值覆盖</p>
<p>​					function    Father（uname,uage）{</p>
<p>​									this.name&#x3D;uname;</p>
<p>​									this.age&#x3D;uage;</p>
<p>​									this.sayHello&#x3D;function(strHi){</p>
<p>​												return strHi;</p>
<p>​									}</p>
<p>​					}</p>
<p>​					&#x2F;&#x2F;实例化</p>
<p>​					var son&#x3D;new Father(“xcy”,”15”);</p>
<p>​					son.sayHello(“Hello!!”);</p>
<p>​					son.sayHello(“Hi~”);</p>
<h6 id="2-增加对象的新属性"><a href="#2-增加对象的新属性" class="headerlink" title="2.增加对象的新属性"></a>2.增加对象的新属性</h6><p>1.点</p>
<p>​				ourDog.bark &#x3D; “bow-wow”;</p>
<p>2.中括号</p>
<p>​				ourDog[“bark”] &#x3D; “bow-wow”;</p>
<h6 id="3-删除对象的属性"><a href="#3-删除对象的属性" class="headerlink" title="3.删除对象的属性"></a>3.删除对象的属性</h6><p>1.delete</p>
<p>​				const ourDog &#x3D; {<br>                  “name”: “Camper”,<br>​				  “legs”: 4,<br>​				  “tails”: 1,<br>​				  “friends”: [“everything!”],<br>​				  “bark”: “bow-wow”<br>​				};</p>
<p>​				delete ourDog.bark;</p>
<h6 id="4-改属性"><a href="#4-改属性" class="headerlink" title="4.改属性"></a>4.改属性</h6><p>1.点</p>
<p>​				ourDog.name &#x3D; “Happy Camper”; </p>
<p>2.中括号</p>
<p>​				 ourDog[“name”] &#x3D; “Happy Camper”;</p>
<h6 id="5-查属性"><a href="#5-查属性" class="headerlink" title="5.查属性 . []"></a>5.查属性 . []</h6><p>​		2.1用.访问属性（属性名没有空格）</p>
<p>​				const myObj &#x3D; {<br>​				  prop1: “val1”,<br>​				  prop2: “val2”<br>​				};</p>
<p>​				const prop1val &#x3D; myObj.prop1;<br>​				const prop2val &#x3D; myObj.prop2;</p>
<p>​		2.2用[]访问属性（属性名有空格）</p>
<p>​				如果属性名中包含空格，就必须使用方括号表示法来获取它的属性值。</p>
<p>​				如果属性名中包含空格，就必须使用引号（单引号或双引号）将它们包裹起来。</p>
<p>​				const myObj &#x3D; {<br>                  “Space Name”: “Kirk”,<br>​				  “More Space”: “Spock”,<br>​				  “NoSpace”: “USS Enterprise”<br>​				};</p>
<p>​				myObj[“Space Name”];<br>​				myObj[‘More Space’];<br>​				myObj[“NoSpace”];</p>
<p>​		2.3用变量访问</p>
<p>​				1.基础</p>
<p>​					const dogs &#x3D; {<br>​					  Fido: “Mutt”,<br>​					  Hunter: “Doberman”,<br>​					  Snoopie: “Beagle”<br>​					};</p>
<p>​					const myDog &#x3D; “Hunter”;<br>​					const myBreed &#x3D; dogs[myDog];<br>​					console.log(myBreed);</p>
<p>​				2.复合</p>
<p><img src="../markdown-img/Q4-JS-4语言基础（图灵）.assets\image-20230414163952811.png" alt="image-20230414163952811" style="zoom:33%;" /><img src="../markdown-img/Q4-JS-4语言基础（图灵）.assets\image-20230414174937591.png" alt="image-20230414174937591" style="zoom:50%;" /></p>
<p><img src="../markdown-img/Q4-JS-4语言基础（图灵）.assets\image-20230414164428406.png" alt="image-20230414164428406" style="zoom:50%;" /><img src="../markdown-img/Q4-JS-4语言基础（图灵）.assets\image-20230414173434503.png" alt="image-20230414173434503" style="zoom:50%;" /></p>
<p>​								</p>
<h6 id="6-查嵌套对象的属性"><a href="#6-查嵌套对象的属性" class="headerlink" title="6.查嵌套对象的属性"></a>6.查嵌套对象的属性</h6><p>​		const ourStorage &#x3D; </p>
<p>​		{<br>​		  “desk”: </p>
<p>​			  {<br>​		   		 “drawer”: “stapler”<br>​		  	},<br>​		  “cabinet”: </p>
<p>​			{<br>           	 “top drawer”:</p>
<p>​						 {<br>                              “folder1”: “a file”,<br>                              “folder2”: <strong>“secrets”</strong><br>                        },<br>                “bottom drawer”: “soda”<br>              }<br>​		};</p>
<p>​		<strong>ourStorage.cabinet[“top drawer”].folder2;</strong></p>
<h6 id="7-复杂对象举例（JS的糅杂数据结构）"><a href="#7-复杂对象举例（JS的糅杂数据结构）" class="headerlink" title="7.复杂对象举例（JS的糅杂数据结构）"></a>7.复杂对象举例（JS的糅杂数据结构）</h6><p>const ourMusic &#x3D; [<br>  {<br>    “artist”: “Daft Punk”,<br>    “title”: “Homework”,<br>    “release_year”: 1997,<br>    “formats”: [<br>      “CD”,<br>      “Cassette”,<br>      “LP”<br>    ],<br>    “gold”: true<br>  }<br>];</p>
<p><strong>提示：</strong>数组中有多个 JSON 对象的时候，对象与对象之间要用逗号隔开。</p>
<h6 id="8-判断对象是否有指定属性"><a href="#8-判断对象是否有指定属性" class="headerlink" title="8.判断对象是否有指定属性"></a>8.判断对象是否有指定属性</h6><p>1.方法</p>
<p>​		.hasOwnProperty(propname)</p>
<p>2.举例</p>
<p>​		myObj.hasOwnProperty(“top”);<br>​		myObj.hasOwnProperty(“middle”);</p>
<h6 id="9-对象遍历for-in"><a href="#9-对象遍历for-in" class="headerlink" title="9.对象遍历for  in"></a>9.对象遍历for  in</h6><p>1.取属性名（而非整个属性）</p>
<p>​		for(var k in son){</p>
<p>​		console.log（k）;</p>
<p>​		}</p>
<p>2.取属性值(只能用【】不能用   .    )</p>
<p>​		console.log（k.name);</p>
<h3 id="4-4-8小结"><a href="#4-4-8小结" class="headerlink" title="4.4.8小结"></a>4.4.8小结</h3><p>1.对象之间赋值是引用的  </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">let a = new Object();  </span><br><span class="line">let b = a;                //则b===a（地址完全一样）。</span><br></pre></td></tr></table></figure>



<h3 id="4-4-9其它"><a href="#4-4-9其它" class="headerlink" title="4.4.9其它"></a>4.4.9其它</h3><h4 id="1-随机数"><a href="#1-随机数" class="headerlink" title="1.随机数"></a>1.随机数</h4><p>​	1.随机小数[0,1)</p>
<p>​			let a&#x3D;Math.random();</p>
<p>​	2.向下取整</p>
<p>​			Math.floor(a) ；</p>
<p>​	3.生成某范围内的随机数</p>
<p>​			Math.floor(Math.random() * (myMax - myMin + 1) + myMin)；</p>
<h4 id="2-递归"><a href="#2-递归" class="headerlink" title="2.递归"></a>2.递归</h4><p>​	1.</p>
<p>​	2.</p>
<p>​	3.</p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/JS/" rel="tag">JS</a></li></ul>

    </footer>
  </div>

    
 
    
</article>

    
    <article
  id="post-前端学习笔记/JS/Q4-JS-3脚本加载基础（图灵）"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2023/04/09/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/JS/Q4-JS-3%E8%84%9A%E6%9C%AC%E5%8A%A0%E8%BD%BD%E5%9F%BA%E7%A1%80%EF%BC%88%E5%9B%BE%E7%81%B5%EF%BC%89/"
    >JS学习笔记-4.3脚本加载（base图灵）</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2023/04/09/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/JS/Q4-JS-3%E8%84%9A%E6%9C%AC%E5%8A%A0%E8%BD%BD%E5%9F%BA%E7%A1%80%EF%BC%88%E5%9B%BE%E7%81%B5%EF%BC%89/" class="article-date">
  <time datetime="2023-04-09T03:34:47.000Z" itemprop="datePublished">2023-04-09</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/code/">code</a> / <a class="article-category-link" href="/categories/code/note/">note</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h1 id="4-3脚本的加载时机"><a href="#4-3脚本的加载时机" class="headerlink" title="4.3脚本的加载时机"></a>4.3脚本的加载时机</h1><h2 id="4-3-1script标签"><a href="#4-3-1script标签" class="headerlink" title="4.3.1script标签"></a>4.3.1script标签</h2><h3 id="1-属性"><a href="#1-属性" class="headerlink" title="1.属性"></a>1.属性</h3><p>​	1.crossorigin：可选。</p>
<p>​		配置相关请求的CORS（跨源资源共享）设置。默认不使用CORS。	</p>
<ul>
<li>​				crossorigin&#x3D;  “anonymous”配置文件请求不必设置凭据标志。</li>
<li>​				crossorigin&#x3D;”use-credentials”设置凭据 标志，意味着出站请求会包含凭据。</li>
</ul>
<p>​	2.integrity：可选。</p>
<p>​			允许比对加密签名以验证子资源完整性。用于确保中介网没有恶意篡改。</p>
<p>​	3.async：异步执行脚本, 可选。</p>
<p>​			表示立即开始下载脚本文件，但不会阻止其他资源的下载（如图片、CSS 等），也不会等待页面完全加载完毕</p>
<p>​			与<code>defer</code>不同的是，标记为<code>async</code>的脚本<strong>并不保证能按照它们出现的次序执行</strong>。</p>
<p>​			因此，该属性常用于不需要等待页面加载完毕就可以立即执行的脚本。</p>
<p>​	4.defer：可选。</p>
<p>​			表示<strong>外部脚本</strong>可以延迟到文档完全被解析和显示之后再执行。</p>
<p>​			因此，该属性常用于，我们想要延迟脚本的执行的情况。</p>
<p>5.举例</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">3.async实例</span><br><span class="line">    &lt;h1&gt;async 示例&lt;/h1&gt;</span><br><span class="line">    &lt;script src=&quot;./example.js&quot; async&gt;&lt;/script&gt;</span><br><span class="line">    &lt;p&gt;此段文字不受脚本影响，可瞬间加载。&lt;/p&gt;</span><br><span class="line"></span><br><span class="line">由于 async 属性的作用，浏览器会立即下载该 JavaScript 文件，并在下载完成后会立即执行其中的代码。同时，页面内容也会立即显示出来，而不必等待 JavaScript 文件的下载和执行。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">4.defer实例</span><br><span class="line">    &lt;h1&gt;defer 示例&lt;/h1&gt;</span><br><span class="line">    &lt;script src=&quot;./example.js&quot; defer&gt;&lt;/script&gt;</span><br><span class="line">    &lt;p&gt;此段文字受脚本影响，需要等待脚本完成执行后才能完全加载。&lt;/p&gt;</span><br><span class="line"></span><br><span class="line">由于 defer 属性的作用，浏览器会延迟 JavaScript 文件的执行，直到页面完全加载完毕并且 JavaScript 文件下载完成后才会执行其中的代码。在执行完脚本后，页面内容也会完全显示出来。需要注意的是，如果有多个带有 defer 属性的脚本文件，它们会按照它们在文档中出现的顺序依次执行。</span><br><span class="line"></span><br><span class="line">综上所述，async 和 defer 属性可以用来控制 JavaScript 文件的下载和执行时间，从而优化页面加载速度和用户体验。</span><br></pre></td></tr></table></figure>

<h2 id="4-3-2动态加载脚本（未细看）"><a href="#4-3-2动态加载脚本（未细看）" class="headerlink" title="4.3.2动态加载脚本（未细看）"></a>4.3.2动态加载脚本（未细看）</h2><h3 id="1-本质"><a href="#1-本质" class="headerlink" title="1.本质"></a>1.本质</h3><p>因为JavaScript可以使用DOM API，所以通过向DOM中动态添加<code>script</code>元素同样可以加载指定的脚本。只要创建一个<code>script</code>元素并将其添加到DOM即可。</p>
<h3 id="2-实例"><a href="#2-实例" class="headerlink" title="2.实例"></a>2.实例</h3><p>JavaScript 代码可以通过创建 script 元素并将其添加到 DOM 中的方式来加载脚本。以下是一个示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">javascript复制代码// 创建一个 script 元素</span><br><span class="line">let script = document.createElement(&#x27;script&#x27;);</span><br><span class="line">// 设置该 script 元素要加载的 JavaScript 脚本文件路径</span><br><span class="line">script.src = &#x27;gibberish.js&#x27;;</span><br><span class="line">// 将创建的 script 元素添加到 head 元素中</span><br><span class="line">document.head.appendChild(script);</span><br></pre></td></tr></table></figure>

<p>这段代码首先使用 <code>document.createElement()</code> 方法创建一个 <code>script</code> 元素，然后将要加载的 JavaScript 文件路径设置为 <code>script.src</code> 属性的值，并将创建的 <code>script</code> 元素添加到了 <code>head</code> 元素中。</p>
<p>需要注意的是，默认情况下以这种方式创建的 <code>script</code> 元素都是以异步方式加载的，相当于添加了 <code>async</code> 属性。这意味着，当执行到上述代码时，浏览器会立即开始下载指定的 JavaScript 文件，但不会阻止其他资源（如图片、CSS 等）的下载，也不会等待页面内容完全加载完毕。</p>
<p>如果要统一动态脚本的加载行为，可以明确设置为同步加载。在上述示例代码中，只需要为创建的 <code>script</code> 元素设置 <code>async</code> 属性的值为 <code>false</code> 即可：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">javascript复制代码// 创建一个 script 元素</span><br><span class="line">let script = document.createElement(&#x27;script&#x27;);</span><br><span class="line">// 设置该 script 元素要加载的 JavaScript 脚本文件路径</span><br><span class="line">script.src = &#x27;gibberish.js&#x27;;</span><br><span class="line">// 明确设置该 script 元素以同步方式加载</span><br><span class="line">script.async = false;</span><br><span class="line">// 将创建的 script 元素添加到 head 元素中</span><br><span class="line">document.head.appendChild(script);</span><br></pre></td></tr></table></figure>

<p>需要注意的是，以这种方式获取的资源对浏览器预加载器是不可见的，这意味着它们在资源获取队列中的优先级比较低。如果想要让预加载器知道这些动态请求的文件存在，可以在文档头部显式声明它们：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">html复制代码&lt;!-- 显式声明要预加载的 JavaScript 文件 --&gt;</span><br><span class="line">&lt;link rel=&quot;preload&quot; href=&quot;gibberish.js&quot;&gt;</span><br></pre></td></tr></table></figure>

<p>在上述示例代码中，使用 <code>rel</code> 属性值为 <code>preload</code> 来声明该文件是要预加载的，<code>href</code> 属性指定要加载的文件路径。</p>
<p>总之，通过动态创建 <code>script</code> 标签并将其添加到 DOM 中的方式来加载 JavaScript 脚本，可以灵活地控制 JavaScript 的加载时间，提高页面性能。但需要注意的是，如果使用异步加载，可能会影响页面其他资源的下载和渲染，而如果使用同步加载，则可能会影响页面的加载速度。因此，需要根据具体情况进行权衡和选择。</p>
<h2 id="4-3-3弱类型进行转换"><a href="#4-3-3弱类型进行转换" class="headerlink" title="4.3.3弱类型进行转换"></a>4.3.3弱类型进行转换</h2><p>​		JS是弱类型，想要类型转换不用强制类型转换</p>
<p>​		var  a&#x3D;“asdf”；</p>
<p>​		a&#x3D;100；&#x2F;&#x2F;a由string类型转换为number类型。</p>
<h2 id="4-3-4小结"><a href="#4-3-4小结" class="headerlink" title="4.3.4小结"></a>4.3.4小结</h2><p>JavaScript是通过<code>&lt;script&gt;</code>元素插入到HTML页面中的。这个元素可用于把JavaScript代码嵌入到HTML页面中，跟其他标记混合在一起，也可用于引入保存在外部文件中的JavaScript。本章的重点可以总结如下。</p>
<ul>
<li>要包含外部JavaScript文件，必须将<code>src</code>属性设置为要包含文件的URL。文件可以跟网页在同一台服务器上，也可以位于完全不同的域。</li>
<li>所有<code>&lt;script&gt;</code>元素会依照它们在网页中出现的次序被解释。在不使用<code>defer</code>和<code>async</code>属性的情况下，包含在<code>&lt;script&gt;</code>元素中的代码必须严格按次序解释。</li>
<li>对不推迟执行的脚本，浏览器必须解释完位于<code>&lt;script&gt;</code>元素中的代码，然后才能继续渲染页面的剩余部分。为此，通常应该把<code>&lt;script&gt;</code>元素放到页面末尾，介于主内容之后及<code>&lt;/body&gt;</code>标签之前。</li>
<li>可以使用<code>defer</code>属性把脚本推迟到文档渲染完毕后再执行。推迟的脚本原则上按照它们被列出的次序执行。</li>
<li>可以使用<code>async</code>属性表示脚本不需要等待其他脚本，同时也不阻塞文档渲染，即异步加载。异步脚本不能保证按照它们在页面中出现的次序执行。</li>
<li>通过使用<code>&lt;noscript&gt;</code>元素，可以指定在浏览器不支持脚本时显示的内容。如果浏览器支持并启用脚本，则<code>&lt;noscript&gt;</code>元素中的任何内容都不会被渲染。</li>
</ul>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/JS/" rel="tag">JS</a></li></ul>

    </footer>
  </div>

    
 
    
</article>

    
    <article
  id="post-前端学习笔记/JS/Q4-JS-2标准库（mooc）"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2023/04/08/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/JS/Q4-JS-2%E6%A0%87%E5%87%86%E5%BA%93%EF%BC%88mooc%EF%BC%89/"
    >JS学习笔记-4.2JS标准库（base mooc）</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2023/04/08/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/JS/Q4-JS-2%E6%A0%87%E5%87%86%E5%BA%93%EF%BC%88mooc%EF%BC%89/" class="article-date">
  <time datetime="2023-04-08T03:34:47.000Z" itemprop="datePublished">2023-04-08</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/code/">code</a> / <a class="article-category-link" href="/categories/code/note/">note</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h1 id="3-2JS标准库（mooc）"><a href="#3-2JS标准库（mooc）" class="headerlink" title="3.2JS标准库（mooc）"></a>3.2JS标准库（mooc）</h1><h2 id="1-Object对象"><a href="#1-Object对象" class="headerlink" title="1.Object对象"></a>1.Object对象</h2><p><a target="_blank" rel="noopener" href="https://wangdoc.com/javascript/stdlib/object">Object 对象 - JavaScript 教程 - 网道 (wangdoc.com)</a></p>
<ol>
<li>Object() 是用来创建一个新的对象的构造函数；</li>
<li>Object.keys() 和 Object.getOwnPropertyNames() 是用来获取对象属性名的方法；</li>
<li>Object.prototype.toString() 是判断数据类型的重要方法；</li>
<li>Object.prototype.hasOwnProperty() 可以用来判断一个对象是否包含指定的属性。</li>
</ol>
<p>需要注意的是，Object.keys()和Object.getOwnPropertyNames()这两个方法虽然类似，但是在获取对象属性名时有一些不同的地方。</p>
<h2 id="2-属性描述对象"><a href="#2-属性描述对象" class="headerlink" title="2.属性描述对象"></a>2.属性描述对象</h2><p><a target="_blank" rel="noopener" href="https://wangdoc.com/javascript/stdlib/attributes">属性描述对象 - JavaScript 教程 - 网道 (wangdoc.com)</a></p>
<ol>
<li><p>Object.getOwnPropertyDescriptor() 获取对象属性的描述符，并返回一个包含属性信息的对象；</p>
<p>通常在需要了解或控制属性的特性（例如是否可枚举、可写、可配置）时使用。</p>
</li>
<li><p>Object.getOwnPropertyNames() 返回一个由一个对象自己拥有的属性名称组成的数组，不包括继承的属性名称；</p>
<p>通常用于遍历对象的属性。</p>
</li>
<li><p>Object.defineProperty() 给对象添加新属性或者修改已存在属性并返回修改后的对象；</p>
<p>通常在需要控制属性的一些特性时使用。</p>
</li>
<li><p>Object.defineProperties() 批量添加属性或修改已存在属性并返回修改后的对象；</p>
<p>通常用于一次性操作多个属性。</p>
</li>
<li><p>Object.prototype.propertyIsEnumerable() 判断对象的某个属性是否可枚举，返回一个布尔值；</p>
<p>通常用于判断对象的属性是否可以通过 for…in 循环枚举出来。</p>
</li>
<li><p>value等元属性 属性描述符对象中的 value、get 和 set 分别表示属性的值、getter 函数和 setter 函数；</p>
<p>通常用于控制属性的访问和赋值行为。</p>
</li>
<li><p>Object.preventExtensions() 禁止一个对象添加新属性并返回原对象；</p>
<p>通常在需要冻结一个对象时使用。</p>
</li>
<li><p>Object.isExtensible() 判断一个对象是否可扩展，返回一个布尔值；</p>
<p>通常用于判断对象是否可以添加新属性。</p>
</li>
<li><p>Object.seal() 让一个对象不可扩展并将其所有属性的 configurable 特性设置为 false；</p>
<p>通常用于保护对象，防止意外修改其属性。</p>
</li>
<li><p>Object.isSealed() 判断一个对象是否被封闭，返回一个布尔值；</p>
<p>通常用于判断对象是否可以添加或删除属性。</p>
</li>
<li><p>Object.freeze() 冻结一个对象并将其所有属性的 writable、configurable 特性都设置为 false；</p>
<p>通常用于保护对象，防止任何修改。</p>
</li>
<li><p>Object.isFrozen() 判断一个对象是否被冻结，返回一个布尔值；</p>
<p>通常用于判断对象是否可以被修改。</p>
</li>
</ol>
<p>这些方法在前端和 Node.js 开发中经常用得到。例如在 React 中，通过 Object.freeze() 冻结组件的 props 和 state 属性，防止意外修改；在 Vue.js 中，则通过 Object.defineProperty() 和 Object.defineProperties() 来实现双向绑定等功能。这些方法使用方便灵活，但需要注意不同方法的使用场景和属性特性，以避免出现意外错误。</p>
<ol>
<li>Object.getOwnPropertyDescriptor() - 获取一个对象上指定属性的描述符</li>
</ol>
<p>该方法用于获取一个对象上指定属性的描述符。返回一个包含获取的描述符属性的对象。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123; <span class="attr">name</span>: <span class="string">&#x27;Tom&#x27;</span>, <span class="attr">age</span>: <span class="number">20</span> &#125;</span><br><span class="line"><span class="keyword">const</span> descriptor = <span class="title class_">Object</span>.<span class="title function_">getOwnPropertyDescriptor</span>(obj, <span class="string">&#x27;name&#x27;</span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(descriptor)</span><br><span class="line"><span class="comment">// 输出: &#123; value: &#x27;Tom&#x27;, writable: true, enumerable: true, configurable: true &#125;</span></span><br></pre></td></tr></table></figure>

<ol>
<li>Object.getOwnPropertyNames() - 获取一个对象的所有属性名（包括不可遍历的属性名）</li>
</ol>
<p>该方法用于获取一个对象的所有属性名，返回一个数组，包括不可遍历的属性名。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123; <span class="attr">name</span>: <span class="string">&#x27;Tom&#x27;</span>, <span class="attr">age</span>: <span class="number">20</span> &#125;</span><br><span class="line"><span class="keyword">const</span> propertyNames = <span class="title class_">Object</span>.<span class="title function_">getOwnPropertyNames</span>(obj)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(propertyNames)</span><br><span class="line"><span class="comment">// 输出: [&quot;name&quot;, &quot;age&quot;]</span></span><br></pre></td></tr></table></figure>

<ol>
<li>Object.defineProperty() - 给一个对象定义一个新属性</li>
</ol>
<p>该方法用于给一个对象定义一个新属性。接收三个参数：对象obj、定义的属性名和属性描述符descriptor。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;&#125;</span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">defineProperty</span>(obj, <span class="string">&#x27;name&#x27;</span>, &#123;</span><br><span class="line">  <span class="attr">value</span>: <span class="string">&#x27;Tom&#x27;</span>,</span><br><span class="line">  <span class="attr">writable</span>: <span class="literal">true</span>,</span><br><span class="line">  <span class="attr">enumerable</span>: <span class="literal">false</span>,</span><br><span class="line">  <span class="attr">configurable</span>: <span class="literal">true</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj.<span class="property">name</span>) <span class="comment">// 输出: Tom</span></span><br></pre></td></tr></table></figure>

<ol>
<li>Object.defineProperties() - 给对象定义多个属性</li>
</ol>
<p>该方法用于给一个对象定义多个属性。接收两个参数：对象obj和一个包含属性名及对应属性描述符的对象。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;&#125;</span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">defineProperties</span>(obj, &#123;</span><br><span class="line">  <span class="attr">name</span>: &#123;</span><br><span class="line">    <span class="attr">value</span>: <span class="string">&#x27;Tom&#x27;</span>,</span><br><span class="line">    <span class="attr">writable</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="attr">enumerable</span>: <span class="literal">false</span>,</span><br><span class="line">    <span class="attr">configurable</span>: <span class="literal">true</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">age</span>: &#123;</span><br><span class="line">    <span class="attr">value</span>: <span class="number">20</span>,</span><br><span class="line">    <span class="attr">writable</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="attr">enumerable</span>: <span class="literal">false</span>,</span><br><span class="line">    <span class="attr">configurable</span>: <span class="literal">true</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj)</span><br><span class="line"><span class="comment">// 输出: &#123; name: &quot;Tom&quot;, age: 20 &#125;</span></span><br></pre></td></tr></table></figure>

<ol>
<li>Object.prototype.propertyIsEnumerable() - 判断一个属性是否可枚举</li>
</ol>
<p>该方法用于判断一个对象上的属性是否可以被枚举。返回一个布尔值。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123; <span class="attr">name</span>: <span class="string">&#x27;Tom&#x27;</span>, <span class="attr">age</span>: <span class="number">20</span> &#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj.<span class="title function_">propertyIsEnumerable</span>(<span class="string">&#x27;name&#x27;</span>)) <span class="comment">// 输出: true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj.<span class="title function_">propertyIsEnumerable</span>(<span class="string">&#x27;toString&#x27;</span>)) <span class="comment">// 输出: false</span></span><br></pre></td></tr></table></figure>

<ol>
<li>value等元属性 - 改变属性的描述符</li>
</ol>
<p>描述符包括（value，writable，enumerable，configurable），是属性对象的一组元属性。可以使用Object.defineProperty()或Object.defineProperties()方法更改元属性描述符。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;&#125;</span><br><span class="line"><span class="keyword">const</span> descriptor = &#123;</span><br><span class="line">  <span class="attr">value</span>: <span class="string">&#x27;Tom&#x27;</span>,</span><br><span class="line">  <span class="attr">writable</span>: <span class="literal">false</span>,</span><br><span class="line">  <span class="attr">enumerable</span>: <span class="literal">true</span>,</span><br><span class="line">  <span class="attr">configurable</span>: <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">defineProperty</span>(obj, <span class="string">&#x27;name&#x27;</span>, descriptor)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj.<span class="property">name</span>) <span class="comment">// 输出: Tom</span></span><br><span class="line">descriptor.<span class="property">value</span> = <span class="string">&#x27;Jerry&#x27;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj.<span class="property">name</span>) <span class="comment">// 输出: Tom，由于writable为false，所以值没有被改变</span></span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">freeze</span>(descriptor)</span><br><span class="line">descriptor.<span class="property">value</span> = <span class="string">&#x27;Jerry&#x27;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj.<span class="property">name</span>) <span class="comment">// 输出: Tom，由于value被冻结，所以值没有被改变</span></span><br></pre></td></tr></table></figure>

<ol>
<li>Object.preventExtensions() - 防止向一个对象添加新属性</li>
</ol>
<p>该方法用于防止向一个对象添加新属性。返回修改后的对象。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123; <span class="attr">name</span>: <span class="string">&#x27;Tom&#x27;</span>, <span class="attr">age</span>: <span class="number">20</span> &#125;</span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">preventExtensions</span>(obj)</span><br><span class="line">obj.<span class="property">gender</span> = <span class="string">&#x27;male&#x27;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj.<span class="property">gender</span>) <span class="comment">// 输出: undefined，由于已经预防拓展，gender属性没有被添加</span></span><br></pre></td></tr></table></figure>

<ol>
<li>Object.isExtensible() - 判断一个对象是否可以拓展</li>
</ol>
<p>该方法用于判断一个对象是否可以拓展。返回一个布尔值。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123; <span class="attr">name</span>: <span class="string">&#x27;Tom&#x27;</span>, <span class="attr">age</span>: <span class="number">20</span> &#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Object</span>.<span class="title function_">isExtensible</span>(obj)) <span class="comment">// 输出: true</span></span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">preventExtensions</span>(obj)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Object</span>.<span class="title function_">isExtensible</span>(obj)) <span class="comment">// 输出: false</span></span><br></pre></td></tr></table></figure>

<ol>
<li>Object.seal() - 密封一个对象，防止添加和删除属性</li>
</ol>
<p>该方法用于密封一个对象，即防止向一个对象添加和删除属性。返回修改后的对象。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123; <span class="attr">name</span>: <span class="string">&#x27;Tom&#x27;</span>, <span class="attr">age</span>: <span class="number">20</span> &#125;</span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">seal</span>(obj)</span><br><span class="line">obj.<span class="property">gender</span> = <span class="string">&#x27;male&#x27;</span></span><br><span class="line"><span class="keyword">delete</span> obj.<span class="property">age</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj)</span><br><span class="line"><span class="comment">// 输出: &#123; name: &quot;Tom&quot;, age: 20 &#125;，由于已经被封闭，gender属性没有被添加，age属性没有被删除</span></span><br></pre></td></tr></table></figure>

<ol>
<li>Object.isSealed() - 判断一个对象是否被密封</li>
</ol>
<p>该方法用于判断一个对象是否被密封。返回一个布尔值。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123; <span class="attr">name</span>: <span class="string">&#x27;Tom&#x27;</span>, <span class="attr">age</span>: <span class="number">20</span> &#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Object</span>.<span class="title function_">isSealed</span>(obj)) <span class="comment">// 输出: false</span></span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">seal</span>(obj)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Object</span>.<span class="title function_">isSealed</span>(obj)) <span class="comment">// 输出: true</span></span><br></pre></td></tr></table></figure>

<ol>
<li>Object.freeze() - 冻结一个对象，防止添加、删除和更改属性</li>
</ol>
<p>该方法用于冻结一个对象，即防止向一个对象添加、删除、更改属性。返回修改后的对象。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123; <span class="attr">name</span>: <span class="string">&#x27;Tom&#x27;</span>, <span class="attr">age</span>: <span class="number">20</span> &#125;</span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">freeze</span>(obj)</span><br><span class="line">obj.<span class="property">gender</span> = <span class="string">&#x27;male&#x27;</span></span><br><span class="line"><span class="keyword">delete</span> obj.<span class="property">age</span></span><br><span class="line">obj.<span class="property">name</span> = <span class="string">&#x27;Jerry&#x27;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj)</span><br><span class="line"><span class="comment">// 输出: &#123; name: &quot;Tom&quot;, age: 20 &#125;，由于已经被冻结，gender属性没有被添加，age属性没有被删除，name属性没有被更改</span></span><br></pre></td></tr></table></figure>

<ol>
<li>Object.isFrozen() - 判断一个对象是否被冻结</li>
</ol>
<p>该方法用于判断一个对象是否被冻结。返回一个布尔值。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123; <span class="attr">name</span>: <span class="string">&#x27;Tom&#x27;</span>, <span class="attr">age</span>: <span class="number">20</span> &#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Object</span>.<span class="title function_">isFrozen</span>(obj)) <span class="comment">// 输出: false</span></span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">freeze</span>(obj)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Object</span>.<span class="title function_">isFrozen</span>(obj)) <span class="comment">// 输出: true</span></span><br></pre></td></tr></table></figure>

<p>需要注意的是，Object.freeze()不仅会把属性的writable特性设置为false，还会把configurable特性设置为false，因此不能再通过Object.defineProperty()方法修改或删除现有属性。</p>
<h2 id="3-Array数组对象"><a href="#3-Array数组对象" class="headerlink" title="3.Array数组对象"></a>3.Array数组对象</h2><ol>
<li><p>构造函数 通过构造函数创建对象实例，由于 JS 中函数也是对象，因此也可以</p>
<p>为函数添加属性或方法。</p>
</li>
<li><p>静态方法 直接通过类（构造函数）调用的方法，而非实例方法，</p>
<p>用于对类进行操作或返回特定信息。</p>
</li>
<li><p>Array.isArray() 静态方法，判断传入的参数是否为数组，返回一个布尔值；</p>
<p>通常用于数组类型的检查。</p>
</li>
<li><p>实例方法 通过实例对象调用的方法，</p>
<p>一般用于操作实例的属性或方法。</p>
</li>
<li><p>valueOf()，toString() 均为实例方法，用于将一个对象转换成字符串或原始值；</p>
<p>通常在需要将对象转换为不同类型的数据时使用。</p>
</li>
<li><p>push()，pop() 向数组末尾添加一个或多个元素，或从数组末尾弹出一个元素；</p>
<p>通常用于对数组进行增删操作。</p>
</li>
<li><p>shift()，unshift() 向数组开头添加一个或多个元素，或从数组开头删除一个元素；</p>
<p>通常用于对数组进行增删操作。</p>
</li>
<li><p>join() 将数组转换为字符串，用指定的分隔符分隔各元素；</p>
<p>通常用于将数组内容连接为一串字符串。</p>
</li>
<li><p>concat() 将两个或多个数组合并为一个新数组；</p>
<p>通常用于将多个数组进行合并。</p>
</li>
<li><p>reverse() 将数组中的元素顺序反转；</p>
<p>通常用于对数组进行倒序排列。</p>
</li>
<li><p>slice() 返回一个数组的一部分浅拷贝，不改变原数组；</p>
<p>通常用于对数组进行截取或复制。</p>
</li>
<li><p>splice() 向数组中添加或删除元素，并返回被删除元素的数组；</p>
<p>通常用于对数组进行增删操作。</p>
</li>
<li><p>sort() 对数组进行升序或降序排列；</p>
<p>通常用于对数组进行排序。</p>
</li>
<li><p>map() 将数组中的每个元素通过函数映射为一个新的元素，并返回新数组；</p>
<p>通常用于对元素进行转换或提取。</p>
</li>
<li><p>forEach() 对数组中的每个元素执行指定的操作，不改变原数组；</p>
<p>通常用于对数组进行遍历或执行某个操作。</p>
</li>
<li><p>filter() 筛选数组中符合条件的元素并返回一个新数组；</p>
<p>通常用于对数组进行筛选或过滤。</p>
</li>
<li><p>some()，every() 均对数组中的所有元素进行指定的操作，并返回一个布尔值表示是否符合条件；</p>
<p>通常用于对数组进行条件判断。</p>
</li>
<li><p>reduce()，reduceRight() 通过对数组中的元素执行函数来将其转化为一个值并返回；</p>
<p>通常用于对数组进行聚合、求和、平均等操作。</p>
</li>
<li><p>indexOf()，lastIndexOf() 返回指定元素在数组中第一次出现的位置或最后一次出现的位置，如果未找到则返回 -1；</p>
<p>通常用于查询元素在数组中的位置。</p>
</li>
<li><p>链式使用 将以上方法进行链式调用，可简化代码且易于阅读；</p>
<p>通常用于多个数组操作进行合并，提高代码的可读性。</p>
</li>
<li><p>.length返回数组的长度</p>
</li>
</ol>
<p>在前端和 Node.js 开发中，数组的使用频率非常高。例如在 Vue.js 中，通过数组的相关方法来动态修改组件的值，从而实现数据的响应式更新。这些方法使用方便灵活，但需要注意不同方法的使用场景和不同方法之间的区别，以避免出现错误或代码可读性较差的情况。</p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/JS/" rel="tag">JS</a></li></ul>

    </footer>
  </div>

    
 
    
</article>

    
  </article>
  

  
  <nav class="page-nav">
    
    <a class="extend prev" rel="prev" href="/page/3/">上一页</a><a class="page-number" href="/">1</a><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><span class="page-number current">4</span><a class="page-number" href="/page/5/">5</a><a class="page-number" href="/page/6/">6</a><span class="space">&hellip;</span><a class="page-number" href="/page/8/">8</a><a class="extend next" rel="next" href="/page/5/">下一页</a>
  </nav>
  
</section>
</div>

      <footer class="footer">
  <div class="outer">
    <ul>
      <li>
        Copyrights &copy;
        2023
        <i class="ri-heart-fill heart_icon"></i> LIXiaohan
      </li>
    </ul>
    <ul>
      <li>
        
      </li>
    </ul>
    <ul>
      <li>
        
        
        <span>
  <span><i class="ri-user-3-fill"></i>访问人数:<span id="busuanzi_value_site_uv"></span></span>
  <span class="division">|</span>
  <span><i class="ri-eye-fill"></i>浏览次数:<span id="busuanzi_value_page_pv"></span></span>
</span>
        
      </li>
    </ul>
    <ul>
      
    </ul>
    <ul>
      
      <li>
          <img src="/images/beian.png"></img>
          <a href="http://www.beian.gov.cn/portal/registerSystemInfo?recordcode=01234567890123" target="_black" rel="nofollow">黑公网安备0123456789号</a>
      </li>
        
    </ul>
    <ul>
      <li>
        <!-- cnzz统计 -->
        
        <script type="text/javascript" src=''></script>
        
      </li>
    </ul>
  </div>
</footer>    
    </main>
    <div class="float_btns">
      <div class="totop" id="totop">
  <i class="ri-arrow-up-line"></i>
</div>

<div class="todark" id="todark">
  <i class="ri-moon-line"></i>
</div>

    </div>
    <aside class="sidebar on">
      <button class="navbar-toggle"></button>
<nav class="navbar">
  
  <div class="logo">
    <a href="/"><img src="/images/ayer-side.svg" alt="Pravite Home"></a>
  </div>
  
  <ul class="nav nav-main">
    
    <li class="nav-item">
      <a class="nav-item-link" href="/">主页</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/archives">归档</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/categories">分类</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/tags">标签</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/2019/about">关于我</a>
    </li>
    
  </ul>
</nav>
<nav class="navbar navbar-bottom">
  <ul class="nav">
    <li class="nav-item">
      
      <a class="nav-item-link nav-item-search"  title="搜索">
        <i class="ri-search-line"></i>
      </a>
      
      
      <a class="nav-item-link" target="_blank" href="/atom.xml" title="RSS Feed">
        <i class="ri-rss-line"></i>
      </a>
      
    </li>
  </ul>
</nav>
<div class="search-form-wrap">
  <div class="local-search local-search-plugin">
  <input type="search" id="local-search-input" class="local-search-input" placeholder="Search...">
  <div id="local-search-result" class="local-search-result"></div>
</div>
</div>
    </aside>
    <div id="mask"></div>

<!-- #reward -->
<div id="reward">
  <span class="close"><i class="ri-close-line"></i></span>
  <p class="reward-p"><i class="ri-cup-line"></i>请我喝杯咖啡吧~</p>
  <div class="reward-box">
    
    <div class="reward-item">
      <img class="reward-img" src="/images/alipay.jpg">
      <span class="reward-type">支付宝</span>
    </div>
    
    
    <div class="reward-item">
      <img class="reward-img" src="/images/wechat.jpg">
      <span class="reward-type">微信</span>
    </div>
    
  </div>
</div>
    
<script src="/js/jquery-3.6.0.min.js"></script>
 
<script src="/js/lazyload.min.js"></script>

<!-- Tocbot -->

<script src="https://cdn.staticfile.org/jquery-modal/0.9.2/jquery.modal.min.js"></script>
<link
  rel="stylesheet"
  href="https://cdn.staticfile.org/jquery-modal/0.9.2/jquery.modal.min.css"
/>
<script src="https://cdn.staticfile.org/justifiedGallery/3.8.1/js/jquery.justifiedGallery.min.js"></script>

<script src="/dist/main.js"></script>

<!-- ImageViewer -->
 <!-- Root element of PhotoSwipe. Must have class pswp. -->
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">

    <!-- Background of PhotoSwipe. 
         It's a separate element as animating opacity is faster than rgba(). -->
    <div class="pswp__bg"></div>

    <!-- Slides wrapper with overflow:hidden. -->
    <div class="pswp__scroll-wrap">

        <!-- Container that holds slides. 
            PhotoSwipe keeps only 3 of them in the DOM to save memory.
            Don't modify these 3 pswp__item elements, data is added later on. -->
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>

        <!-- Default (PhotoSwipeUI_Default) interface on top of sliding area. Can be changed. -->
        <div class="pswp__ui pswp__ui--hidden">

            <div class="pswp__top-bar">

                <!--  Controls are self-explanatory. Order can be changed. -->

                <div class="pswp__counter"></div>

                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>

                <button class="pswp__button pswp__button--share" style="display:none" title="Share"></button>

                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>

                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>

                <!-- Preloader demo http://codepen.io/dimsemenov/pen/yyBWoR -->
                <!-- element will get class pswp__preloader--active when preloader is running -->
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                        <div class="pswp__preloader__cut">
                            <div class="pswp__preloader__donut"></div>
                        </div>
                    </div>
                </div>
            </div>

            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div>
            </div>

            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>

            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>

            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>

        </div>

    </div>

</div>

<link rel="stylesheet" href="https://cdn.staticfile.org/photoswipe/4.1.3/photoswipe.min.css">
<link rel="stylesheet" href="https://cdn.staticfile.org/photoswipe/4.1.3/default-skin/default-skin.min.css">
<script src="https://cdn.staticfile.org/photoswipe/4.1.3/photoswipe.min.js"></script>
<script src="https://cdn.staticfile.org/photoswipe/4.1.3/photoswipe-ui-default.min.js"></script>

<script>
    function viewer_init() {
        let pswpElement = document.querySelectorAll('.pswp')[0];
        let $imgArr = document.querySelectorAll(('.article-entry img:not(.reward-img)'))

        $imgArr.forEach(($em, i) => {
            $em.onclick = () => {
                // slider展开状态
                // todo: 这样不好，后面改成状态
                if (document.querySelector('.left-col.show')) return
                let items = []
                $imgArr.forEach(($em2, i2) => {
                    let img = $em2.getAttribute('data-idx', i2)
                    let src = $em2.getAttribute('data-target') || $em2.getAttribute('src')
                    let title = $em2.getAttribute('alt')
                    // 获得原图尺寸
                    const image = new Image()
                    image.src = src
                    items.push({
                        src: src,
                        w: image.width || $em2.width,
                        h: image.height || $em2.height,
                        title: title
                    })
                })
                var gallery = new PhotoSwipe(pswpElement, PhotoSwipeUI_Default, items, {
                    index: parseInt(i)
                });
                gallery.init()
            }
        })
    }
    viewer_init()
</script> 
<!-- MathJax -->
 <script type="text/x-mathjax-config">
  MathJax.Hub.Config({
      tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
          processEscapes: true,
          skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
      }
  });

  MathJax.Hub.Queue(function() {
      var all = MathJax.Hub.getAllJax(), i;
      for(i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
      }
  });
</script>

<script src="https://cdn.staticfile.org/mathjax/2.7.7/MathJax.js"></script>
<script src="https://cdn.staticfile.org/mathjax/2.7.7/config/TeX-AMS-MML_HTMLorMML-full.js"></script>
<script>
  var ayerConfig = {
    mathjax: true,
  };
</script>

<!-- Katex -->

<!-- busuanzi  -->
 
<script src="/js/busuanzi-2.3.pure.min.js"></script>
 
<!-- ClickLove -->

<!-- ClickBoom1 -->

<!-- ClickBoom2 -->
 
<script src="/js/clickBoom2.js"></script>
 
<!-- CodeCopy -->
 
<link rel="stylesheet" href="/css/clipboard.css">
 <script src="https://cdn.staticfile.org/clipboard.js/2.0.10/clipboard.min.js"></script>
<script>
  function wait(callback, seconds) {
    var timelag = null;
    timelag = window.setTimeout(callback, seconds);
  }
  !function (e, t, a) {
    var initCopyCode = function(){
      var copyHtml = '';
      copyHtml += '<button class="btn-copy" data-clipboard-snippet="">';
      copyHtml += '<i class="ri-file-copy-2-line"></i><span>COPY</span>';
      copyHtml += '</button>';
      $(".highlight .code pre").before(copyHtml);
      $(".article pre code").before(copyHtml);
      var clipboard = new ClipboardJS('.btn-copy', {
        target: function(trigger) {
          return trigger.nextElementSibling;
        }
      });
      clipboard.on('success', function(e) {
        let $btn = $(e.trigger);
        $btn.addClass('copied');
        let $icon = $($btn.find('i'));
        $icon.removeClass('ri-file-copy-2-line');
        $icon.addClass('ri-checkbox-circle-line');
        let $span = $($btn.find('span'));
        $span[0].innerText = 'COPIED';
        
        wait(function () { // 等待两秒钟后恢复
          $icon.removeClass('ri-checkbox-circle-line');
          $icon.addClass('ri-file-copy-2-line');
          $span[0].innerText = 'COPY';
        }, 2000);
      });
      clipboard.on('error', function(e) {
        e.clearSelection();
        let $btn = $(e.trigger);
        $btn.addClass('copy-failed');
        let $icon = $($btn.find('i'));
        $icon.removeClass('ri-file-copy-2-line');
        $icon.addClass('ri-time-line');
        let $span = $($btn.find('span'));
        $span[0].innerText = 'COPY FAILED';
        
        wait(function () { // 等待两秒钟后恢复
          $icon.removeClass('ri-time-line');
          $icon.addClass('ri-file-copy-2-line');
          $span[0].innerText = 'COPY';
        }, 2000);
      });
    }
    initCopyCode();
  }(window, document);
</script>
 
<!-- CanvasBackground -->

<script>
  if (window.mermaid) {
    mermaid.initialize({ theme: "forest" });
  }
</script>


    
    <div id="music">
    
    
    
    <iframe frameborder="no" border="1" marginwidth="0" marginheight="0" width="200" height="52"
        src="//music.163.com/outchain/player?type=2&id=22707008&auto=1&height=32"></iframe>
</div>

<style>
    #music {
        position: fixed;
        right: 15px;
        bottom: 0;
        z-index: 998;
    }
</style>
    
    
<script>
  const password = "11";
  const lock_password = window.sessionStorage.getItem("lock_password");
  console.log(password, lock_password);
  if (lock_password !== password) {
    Swal.fire({
      title: "请输入访问密码",
      input: "text",
      inputAttributes: {
        autocapitalize: "off",
      },
      showCancelButton: false,
      showLoaderOnConfirm: true,
      allowOutsideClick: false,
      confirmButtonText: "确定",
    }).then((result) => {
      console.log(result);
      if (result.isConfirmed) {
        console.log(password);
        if (result.value === password) {
          window.sessionStorage.setItem("lock_password", result.value);
        } else {
          Swal.fire({
            icon: "error",
            title: "密码错误，请重试",
            confirmButtonText: "确定",
            allowOutsideClick: false,
          }).then(() => {
            window.location.reload();
          });
        }
      }
    });
  }
</script>


  </div>
</body>

</html>