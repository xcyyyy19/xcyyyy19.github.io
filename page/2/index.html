<!DOCTYPE html>


<html lang="zh-CN">
  

    <head>
      <meta charset="utf-8" />
        
      <meta
        name="viewport"
        content="width=device-width, initial-scale=1, maximum-scale=1"
      />
      <title> Pravite Home</title>
  <meta name="generator" content="hexo-theme-ayer">
      
      <link rel="shortcut icon" href="/favicon.ico" />
       
<link rel="stylesheet" href="/dist/main.css">

      
<link rel="stylesheet" href="/css/fonts/remixicon.css">

      
<link rel="stylesheet" href="/css/custom.css">
 
      <script src="https://cdn.staticfile.org/pace/1.2.4/pace.min.js"></script>
       
 

      <link
        rel="stylesheet"
        href="https://cdn.jsdelivr.net/npm/@sweetalert2/theme-bulma@5.0.1/bulma.min.css"
      />
      <script src="https://cdn.jsdelivr.net/npm/sweetalert2@11.0.19/dist/sweetalert2.min.js"></script>

      <!-- mermaid -->
      
      <style>
        .swal2-styled.swal2-confirm {
          font-size: 1.6rem;
        }
      </style>
    <link rel="alternate" href="/atom.xml" title="Pravite Home" type="application/atom+xml">
</head>
  </html>
</html>


<body>
  <div id="app">
    
      
      <canvas width="1777" height="841"
        style="position: fixed; left: 0px; top: 0px; z-index: 99999; pointer-events: none;"></canvas>
      
    <main class="content on">
      
<section class="cover">
    
  <div class="cover-frame">
    <div class="bg-box">
      <img src="/images/cover1.jpg" alt="image frame" />
    </div>
    <div class="cover-inner text-center text-white">
      <h1><a href="/">Pravite Home</a></h1>
      <div id="subtitle-box">
        
        <span id="subtitle"></span>
        
      </div>
      <div>
        
        <img
          src="/images/ayer.svg"
          class="cover-logo"
          alt="Pravite Home"
        />
        
      </div>
    </div>
  </div>
  <div class="cover-learn-more">
    <a href="javascript:void(0)" class="anchor"><i class="ri-arrow-down-line"></i></a>
  </div>
</section>



<script src="https://cdn.staticfile.org/typed.js/2.0.12/typed.min.js"></script>


<!-- Subtitle -->

  <script>
    try {
      var typed = new Typed("#subtitle", {
        strings: ['群英荟萃，萝卜开会', '圣火昭昭，圣火耀耀，凡我弟子，喵喵喵喵', '不跟唱？您诫过毒吧'],
        startDelay: 30,
        typeSpeed: 100,
        loop: true,
        backSpeed: 50,
        showCursor: true
      });
    } catch (err) {
      console.log(err)
    }
  </script>
  
<div id="main">
  <section class="outer">
  
  
  
<div class="notice" style="margin-top:50px">
    <i class="ri-heart-fill"></i>
    <div class="notice-content">【网页完善中，1.点击标签-&gt;必看-&gt;网页完善ToDoList。 2.或主页拉到最下方了解进度。】</div>
</div>


<style>
    .notice {
        padding: 20px;
        border: 1px dashed #e6e6e6;
        color: #969696;
        position: relative;
        display: inline-block;
        width: 100%;
        background: #fbfbfb50;
        border-radius: 10px;
    }

    .notice i {
        float: left;
        color: #999;
        font-size: 16px;
        padding-right: 10px;
        vertical-align: middle;
        margin-top: -2px;
    }

    .notice-content {
        display: initial;
        vertical-align: middle;
    }
</style>
  
  <article class="articles">
    
    
    
    
    <article
  id="post-前端学习笔记/JS/Q4-JS-6标准库"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2023/04/07/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/JS/Q4-JS-6%E6%A0%87%E5%87%86%E5%BA%93/"
    >JS学习笔记-4.6标准库（base阮一峰/gpt ）</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2023/04/07/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/JS/Q4-JS-6%E6%A0%87%E5%87%86%E5%BA%93/" class="article-date">
  <time datetime="2023-04-07T03:34:47.000Z" itemprop="datePublished">2023-04-07</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/code/">code</a> / <a class="article-category-link" href="/categories/code/note/">note</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h1 id="4-6标准库"><a href="#4-6标准库" class="headerlink" title="4.6标准库"></a>4.6标准库</h1><h2 id="4-6-0基础知识"><a href="#4-6-0基础知识" class="headerlink" title="4.6.0基础知识"></a>4.6.0基础知识</h2><h3 id="1-C-和-JS-中的构造函数和析构函数的异同"><a href="#1-C-和-JS-中的构造函数和析构函数的异同" class="headerlink" title="1.C++ 和 JS 中的构造函数和析构函数的异同"></a>1.C++ 和 JS 中的构造函数和析构函数的异同</h3><p>C++ 和 JS 中的构造函数和析构函数有以下的异同:异同点一:初始化资源申请以及释放。它们都是用来初始化申请资源以及释放资源的。异同点二:以类名一样的方法命名。构造函数都是以类名命名的,析构函数都是以类名加上 ~ 符号命名的。</p>
<p>不同点一:调用时机不同。</p>
<p>C++: 构造函数在对象定义时或通过 new 关键字动态分配内存时调用;析构函数在对象释放时或 delete 关键字释放内存时调用。<br>JS:构造函数在通过 new 关键字调用时执行;没有析构函数的概念,JS 中由垃圾回收机制实现内存释放。</p>
<p>不同点二:继承的调用关系不同。</p>
<p>C++:在继承关系中,如果子类没有定义构造函数,会自动调用父类的构造函数;如果子类定义了构造函数,需要在子类构造函数中显式调用父类的构造函数;析构函数与构造函数相反,会先调用子类的析构函数,然后调用父类的析构函数。<br>JS:在继承关系中,如果子类没有定义构造函数,不会自动调用父类的构造函数;子类需要显示调用父类的构造函数;没有析构函数的概念。不同点三:重载与重写不同。</p>
<p>C++: 构造函数和析构函数都可以重载;子类可以重写父类的构造函数和析构函数。<br>JS:构造函数不能重载,但可以在子类中重写父类的构造函数;没有重写析构函数的概念。</p>
<p>总体来说,C++ 中的这两个概念更加丰富,而 JS 中针对对象初始化和释放的处理较为简单。</p>
<h3 id="2-什么是浅拷贝"><a href="#2-什么是浅拷贝" class="headerlink" title="2.什么是浅拷贝"></a>2.什么是浅拷贝</h3><p>就是愚蠢的拷贝，如果对象里嵌套了对象，那么就会把内部对象的引用给拷贝下来（引用类型的拷贝不会改变引用地址，也就是说拷贝下来的新引用还是旧的那个引用）。由于只是拷贝引用,所以如果引用所指向的对象发生变化,浅拷贝得到的对象也会发生变化。</p>
<h4 id="最直观的例子："><a href="#最直观的例子：" class="headerlink" title="最直观的例子："></a>最直观的例子：</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">let obj = &#123; a: 1, b: &#123; c: 2 &#125; &#125;;</span><br><span class="line">let copy = Object.assign(&#123;&#125;, obj);  // 浅拷贝</span><br><span class="line">obj.b.c = 3;</span><br><span class="line">obj.a = 4;</span><br><span class="line">console.log(copy.b.c);  // 3  发生变化</span><br><span class="line">console.log(copy.a);    //1   无变化</span><br></pre></td></tr></table></figure>

<h4 id="具体解释："><a href="#具体解释：" class="headerlink" title="具体解释："></a>具体解释：</h4><p>对上面这个例子,我们来分析浅拷贝后 copy 对象的结构:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">js</span><br><span class="line">obj = &#123;</span><br><span class="line">  a: 1,     // 基本类型,值 </span><br><span class="line">  b: &#123;      // 引用类型,地址1</span><br><span class="line">    c: 2 </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">copy = &#123;</span><br><span class="line">  a: 1,     // 基本类型,值 </span><br><span class="line">  b: &#123;      // 引用类型,地址1</span><br><span class="line">    c: 2 </span><br><span class="line">  &#125;  </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<p>然后当我们修改 obj 时:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">js</span><br><span class="line">obj.b.c = 3;  // 修改的是地址1指向的对象</span><br><span class="line">obj.a = 4;     // 修改的是值</span><br></pre></td></tr></table></figure>

<p>此时,obj 和 copy 的结构变为:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">js</span><br><span class="line">obj = &#123;</span><br><span class="line">  a: 4,      // 新的基本类型值 </span><br><span class="line">  b: &#123;       // 地址1</span><br><span class="line">    c: 3    </span><br><span class="line">  &#125;  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">copy = &#123;</span><br><span class="line">  a: 1,       // 原基本类型值</span><br><span class="line">  b: &#123;        // 地址1</span><br><span class="line">    c: 3     </span><br><span class="line">  &#125; </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<p>可以看到:- 当我们修改 obj 的引用类型成员 b 时,由于 copy 中的 b 也指向地址 1,所以 copy 的 b 也发生了变化。- 但是,当我们修改 obj 的基本类型成员 a 时,copy 中的 a 不发生变化,因为它有自己的独立值。所以结果是:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">js</span><br><span class="line">console.log(copy.b.c);  // 3  发生变化</span><br><span class="line">console.log(copy.a);    //1   无变化  </span><br></pre></td></tr></table></figure>

<p>这个过程很好地证明了浅拷贝的特征:- 对引用类型的成员,拷贝的是地址,变化会相互影响<br>- 对基本类型的成员,拷贝的是值,变化互不影响</p>
<h4 id="浅拷贝常见的实现方式有"><a href="#浅拷贝常见的实现方式有" class="headerlink" title="浅拷贝常见的实现方式有:"></a>浅拷贝常见的实现方式有:</h4><ol>
<li><h5 id="Object-assign-obj1-obj2-对象的浅拷贝"><a href="#Object-assign-obj1-obj2-对象的浅拷贝" class="headerlink" title="Object.assign(obj1, obj2)对象的浅拷贝:"></a>Object.assign(obj1, obj2)对象的浅拷贝:</h5></li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">let obj = &#123; a: 1, b: &#123; c: 2 &#125; &#125;;</span><br><span class="line">let copy = Object.assign(&#123;&#125;, obj);  // 浅拷贝</span><br><span class="line">obj.b.c = 3;</span><br><span class="line">console.log(copy.b.c);  // 3  发生变化</span><br></pre></td></tr></table></figure>

<ol start="2">
<li><h5 id="arr-slice-数组的浅拷贝"><a href="#arr-slice-数组的浅拷贝" class="headerlink" title="arr.slice()数组的浅拷贝:"></a>arr.slice()数组的浅拷贝:</h5></li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">let arr = [1, &#123; a: 2 &#125;]; </span><br><span class="line">let copy = arr.slice();   // 浅拷贝</span><br><span class="line">arr[1].a = 3;</span><br><span class="line">console.log(copy[1].a);   // 3  发生变化</span><br></pre></td></tr></table></figure>

<ol start="3">
<li><h5 id="…obj-…arr-展开语法进行浅拷贝"><a href="#…obj-…arr-展开语法进行浅拷贝" class="headerlink" title="{ …obj }  […arr]展开语法进行浅拷贝:"></a>{ …obj }  […arr]展开语法进行浅拷贝:</h5></li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">let obj = &#123; a: 1, b: &#123; c: 2 &#125; &#125;;</span><br><span class="line">let copy = &#123; ...obj &#125;;   // 浅拷贝</span><br><span class="line">obj.b.c = 3;</span><br><span class="line">console.log(copy.b.c);   // 3  发生变化</span><br></pre></td></tr></table></figure>

<p>所以,浅拷贝的主要用途是快速复制对象,但是由于它只复制引用,对于引用类型的成员来说,如果原对象发生变化,拷贝对象也会变化。如果要避免这种情况,可以使用深拷贝,深拷贝会完整复制一个新对象,两者之间不再有任何引用关系,变化互不影响。</p>
<h4 id="常见的深拷贝实现方式有"><a href="#常见的深拷贝实现方式有" class="headerlink" title="常见的深拷贝实现方式有:"></a>常见的深拷贝实现方式有:</h4><p>JSON.parse(JSON.stringify(obj))<br>lodash工具库的 _.cloneDeep() 方法<br>手动实现深度遍历对象并复制（及其简单的递归，就是一层层拨开嵌套对象，直到到达内部找到对象内的键值对，浅拷贝它）</p>
<p>所以,总结来说,浅拷贝和深拷贝的主要区别在于对引用类型的成员的处理方式,理解两者的区别可以更好地选择适合的拷贝方式。</p>
<h4 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h4><p>在工作中,如果要考虑兼容性,或需要灵活指定下标获取部分数组,arr.slice() 会更常用。</p>
<p>如果项目环境支持 ES6,并且需要获取数组的完整拷贝,展开语法 …arr 会更简洁,也是较常见的用法。</p>
<p>两者的底层实现原理都是浅拷贝,对于一维数组来说,效果是相同的。</p>
<p>但也要注意,如果数组包含复杂类型,那么对原数组的修改会影响拷贝得到的数组。</p>
<p>除此之外,也可以选择 lodash 等工具库提供的深拷贝方法,如 _.cloneDeep(),来完全避免两个数组之间的影响,这在某些场景下也比较常用。</p>
<h2 id="4-6-1Object"><a href="#4-6-1Object" class="headerlink" title="4.6.1Object"></a>4.6.1Object</h2><h3 id="1-常用方法"><a href="#1-常用方法" class="headerlink" title="1.常用方法"></a>1.常用方法</h3><p>在工作中,Object 对象属性和方法中常用的主要有:</p>
<ol>
<li><strong>Object.defineProperty() 和 Object.defineProperties()</strong>:用于在对象上定义属性或修改属性,常用于<em><strong>数据响应式</strong></em>。</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">let obj = &#123;&#125;;</span><br><span class="line">Object.defineProperty(obj, &quot;prop&quot;, &#123;</span><br><span class="line">  value: true,</span><br><span class="line">  writable: false,</span><br><span class="line">  enumerable: true </span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>Object.keys() 和 Object.values():用于获得对象的键名数组和键值数组。</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">let obj = &#123; a: 1, b: 2 &#125;;</span><br><span class="line">Object.keys(obj); // [&#x27;a&#x27;, &#x27;b&#x27;]</span><br><span class="line">Object.values(obj); // [1, 2]</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>Object.assign():用于对象合并，B合并到A里（是浅拷贝）。&#x2F;&#x2F;assign：分配、指派（任务）<br>                            不会去重，但是如果键值对的key是一样的，新的会把旧的覆盖，即旧的value消失</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">let target = &#123; a: 1 &#125;;</span><br><span class="line">let source = &#123; b: 2 &#125;;</span><br><span class="line">Object.assign(target, source);</span><br><span class="line">// target is now &#123;a: 1, b: 2&#125;</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>Object.freeze():用于冻结对象,使其不能被修改。</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">let obj = &#123; a: 1 &#125;;</span><br><span class="line">Object.freeze(obj);</span><br><span class="line">obj.a = 2; // 无效</span><br></pre></td></tr></table></figure>

<p>除此之外,对象的元属性(writable、enumerable 等)和存取器(getter、setter)也会使用,但是相对来说较少。控制对象状态的方法(Object.preventExtensions、Object.seal 等)用得比较少,一般只会在需要严格控制对象状态的场景下使用。所以,总的来说,在日常工作中 Object 对象的常用方面主要是属性的操作与管理,包括定义、获取和控制属性。</p>
<blockquote>
<p>注：数据响应式是一种设计模式,其核心思想是:当数据变化时,自动更新视图。在 JavaScript 中,定义响应式数据常用的手段就是 Object.defineProperty()。我们可以在定义对象属性时,指定 getter 和 setter 方法。当属性值发生变化时,getter 和 setter 就会自动调用,这样我们可以在 setter 中更新视图,达到数据响应式的效果。例如:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">let data = &#123;</span><br><span class="line">    name: &quot;John&quot;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Object.defineProperty(data, &quot;name&quot;, &#123;</span><br><span class="line">    get() &#123;</span><br><span class="line">        return this._name;</span><br><span class="line">    &#125;,</span><br><span class="line">    set(newValue) &#123;</span><br><span class="line">        this._name = newValue;</span><br><span class="line">        document.querySelector(&quot;#name&quot;).textContent = newValue;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">data.name = &quot;Jack&quot;; </span><br><span class="line">// 视图自动更新,页面上#name元素的文本变为&quot;Jack&quot;</span><br></pre></td></tr></table></figure>

<p>这里我们定义了 name 属性的 getter 和 setter。当对 name 进行重新赋值时,setter 会自动调用,更新视图中的文本内容。Vue.js 中的响应式就是建立在 Object.defineProperty() 之上的。它通过递归定义对象属性的 getter 和 setter,实现视图的响应更新。所以,我们说 Object.defineProperty() 常用于数据响应式,就是因为它提供了定义属性访问器(getter 和 setter)的能力,可以结合 getter 和 setter 达到响应式更新视图的目的。</p>
</blockquote>
<h3 id="2-Object-prototype（后几个不会用）"><a href="#2-Object-prototype（后几个不会用）" class="headerlink" title="2.Object.prototype（后几个不会用）"></a>2.Object.prototype（后几个不会用）</h3><p>在工作中,Object.prototype 最常用于:</p>
<ol>
<li>扩展内置对象。我们会在 Object.prototype 上添加方法,扩展 String、Array、Date 等内置对象的功能。例如:</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">String.prototype.reverse = function() &#123;</span><br><span class="line">  return this.split(&#x27;&#x27;).reverse().join(&#x27;&#x27;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x27;hello&#x27;.reverse() // olleh</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>实现继承和共享方法。我们会在 Object.prototype 上定义方法,让多个对象类型共享这些方法,实现继承。例如:</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Object.prototype.sayHi = function() &#123;</span><br><span class="line">  console.log(&#x27;Hi!&#x27;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let str = &#x27;Hello&#x27; </span><br><span class="line">let obj = &#123;name: &#x27;Jack&#x27;&#125;</span><br><span class="line"></span><br><span class="line">str.sayHi() // Hi!</span><br><span class="line">obj.sayHi() // Hi!</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>模拟类。在 JS 中我们会使用构造函数和原型来模拟类,Object.prototype 就是在这里发挥作用。例如:</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">function Person(name) &#123;</span><br><span class="line">  this.name = name </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Person.prototype.sayName = function() &#123;</span><br><span class="line">  console.log(this.name); </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let jack = new Person(&#x27;Jack&#x27;);</span><br><span class="line">jack.sayName(); // Jack</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>实现 utility 方法。我们会在 Object.prototype 上实现一些通用的工具方法,供所有对象使用。例如:</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Object.prototype.isArray = function() &#123;</span><br><span class="line">  return Object.prototype.toString.call(this) === &#x27;[object Array]&#x27;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">[].isArray() // true </span><br><span class="line">&#123;&#125;.isArray() // false</span><br></pre></td></tr></table></figure>

<p>所以,总的来说,在工作中 Object.prototype 最常用于扩展内置对象、实现继承和共享方法、模拟类、以及实现通用工具方法。它让 JS 的框架和库设计变得简单高效,也使我们的代码更加优雅。</p>
<h2 id="4-6-1小结"><a href="#4-6-1小结" class="headerlink" title="4.6.1小结"></a>4.6.1小结</h2><p>Object有的函数能继承，有的不能。但不知道怎么主动让它继承，也不知道都哪些能继承。</p>
<h2 id="4-6-2原始类型的对象化"><a href="#4-6-2原始类型的对象化" class="headerlink" title="4.6.2原始类型的对象化"></a>4.6.2原始类型的对象化</h2><h3 id="1-三种包装对象"><a href="#1-三种包装对象" class="headerlink" title="1.三种包装对象"></a>1.三种包装对象</h3><p>Number、String、Boolean</p>
<h3 id="2-包装成对象的原因"><a href="#2-包装成对象的原因" class="headerlink" title="2.包装成对象的原因"></a>2.包装成对象的原因</h3><p>用于继承并使用Object类型中的函数。其中三者公用的是valueOf()<code>和</code>toString()。</p>
<h4 id="2-1valueOf"><a href="#2-1valueOf" class="headerlink" title="2.1valueOf()"></a>2.1valueOf()</h4><p>返回包装对象实例对应的原始类型的值。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">new Number(123).valueOf()  // 123</span><br><span class="line">new String(&#x27;abc&#x27;).valueOf() // &quot;abc&quot;</span><br><span class="line">new Boolean(true).valueOf() // true</span><br></pre></td></tr></table></figure>

<h4 id="2-2toString"><a href="#2-2toString" class="headerlink" title="2.2toString()"></a>2.2toString()</h4><p>返回对应的字符串形式。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">new Number(123).toString() // &quot;123&quot;</span><br><span class="line">new String(&#x27;abc&#x27;).toString() // &quot;abc&quot;</span><br><span class="line">new Boolean(true).toString() // &quot;true&quot;</span><br></pre></td></tr></table></figure>

<h2 id="4-6-2小结"><a href="#4-6-2小结" class="headerlink" title="4.6.2小结"></a>4.6.2小结</h2><p>有些类型直接使用太麻烦，包装成对象可以调用更多的库函数。</p>
<h2 id="4-6-3Boolean"><a href="#4-6-3Boolean" class="headerlink" title="4.6.3Boolean"></a>4.6.3Boolean</h2><h4 id="0-使用与易错点"><a href="#0-使用与易错点" class="headerlink" title="0.使用与易错点"></a>0.使用与易错点</h4><p>0.1使用：直接 let a&#x3D;true；就行。</p>
<p>0.2易错点：小心使用，并不是只有0和false是false，空字符串等也是。</p>
<h4 id="1-Boolean中得到true的例子（都要记住）"><a href="#1-Boolean中得到true的例子（都要记住）" class="headerlink" title="1.Boolean中得到true的例子（都要记住）"></a>1.Boolean中得到true的例子（都要记住）</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Boolean(1) // true				数字</span><br><span class="line">Boolean(&#x27;false&#x27;) // true		字符串</span><br><span class="line">Boolean([]) // true				空数组</span><br><span class="line">Boolean(&#123;&#125;) // true				空对象</span><br><span class="line">Boolean(function () &#123;&#125;) // true	空函数</span><br><span class="line">Boolean(/foo/) // true			正则</span><br></pre></td></tr></table></figure>

<h3 id="2-JS和C中的bool类型的异同"><a href="#2-JS和C中的bool类型的异同" class="headerlink" title="2.JS和C中的bool类型的异同"></a>2.JS和C中的bool类型的异同</h3><p>异同点:</p>
<p>都只有两个值:true 和 false。</p>
<p>都用于表示逻辑上的真假。</p>
<h4 id="2-1不同点一-存储方式不同。"><a href="#2-1不同点一-存储方式不同。" class="headerlink" title="2.1不同点一:存储方式不同。"></a>2.1不同点一:存储方式不同。</h4><p>JS:Boolean 是基本数据类型,占据1个字节。<br>C:没有标准的 bool 类型,一般使用整型来存储,占据1个字节(char)或4个字节(int)。</p>
<h4 id="2-2不同点二-转换规则不同。"><a href="#2-2不同点二-转换规则不同。" class="headerlink" title="2.2不同点二:转换规则不同。"></a>2.2不同点二:转换规则不同。</h4><p>JS:在 Boolean 上下文中,以下值会转换为 false:<br> - false<br> - 0<br> - “”(空字符串)<br> - null<br> - undefined<br> - NaN<br>C:所有非零的值都会转换为 true,0 转换为 false。</p>
<h4 id="2-3不同点三-操作方式不同。"><a href="#2-3不同点三-操作方式不同。" class="headerlink" title="2.3不同点三:操作方式不同。"></a>2.3不同点三:操作方式不同。</h4><p>JS:可以直接对 Boolean 类型的值进行逻辑运算(&amp;&amp;、||、!)<br>C:需要先将值转换为整型,再进行逻辑运算。</p>
<p>例如:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">js</span><br><span class="line">let t = true;</span><br><span class="line">let f = false;</span><br><span class="line"></span><br><span class="line">t &amp;&amp; f;     // false</span><br><span class="line">t || f;     // true </span><br><span class="line">!t;         // false</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">c</span><br><span class="line">int t = 1;  // true</span><br><span class="line">int f = 0;  // false</span><br><span class="line"></span><br><span class="line">t &amp;&amp; f;     // 0 </span><br><span class="line">t || f;     // 1</span><br><span class="line">!t;         // 0</span><br></pre></td></tr></table></figure>

<p>所以,Boolean 作为两种语言的基本数据类型,在概念上是相通的,但是具体的实现与使用上存在一定的差异。总体来说,JS 对 Boolean 的支持更加丰富,使用也更加方便,而 C 由于缺乏标准的 bool 类型, Boolean 的表达相对局限。这也是两种语言的特点的体现:JS 侧重表达,C 侧重底层实现。理解两者在这一点上的差异,有助于更好的使用两种语言。</p>
<h3 id="3-boolean类型与Boolean对象"><a href="#3-boolean类型与Boolean对象" class="headerlink" title="3.boolean类型与Boolean对象"></a>3.boolean类型与Boolean对象</h3><p>在 JS 中,boolean 类型和 Boolean 对象是不同的:</p>
<h4 id="3-1boolean-类型"><a href="#3-1boolean-类型" class="headerlink" title="3.1boolean 类型:"></a>3.1boolean 类型:</h4><p>是 JS 的基本数据类型之一,只有 true 和 false 两个值。<br>- 表示逻辑上的真或假。<br>- 大小写敏感,true 和 True 是不同的。<br>- 可以直接在条件语句中使用,如 if 和 while。例如:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">js</span><br><span class="line">let bool = true;     // boolean 类型</span><br><span class="line"></span><br><span class="line">if (bool) &#123; ... &#125;    // 可以直接用于条件判断</span><br></pre></td></tr></table></figure>

<h4 id="3-2Boolean-对象"><a href="#3-2Boolean-对象" class="headerlink" title="3.2Boolean 对象:"></a>3.2Boolean 对象:</h4><p>是 JS 的内置对象,继承自 Object。<br>- 包装了 boolean 基本类型,有 true 和 false 两个值。<br>- 大小写不敏感,TRUE 和 true 是同一个值。<br>- 不能直接在条件语句中使用,需要调用 valueOf() 方法。<br>- 除了 true 和 false,可以有其他的属性和方法。例如:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">js</span><br><span class="line">let bool = new Boolean(true);   // Boolean 对象</span><br><span class="line"></span><br><span class="line">if (bool.valueOf()) &#123; ... &#125;    // 需要调用 valueOf() 方法</span><br><span class="line"></span><br><span class="line">bool.constructor = 123;        // 可以添加属性</span><br></pre></td></tr></table></figure>

<p>所以,boolean 类型和 Boolean 对象的主要区别在于:- boolean 是基本数据类型,Boolean 是对象。<br>- boolean 只有 true 和 false 两个字面量,Boolean 除了 true 和 false 值外,还可以有其他属性和方法。<br>- boolean 可以直接用于条件判断,Boolean 需要调用 valueOf() 方法。但是,在大多数情况下,我们可以把 Boolean 对象当作 boolean 类型来使用,因为:- Boolean 对象在布尔表达式中会自动调用 valueOf() 方法,返回基本类型值。</p>
<h2 id="4-6-3小结"><a href="#4-6-3小结" class="headerlink" title="4.6.3小结"></a>4.6.3小结</h2><p><strong>基于性能考虑,大多数情况下我们会使用基本类型boolean而不是Boolean对象。</strong>所以,boolean 和 Boolean的关系可以看作,boolean 是基本数据类型,Boolean 是它的对象包装形式。</p>
<h2 id="4-6-4Number"><a href="#4-6-4Number" class="headerlink" title="4.6.4Number"></a>4.6.4Number</h2><p>只有可继承的原型函数prototype.toString（）值得一看</p>
<h2 id="4-6-5-String"><a href="#4-6-5-String" class="headerlink" title="4.6.5.String"></a>4.6.5.String</h2><h4 id="5-1原型属性"><a href="#5-1原型属性" class="headerlink" title="5.1原型属性"></a>5.1原型属性</h4><ol>
<li>字符串实例的length属性返回字符串的长度。</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#x27;abc&#x27;.length // 3</span><br></pre></td></tr></table></figure>

<h4 id="5-2原型函数"><a href="#5-2原型函数" class="headerlink" title="5.2原型函数"></a>5.2原型函数</h4><ol>
<li>charAt():返回指定索引处的字符,索引从 0 开始。</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#x27;hello&#x27;.charAt(0);  // &#x27;h&#x27;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>concat():连接两个或多个字符串,返回连接后的字符串。</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#x27;hello&#x27;.concat(&#x27; &#x27;, &#x27;world&#x27;);  // &#x27;hello world&#x27;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>startsWith():检查字符串是否以指定的子字符串开头,返回 true 或 false。</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#x27;hello&#x27;.startsWith(&#x27;he&#x27;);   // true</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>endsWith():检查字符串是否以指定的子字符串结尾,返回 true 或 false。</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#x27;hello&#x27;.endsWith(&#x27;lo&#x27;);   // true</span><br></pre></td></tr></table></figure>

<ol start="5">
<li>indexOf():返回指定子字符串首次出现的索引,如果不存在则返回 -1。</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#x27;hello&#x27;.indexOf(&#x27;l&#x27;);   // 2</span><br></pre></td></tr></table></figure>

<ol start="6">
<li>lastIndexOf():返回指定子字符串最后一次出现的索引,如果不存在则返回 -1。</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#x27;hello&#x27;.lastIndexOf(&#x27;l&#x27;);   // 3</span><br></pre></td></tr></table></figure>

<ol start="7">
<li>slice():提取字符串的一部分,返回提取后的字符串。</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#x27;hello&#x27;.slice(1, 3);   // &#x27;el&#x27;</span><br></pre></td></tr></table></figure>

<ol start="8">
<li>substring():提取字符串的一部分,返回提取后的字符串。与 slice() 类似。</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#x27;hello&#x27;.substring(1, 3);   // &#x27;el&#x27;</span><br></pre></td></tr></table></figure>

<ol start="9">
<li>split():将字符串按指定分隔符拆分成数组,返回数组。</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">js</span><br><span class="line">&#x27;a-b-c&#x27;.split(&#x27;-&#x27;);   // [&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;]</span><br></pre></td></tr></table></figure>

<ol start="10">
<li>replace():替换字符串中的指定子字符串,返回替换后的字符串。</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#x27;hello&#x27;.replace(&#x27;l&#x27;, &#x27;x&#x27;);   // &#x27;hexxo&#x27;</span><br></pre></td></tr></table></figure>

<h3 id="6-Math"><a href="#6-Math" class="headerlink" title="6.Math"></a>6.Math</h3><h4 id="6-1（只有）静态函数"><a href="#6-1（只有）静态函数" class="headerlink" title="6.1（只有）静态函数"></a>6.1（只有）静态函数</h4><ul>
<li><p><code>Math.abs()</code>：绝对值</p>
</li>
<li><p><code>Math.ceil()</code>：向上取整</p>
</li>
<li><p><code>Math.floor()</code>：向下取整</p>
</li>
<li><p><code>Math.max()</code>：最大值</p>
</li>
<li><p><code>Math.min()</code>：最小值</p>
</li>
<li><p><code>Math.pow()</code>：幂运算</p>
<p>Math.pow方法返回以第一个参数为底数、第二个参数为指数的幂运算值。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 等同于 2 ** 2</span><br><span class="line">Math.pow(2, 2) // 4</span><br><span class="line">// 等同于 2 ** 3</span><br><span class="line">Math.pow(2, 3) // 8</span><br></pre></td></tr></table></figure>

<p>下面是计算圆面积的方法。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var radius = 20;</span><br><span class="line">var area = Math.PI * Math.pow(radius, 2);</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>Math.sqrt()</code>：平方根</p>
<p>Math.sqrt方法返回参数值的平方根。如果参数是一个负值，则返回<code>NaN</code>。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Math.sqrt(4) // 2</span><br><span class="line">Math.sqrt(-4) // NaN</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>Math.log()</code>：自然对数</p>
</li>
<li><p><code>Math.exp()</code>：<code>e</code>的指数</p>
</li>
<li><p><code>Math.round()</code>：四舍五入</p>
</li>
<li><p><code>Math.random()</code>：随机数</p>
<p><code>Math.random()</code>返回0到1之间的一个伪随机数，可能等于0，但是一定小于1。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Math.random() // 0.7151307314634323</span><br></pre></td></tr></table></figure>

<p>任意范围的随机数生成函数如下。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">function getRandomArbitrary(min, max) &#123;</span><br><span class="line">  return Math.random() * (max - min) + min;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">getRandomArbitrary(1.5, 6.5)</span><br><span class="line">// 2.4942810038223864</span><br></pre></td></tr></table></figure>

<p>任意范围的随机整数生成函数如下。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">function getRandomInt(min, max) &#123;</span><br><span class="line">  return Math.floor(Math.random() * (max - min + 1)) + min;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">getRandomInt(1, 6) // 5</span><br></pre></td></tr></table></figure>

<p>返回随机字符的例子如下。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">function random_str(length) &#123;</span><br><span class="line">  var ALPHABET = &#x27;ABCDEFGHIJKLMNOPQRSTUVWXYZ&#x27;;</span><br><span class="line">  ALPHABET += &#x27;abcdefghijklmnopqrstuvwxyz&#x27;;</span><br><span class="line">  ALPHABET += &#x27;0123456789-_&#x27;;</span><br><span class="line">  var str = &#x27;&#x27;;</span><br><span class="line">  for (var i = 0; i &lt; length; ++i) &#123;</span><br><span class="line">    var rand = Math.floor(Math.random() * ALPHABET.length);</span><br><span class="line">    str += ALPHABET.substring(rand, rand + 1);</span><br><span class="line">  &#125;</span><br><span class="line">  return str;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">random_str(6) // &quot;NdQKOr&quot;</span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>random_str</code>函数接受一个整数作为参数，返回变量<code>ALPHABET</code>内的随机字符所组成的指定长度的字符串。</p>
</li>
</ul>
<h3 id="7-Date"><a href="#7-Date" class="headerlink" title="7.Date"></a>7.Date</h3><h4 id="7-1作为普通函数"><a href="#7-1作为普通函数" class="headerlink" title="7.1作为普通函数"></a>7.1作为普通函数</h4><p>无论有没有参数，直接调用<code>Date</code>总是返回当前时间。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Date()</span><br><span class="line">// &quot;Tue Dec 01 2015 09:34:43 GMT+0800 (CST)&quot;</span><br></pre></td></tr></table></figure>

<h4 id="7-2作为构造函数"><a href="#7-2作为构造函数" class="headerlink" title="7.2作为构造函数"></a>7.2作为构造函数</h4><p>作为构造函数时，<code>Date</code>对象可以接受多种格式的参数，返回一个该参数对应的时间实例。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// 参数为日期字符串</span><br><span class="line">new Date(&#x27;January 6, 2013&#x27;);</span><br><span class="line">// Sun Jan 06 2013 00:00:00 GMT+0800 (CST)</span><br><span class="line"></span><br><span class="line">// 参数为多个整数，</span><br><span class="line">// 代表年、月、日、小时、分钟、秒、毫秒</span><br><span class="line">new Date(2013, 0, 1, 0, 0, 0, 0)</span><br><span class="line">// Tue Jan 01 2013 00:00:00 GMT+0800 (CST)</span><br></pre></td></tr></table></figure>

<h4 id="7-3包含的静态函数"><a href="#7-3包含的静态函数" class="headerlink" title="7.3包含的静态函数"></a>7.3包含的静态函数</h4><p>没啥用</p>
<h4 id="7-4实例方法"><a href="#7-4实例方法" class="headerlink" title="7.4实例方法"></a>7.4实例方法</h4><p><strong>（1）一堆用不上的，略</strong></p>
<p><strong>（2）本地时间</strong></p>
<p>以下三种方法，可以将 Date 实例转为表示本地时间的字符串。</p>
<ul>
<li>Date.prototype.toLocaleString()：完整的本地时间。</li>
<li>Date.prototype.toLocaleDateString()：本地日期（不含小时、分和秒）。</li>
<li>Date.prototype.toLocaleTimeString()：本地时间（不含年月日）。</li>
</ul>
<p>下面是用法实例。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">var d = new Date(2013, 0, 1);</span><br><span class="line"></span><br><span class="line">d.toLocaleString()</span><br><span class="line">// 中文版浏览器为&quot;2013年1月1日 上午12:00:00&quot;</span><br><span class="line">// 英文版浏览器为&quot;1/1/2013 12:00:00 AM&quot;</span><br><span class="line"></span><br><span class="line">d.toLocaleDateString()</span><br><span class="line">// 中文版浏览器为&quot;2013年1月1日&quot;</span><br><span class="line">// 英文版浏览器为&quot;1/1/2013&quot;</span><br><span class="line"></span><br><span class="line">d.toLocaleTimeString()</span><br><span class="line">// 中文版浏览器为&quot;上午12:00:00&quot;</span><br><span class="line">// 英文版浏览器为&quot;12:00:00 AM&quot;</span><br></pre></td></tr></table></figure>

<p>这三个方法都有两个可选的参数。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">dateObj.toLocaleString([locales[, options]])</span><br><span class="line">dateObj.toLocaleDateString([locales[, options]])</span><br><span class="line">dateObj.toLocaleTimeString([locales[, options]])</span><br></pre></td></tr></table></figure>

<p>这两个参数中，<code>locales</code>是一个指定所用语言的字符串，<code>options</code>是一个配置对象。下面是<code>locales</code>的例子，分别采用<code>en-US</code>和<code>zh-CN</code>语言设定。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">var d = new Date(2013, 0, 1);</span><br><span class="line"></span><br><span class="line">d.toLocaleString(&#x27;en-US&#x27;) // &quot;1/1/2013, 12:00:00 AM&quot;</span><br><span class="line">d.toLocaleString(&#x27;zh-CN&#x27;) // &quot;2013/1/1 上午12:00:00&quot;</span><br><span class="line"></span><br><span class="line">d.toLocaleDateString(&#x27;en-US&#x27;) // &quot;1/1/2013&quot;</span><br><span class="line">d.toLocaleDateString(&#x27;zh-CN&#x27;) // &quot;2013/1/1&quot;</span><br><span class="line"></span><br><span class="line">d.toLocaleTimeString(&#x27;en-US&#x27;) // &quot;12:00:00 AM&quot;</span><br><span class="line">d.toLocaleTimeString(&#x27;zh-CN&#x27;) // &quot;上午12:00:00&quot;</span><br></pre></td></tr></table></figure>

<h3 id="8-RegExp正则"><a href="#8-RegExp正则" class="headerlink" title="8.RegExp正则"></a>8.RegExp正则</h3><h4 id="5-1"><a href="#5-1" class="headerlink" title="5.1"></a>5.1</h4><h4 id="5-2"><a href="#5-2" class="headerlink" title="5.2"></a>5.2</h4><h3 id="9-JOSN"><a href="#9-JOSN" class="headerlink" title="9.JOSN"></a>9.JOSN</h3><h4 id="5-1-1"><a href="#5-1-1" class="headerlink" title="5.1"></a>5.1</h4><h4 id="5-2-1"><a href="#5-2-1" class="headerlink" title="5.2"></a>5.2</h4> 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/JS/" rel="tag">JS</a></li></ul>

    </footer>
  </div>

    
 
    
</article>

    
    <article
  id="post-Python/爬虫/P6-Py-0两种异步观念"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2023/04/07/Python/%E7%88%AC%E8%99%AB/P6-Py-0%E4%B8%A4%E7%A7%8D%E5%BC%82%E6%AD%A5%E8%A7%82%E5%BF%B5/"
    >爬虫学习笔记-6.0两种异步观念（base大学数据结构+OS老师）</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2023/04/07/Python/%E7%88%AC%E8%99%AB/P6-Py-0%E4%B8%A4%E7%A7%8D%E5%BC%82%E6%AD%A5%E8%A7%82%E5%BF%B5/" class="article-date">
  <time datetime="2023-04-07T03:34:47.000Z" itemprop="datePublished">2023-04-07</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/code/">code</a> / <a class="article-category-link" href="/categories/code/note/">note</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h1 id="有疑问-同步-关注通信机制-跟同步-描述进程中之间的关系-的区别-并发并行与异步的联系"><a href="#有疑问-同步-关注通信机制-跟同步-描述进程中之间的关系-的区别-并发并行与异步的联系" class="headerlink" title="[有疑问]同步(关注通信机制)跟同步(描述进程中之间的关系)的区别  并发并行与异步的联系"></a>[有疑问]同步(关注通信机制)跟同步(描述进程中之间的关系)的区别  并发并行与异步的联系</h1><h2 id="两种关于异步的理解"><a href="#两种关于异步的理解" class="headerlink" title="两种关于异步的理解"></a><strong>两种关于异步的理解</strong></h2><p>1.线程&#x2F;进程&#x2F;作业 不按代码顺序执行(其他)</p>
<p>2.不按发送请求的顺序返回结果(消息通信机制)</p>
<p><strong>消息通信机制中的同步异步(顺带并发并行)</strong></p>
<p>同步和异步关注的是<strong>消息通信机制</strong> (synchronous communication&#x2F; asynchronous communication)。所谓同步，就是在发出一个<em>调用</em>时，在没有得到结果之前，该<em>调用</em>就不返回。但是一旦调用返回，就得到返回值了。换句话说，就是由<em>调用者</em>主动等待这个<em>调用</em>的结果。</p>
<p>而异步则是相反，<em>调用</em>在发出之后，这个调用就直接返回了，所以没有返回结果。换句话说，当一个异步过程调用发出后，调用者不会立刻得到结果。而是在<em>调用</em>发出后，<em>被调用者</em>通过状态、通知来通知调用者，或通过回调函数处理这个调用。</p>
<p>并发和并行其实是异步(线程&#x2F;进程&#x2F;作业 不按代码顺序执行,不按发送请求的顺序返回结果)线程实现的两种形式。(这里的异步指的是什么异步???)</p>
<p>并行其实是真正的异步，多核CUP可以同时开启多条线程供多个任务同时执行，互不干扰。但</p>
<p>是并发就不一样了，是一个伪异步。在单核CUP中只能有一条线程，但是又想执行多个任务。这个时候，只能在一条线程上不停的切换任务，但是当并发是在多个cpu的情况下，那么并行和并发就没多大的区别了。但是在单个cpu的情况下的话，那么就只能并发而不能并行了。</p>
<p><strong>操作系统中的异步机制和进程同步机制</strong></p>
<ul>
<li>1.异步机制:由于操作系统都是并发的(一段时间内cpu到处跳),即拥有了异步性,导致了有些情况</li>
</ul>
<p><strong>(———–<strong>比如AB两进程并发操作数据10,想得到的结果是A进程先执行除法,B再进行加法….,再比如两人同时存钱,<strong>同时访问数据库,导致操作出问题</strong>(好像是有三四种可能,此处关于数据库安全性)</strong>————)</strong></p>
<p>无法按照顺序得到想要的结果,故提出进程同步机制,其中一个即信号量机制,信号量机制又可以实现同步和互斥,其中的同步和同步机制是两个概念.</p>
<ul>
<li>2.同步机制:使进程按某种顺序执行的各种机制(方法).<strong>并不是一定A执行完了B才能执行(同步)这种严格的顺序.还有AB谁先执行都行,但是同一时间只能有一个进程执行.</strong></li>
</ul>
<p><strong>操作系统中的同步机制中的同步和互斥</strong></p>
<p>显然，同步是一种更为复杂的互斥，而互斥是一种特殊的同步。</p>
<p>也就是说互斥是两个线程之间不可以同时运行，他们会相互排斥，必须等待一个线程运行完毕，另一个才能运行，而同步也是不能同时运行，但他是必须要安照某种次序来运行相应的线程（也是一种互斥）！</p>
<p><strong>互斥</strong>：是指某一资源同时只允许一个访问者对其进行访问，具有唯一性和排它性。但互斥无法限制访问者对资源的访问顺序，即访问是无序的。<strong>进程之间的执行没有先后顺序,但资源共享,同一时间只能有一个进程访问这个资源.</strong></p>
<p><strong>同步</strong>：是指在互斥的基础上（大多数情况），通过其它机制实现访问者对资源的有序访问。在大多数情况下，同步已经实现了互斥，特别是所有写入资源的情况必定是互斥的。少数情况是指可以允许多个访问者同时访问资源。<strong>进程之间的执行必须有先后顺序,资源共享,同一时间只能有一个进程访问这个资源.</strong></p>
<h1 id="同步异步并串行并行并发的区别"><a href="#同步异步并串行并行并发的区别" class="headerlink" title="同步异步并串行并行并发的区别"></a><strong>同步异步并串行并行并发的区别</strong></h1><p>   <strong>同步、异步：</strong></p>
<p>指的是能否开启新的线程。同步不能开启新的线程，异步可以。</p>
<p>   <strong>串行、并行：</strong></p>
<p>指的是任务的执行方式。串行是指多个任务时，各个任务按顺序执行，完成一个之后才能进行下一个。并行指的是多个任务可以同时执行。异步是多个任务并行的前提条件。</p>
<p>   <strong>并发和并行其实是异步线程实现的两种形式。并行其实是真正的异步，多核CUP可以同时开启多条线程供多个任务同时执行，互不干扰。但是并发就不一样了，是一个伪异步。在单核CUP中只能有一条线程，但是又想执行多个任务。这个时候，只能在一条线程上不停的切换任务，比如任务A执行了20%，任务A停下里，线程让给任务B，任务执行了30%停下，再让任务A执行。这样我们用的时候，由于CUP处理速度快，你看起来好像是同时执行，其实不是的，同一时间只会执行单个任务。但是当并发是在多个cpu的情况下，那么并行和并发就没多大的区别了。但是在单个cpu的情况下的话，那么就只能并发而不能并行了。</strong></p>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/czk666/articles/9353160.html">查看原文</a></p>
<h1 id="同步异步-阻塞非阻塞-和nginx的IO模型"><a href="#同步异步-阻塞非阻塞-和nginx的IO模型" class="headerlink" title="同步异步,阻塞非阻塞 和nginx的IO模型"></a>同步异步,阻塞非阻塞 和nginx的IO模型</h1><p><a target="_blank" rel="noopener" href="http://www.cnblogs.com/wxl-dede/p/5134636.html"><strong>同步异步,阻塞非阻塞 和nginx的IO模型</strong></a><strong>（这人的笔记都很有用!!!）</strong></p>
<p><a target="_blank" rel="noopener" href="https://www.zhihu.com/question/19732473/answer/20851256">https://www.zhihu.com/question/19732473/answer/20851256</a></p>
<p><a target="_blank" rel="noopener" href="https://www.zhihu.com/question/19732473/answer/14413599">https://www.zhihu.com/question/19732473/answer/14413599</a></p>
<p><a target="_blank" rel="noopener" href="https://www.zhihu.com/question/19732473/answer/241673170">https://www.zhihu.com/question/19732473/answer/241673170</a></p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Python%EF%BC%8CScrapy/" rel="tag">Python，Scrapy</a></li></ul>

    </footer>
  </div>

    
 
    
</article>

    
    <article
  id="post-Python/爬虫/P6-Py-100Scrapy性能提高"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2023/04/07/Python/%E7%88%AC%E8%99%AB/P6-Py-100Scrapy%E6%80%A7%E8%83%BD%E6%8F%90%E9%AB%98/"
    >爬虫学习笔记-6.100Scrapy性能提升（base百度）</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2023/04/07/Python/%E7%88%AC%E8%99%AB/P6-Py-100Scrapy%E6%80%A7%E8%83%BD%E6%8F%90%E9%AB%98/" class="article-date">
  <time datetime="2023-04-07T03:34:47.000Z" itemprop="datePublished">2023-04-07</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/code/">code</a> / <a class="article-category-link" href="/categories/code/note/">note</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <p>需求：scrapy爬取网页速度十分缓慢，在目标网站良好的情况下三天才跑了80w条数据，参考其他爬虫的速度，一天抓取1000w条数据是没有问题的，scrapy性能需要优化。</p>
<p>思路：经过各种搜索，scrapy提高性能核心逻辑是提高并发数量，最简单的实现方式可以通过调整settings的‘CONCURRENT_REQUESTS’等参数或者使用分布式爬虫来提速。除此之外代码也要尽量少用循环。本人的简单优化主要通过以下方式</p>
<p><strong>settings中设置CONCURRENT_REQUESTS</strong></p>
<p>scrapy默认CONCURRENT_REQUESTS 为16,可以将CONCURRENT_REQUESTS 的数量增加。要注意download_delay会影响到并发的效果，大概是由于每个request的处理要在download_delay时间之后。具体见链接<a target="_blank" rel="noopener" href="https://link.jianshu.com/?t=http://blog.csdn.net/s150503/article/details/72571680">scrapy中CONCURRENT_REQUESTS与DOWNLOAD_DELAY的联系</a></p>
<p>DEPTH_PRIORITY &#x3D; 1 SCHEDULER_DISK_QUEUE &#x3D; ‘scrapy.squeues.PickleFifoDiskQueue’ SCHEDULER_MEMORY_QUEUE &#x3D; ‘scrapy.squeues.FifoMemoryQueue’</p>
<p><strong>spider中的循环优化</strong></p>
<p>尽量减少循环的层数，另外参考python优化的原则，在循环中少用”.”的方法。</p>
<p>lowerlist &#x3D; [‘this’, ‘is’, ‘lowercase’] upper &#x3D; str.upper upperlist &#x3D; [] append &#x3D; upperlist.append for word in lowerlist:    append(upper(word))    print(upperlist)</p>
<p><strong>中间价的优化</strong></p>
<p>当时写了一个简单的中间件用来记录请求失败的url，将中间件删掉后速度有所提升。</p>
<p><strong>异步导出数据</strong></p>
<p>具体没尝试过故此只放链接在次</p>
<p>[异步导出数据]<a target="_blank" rel="noopener" href="https://link.jianshu.com/?t=http://www.cnblogs.com/ruoniao/p/6906344.html">http://www.cnblogs.com/ruoniao/p/6906344.html</a></p>
<p>参考文章</p>
<p><a target="_blank" rel="noopener" href="https://link.jianshu.com/?t=http://python.jobbole.com/81035/">提升 Python 程序性能的 6 个技巧</a></p>
<p><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/df9c0d1e9087">Scrapy爬虫入门教程十三 Settings（设置）</a></p>
<p><a target="_blank" rel="noopener" href="https://link.jianshu.com/?t=http://blog.csdn.net/zongzhiyuan/article/details/53364749">【Scrapy爬虫系列2】性能调优</a></p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Python%EF%BC%8CScrapy/" rel="tag">Python，Scrapy</a></li></ul>

    </footer>
  </div>

    
 
    
</article>

    
    <article
  id="post-Python/爬虫/P6-Py-1异步问答"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2023/04/07/Python/%E7%88%AC%E8%99%AB/P6-Py-1%E5%BC%82%E6%AD%A5%E9%97%AE%E7%AD%94/"
    >爬虫学习笔记-6.1异步相关问答（base大学JS+OS老师）</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2023/04/07/Python/%E7%88%AC%E8%99%AB/P6-Py-1%E5%BC%82%E6%AD%A5%E9%97%AE%E7%AD%94/" class="article-date">
  <time datetime="2023-04-07T03:34:47.000Z" itemprop="datePublished">2023-04-07</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/code/">code</a> / <a class="article-category-link" href="/categories/code/note/">note</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h1 id="异步概念，异步执行，异步机制，异步传输数据"><a href="#异步概念，异步执行，异步机制，异步传输数据" class="headerlink" title="异步概念，异步执行，异步机制，异步传输数据"></a>异步概念，异步执行，异步机制，异步传输数据</h1><p>在我印象里异步传输数据就是A发送一字节数据，B不知道啥时候接收到，也不知道B啥时候返回。B返回时会通知A回来处理。</p>
<p>异步机制是通过回调函数。。。。。。</p>
<p>异步概念跟异步传输差不多</p>
<p>异步执行是异步概念基础上加了函数执行，目前只知道js里的函数能异步执行。</p>
<p>然后异步函数为了保证执行顺序 我们可以使用promise或者async&#x2F;await对异步函数进行包装</p>
<h2 id="1-既然是异步，为什么还要保证执行顺序？"><a href="#1-既然是异步，为什么还要保证执行顺序？" class="headerlink" title="1.既然是异步，为什么还要保证执行顺序？"></a>1.既然是异步，为什么还要保证执行顺序？</h2><p><strong>答：</strong>异步有时候需要做执行顺序的调整啊</p>
<p>比如</p>
<p>A:一个异步请求</p>
<p>B:一个输出</p>
<blockquote>
<p>你输出的时候，异步请求的结果还没出来(因为执行顺序不是同步的，异步就变成先执行B再执行A)</p>
</blockquote>
<h3 id="1-1设计操作系统的时候就应该解决这种问题了啊，同步和互斥，加锁。"><a href="#1-1设计操作系统的时候就应该解决这种问题了啊，同步和互斥，加锁。" class="headerlink" title="1.1设计操作系统的时候就应该解决这种问题了啊，同步和互斥，加锁。"></a>1.1设计操作系统的时候就应该解决这种问题了啊，同步和互斥，加锁。</h3><p>想通了：操作系统解决的是最基础的，函数顺序可能有问题关他毛事。函数是自己写的，os又不可能未卜先知。</p>
<img src="./P6-Py-1%E5%BC%82%E6%AD%A5%E9%97%AE%E7%AD%94.assets/image-20230421173728251.png" alt="image-20230421173728251" style="zoom:50%;" />

<h3 id="1-2宏观任务为什么就异步了？宏观任务是什么？"><a href="#1-2宏观任务为什么就异步了？宏观任务是什么？" class="headerlink" title="1.2宏观任务为什么就异步了？宏观任务是什么？"></a>1.2宏观任务为什么就异步了？宏观任务是什么？</h3><p>我的理解:因为宏观任务，微观任务这些都需要时间，比如花时间去请求，或者花时间调用计时器。 js的设计可能是为了避免这些用时的异步函数阻塞了执行。所以才会设计成先执行同步代码，再执行异步的。</p>
<p>宏观任务应该说是事件的来源</p>
<p>js里面的计时器是自带的，所以是宏观任务。 然后promise或者请求一般是宿主发出的，是微观请求。</p>
<h3 id="1-2异步函数是指os控制下使普通函数变得异步是么，还是说函数受程序员控制，你调什么东西让它异步？（应该是后面那个，比如用框架，但是框架是怎么让函数变成异步执行的？）"><a href="#1-2异步函数是指os控制下使普通函数变得异步是么，还是说函数受程序员控制，你调什么东西让它异步？（应该是后面那个，比如用框架，但是框架是怎么让函数变成异步执行的？）" class="headerlink" title="1.2异步函数是指os控制下使普通函数变得异步是么，还是说函数受程序员控制，你调什么东西让它异步？（应该是后面那个，比如用框架，但是框架是怎么让函数变成异步执行的？）"></a>1.2异步函数是指os控制下使普通函数变得异步是么，还是说函数受程序员控制，你调什么东西让它异步？（应该是后面那个，比如用框架，但是框架是怎么让函数变成异步执行的？）</h3><h3 id="1-3异步函数的实际执行顺序受制于避免阻塞还有？？"><a href="#1-3异步函数的实际执行顺序受制于避免阻塞还有？？" class="headerlink" title="1.3异步函数的实际执行顺序受制于避免阻塞还有？？"></a>1.3异步函数的实际执行顺序受制于避免阻塞还有？？</h3><p>想通了：异步函数的实际执行顺序好像跟进程的执行顺序一个道理。（想啥呢进程不就是函数+pcb）</p>
<blockquote>
<p>这块我明天得捋一捋了，我具体也忘了浏览器四个进程现在是怎么划分的，还有进程的一些特点之类</p>
</blockquote>
<blockquote>
<p>异步的问题，你看看掘金上对于event loop的解释，你就会明白js的执行顺序。</p>
<p>同步代码会直接按顺序执行。异步(分成宏任务和微任务，具体的区别你可以查一查。常见的宏任务主要是setTimeout,SetInterval这类计时器，以及I&#x2F;O操作,ui渲染的操作，微任务主要是Promise之类)。</p>
<p>具体的执行顺序看event loop的文章，我解释起来可能有点费劲。我把思路理一理再做解释</p>
</blockquote>
<ol start="4">
<li></li>
</ol>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Python%EF%BC%8CScrapy/" rel="tag">Python，Scrapy</a></li></ul>

    </footer>
  </div>

    
 
    
</article>

    
    <article
  id="post-Python/爬虫/P6-Py-3Ajax工作原理及实例"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2023/04/07/Python/%E7%88%AC%E8%99%AB/P6-Py-3Ajax%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%E5%8F%8A%E5%AE%9E%E4%BE%8B/"
    >爬虫学习笔记-6.3Ajax工作原理及实例（base百度）</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2023/04/07/Python/%E7%88%AC%E8%99%AB/P6-Py-3Ajax%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%E5%8F%8A%E5%AE%9E%E4%BE%8B/" class="article-date">
  <time datetime="2023-04-07T03:34:47.000Z" itemprop="datePublished">2023-04-07</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/code/">code</a> / <a class="article-category-link" href="/categories/code/note/">note</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <p><strong>1、关于ajax的名字</strong>　　</p>
<p>　　ajax 的全称是Asynchronous JavaScript and XML，其中，Asynchronous 是异步的意思，它有别于传统web开发中采用的同步的方式。</p>
<p><strong>2、关于同步和异步</strong>　</p>
<p>　　异步传输是面向字符的传输，它的单位是字符；而同步传输是面向比特的传输，它的单位是桢，它传输的时候要求接受方和发送方的时钟是保持一致的。</p>
<p>具体来说，异步传输是将比特分成小组来进行传送。一般每个小组是一个8位字符，在每个小组的头部和尾部都有一个开始位和一个停止位，它在传送过程中接收方和发送方的时钟不要求一致，也就是说，发送方可以在任何时刻发送这些小组，而接收方并不知道它什么时候到达。一个最明显的例子就是计算机键盘和主机的通信，按下一个键的同时向主机发送一个8比特位的ASCII代 码，键盘可以在任何时刻发送代码，这取决于用户的输入速度，内部的硬件必须能够在任何时刻接收一个键入的字符。这是一个典型的异步传输过程。异步传输存在 一个潜在的问题，即接收方并不知道数据会在什么时候到达。在它检测到数据并做出响应之前，第一个比特已经过去了。这就像有人出乎意料地从后面走上来跟你说 话，而你没来得及反应过来，漏掉了最前面的几个词。因此，每次异步传输的信息都以一个起始位开头，它通知接收方数据已经到达了，这就给了接收方响应、接收 和缓存数据比特的时间；在传输结束时，一个停止位表示该次传输信息的终止。按照惯例，空闲（没有传送数据）的线路实际携带着一个代表二进制1的信号。步传输的开始位使信号变成0，其他的比特位使信号随传输的数据信息而变化。最后，停止位使信号重新变回1，该信号一直保持到下一个开始位到达。例如在键盘上数字“1”，按照8比特位的扩展ASCII编码，将发送“00110001”，同时需要在8比特位的前面加一个起始位，后面一个停止位。</p>
<p>同步传输的比特分组要大得多。它不是独立地发送每个字符，每个字符都有自己的开始位和停止位，而是把它们组合起来一起发送。我们将这些组合称为数据帧，或简称为帧。</p>
<p>　　数据帧的第一部分包含一组同步字符，它是一个独特的比特组合，类似于前面提到的起始位，用于通知接收方一个帧已经到达，但它同时还能确保接收方的采样速度和比特的到达速度保持一致，使收发双方进入同步。</p>
<p>　　帧的最后一部分是一个帧结束标记。与同步字符一样，它也是一个独特的比特串，类似于前面提到的停止位，用于表示在下一帧开始之前没有别的即将到达的数据了。</p>
<p>　　同步传输通常要比异步传输快速得多。接收方不必对每个字符进行开始和停止的操作。一旦检测到帧同步字符，它就在接下来的数据到达时接收它们。另外，同步传输的开销也比较少。例如，一个典型的帧可能有500字节（即4000比特）的数据，其中可能只包含100比特的开销。这时，增加的比特位使传输的比特总数增加2.5%，这与异步传输中25 %的增值要小得多。随着数据帧中实际数据比特位的增加，开销比特所占的百分比将相应地减少。但是，数据比特位越长，缓存数据所需要的缓冲区也越大，这就限制了一个帧的大小。另外，帧越大，它占据传输媒体的连续时间也越长。在极端的情况下，这将导致其他用户等得太久。</p>
<p>　3、<strong>ajax所包含的技术</strong></p>
<p>　　<strong>ajax并非一种新的技术，而是几种原有技术的结合体。它由下列技术组合而成。</strong></p>
<p>　1.使用CSS和XHTML来表示。</p>
<ol start="2">
<li>使用DOM模型来交互和动态显示。</li>
</ol>
<p>  3.使用XMLHttpRequest来和服务器进行异步通信。</p>
<p>  4.使用javascript来绑定和调用。</p>
<p>在上面几中技术中，除了XmlHttpRequest对象以外，其它所有的技术都是基于web标准并且已经得到了广泛使用的，XMLHttpRequest虽然目前还没有被W3C所采纳，但是它已经是一个事实的标准，因为目前几乎所有的主流浏览器都支持它。</p>
<p>  <strong>4、ajax原理和XmlHttpRequest对象</strong></p>
<p>　　<strong>Ajax的原理简单来说通过XmlHttpRequest对象来向服务器发异步请求，从服务器获得数据，然后用javascript来操作DOM而更新页面。这其中最关键的一步就是从服务器获得请求数据。要清楚这个过程和原理，我们必须对 XMLHttpRequest有所了解。</strong></p>
<p>XMLHttpRequest是ajax的核心机制，它是在IE5中首先引入的，是一种支持异步请求的技术。简单的说，也就是javascript可以及时向服务器提出请求和处理响应，而不阻塞用户。达到无刷新的效果。</p>
<p> 　所以我们先从XMLHttpRequest讲起，来看看它的工作原理。</p>
<p> 　首先，我们先来看看XMLHttpRequest这个对象的属性。</p>
<p> 　　它的属性有：</p>
<p> 　　onreadystatechange 每次状态改变所触发事件的事件处理程序。</p>
<p> 　　responseText   从服务器进程返回数据的字符串形式。</p>
<p> 　　responseXML   从服务器进程返回的DOM兼容的文档数据对象。</p>
<p> 　　status      从服务器返回的数字代码，比如常见的404（未找到）和200（已就绪）</p>
<p> 　　status Text    伴随状态码的字符串信息</p>
<p> 　　readyState    对象状态值</p>
<p>　　　　0 (未初始化) 对象已建立，但是尚未初始化（尚未调用open方法）</p>
<p>　　　　1 (初始化) 对象已建立，尚未调用send方法</p>
<p>　　　　2 (发送数据) send方法已调用，但是当前的状态及http头未知</p>
<p>　　　　3 (数据传送中) 已接收部分数据，因为响应及http头不全，这时通过responseBody和responseText获取部分数据会出现错误，</p>
<p>　　　　4 (完成) 数据接收完毕,此时可以通过通过responseXml和responseText获取完整的回应数据</p>
<p>　　但是，由于各浏览器之间存在差异，所以创建一个XMLHttpRequest对象可能需要不同的方法。这个差异主要体现在IE和其它浏览器之间。下面是一个比较标准的创建XMLHttpRequest对象的方法。</p>
<p>function CreateXmlHttp() {</p>
<p>​    &#x2F;&#x2F;非IE浏览器创建XmlHttpRequest对象</p>
<p>​    if (window.XmlHttpRequest) {</p>
<p>​        xmlhttp &#x3D; new XmlHttpRequest();</p>
<p>​    }</p>
<p>​    &#x2F;&#x2F;IE浏览器创建XmlHttpRequest对象</p>
<p>​    if (window.ActiveXObject) {</p>
<p>​        try {</p>
<p>​            xmlhttp &#x3D; new ActiveXObject(“Microsoft.XMLHTTP”);</p>
<p>​        }</p>
<p>​        catch (e) {</p>
<p>​            try {</p>
<p>​                xmlhttp &#x3D; new ActiveXObject(“msxml2.XMLHTTP”);</p>
<p>​            }</p>
<p>​            catch (ex) { }</p>
<p>​        }</p>
<p>​    }</p>
<p>}</p>
<p>function Ustbwuyi() {</p>
<p>​    var data &#x3D; document.getElementById(“username”).value;</p>
<p>​    CreateXmlHttp();</p>
<p>​    if (!xmlhttp) {</p>
<p>​        alert(“创建xmlhttp对象异常！”);</p>
<p>​        return false;</p>
<p>​    }</p>
<p>​    xmlhttp.open(“POST”, url, false);</p>
<p>​    xmlhttp.onreadystatechange &#x3D; function () {</p>
<p>​        if (xmlhttp.readyState &#x3D;&#x3D; 4) {</p>
<p>​            document.getElementById(“user1”).innerHTML &#x3D; “数据正在加载…”;</p>
<p>​            if (xmlhttp.status &#x3D;&#x3D; 200) {</p>
<p>​                document.write(xmlhttp.responseText);</p>
<p>​            }</p>
<p>​        }</p>
<p>​    }</p>
<p>​    xmlhttp.send();</p>
<p>}</p>
<p>　　如上所示，函数首先检查XMLHttpRequest的整体状态并且保证它已经完成（readyStatus&#x3D;4），即数据已经发送完毕。然后根据服务器的设定询问请求状态，如果一切已经就绪（status&#x3D;200），那么就执行下面需要的操作。</p>
<p>对于XmlHttpRequest的两个方法，open和send，其中open方法指定了：</p>
<p>a、向服务器提交数据的类型，即post还是get。</p>
<p>b、请求的url地址和传递的参数。</p>
<p>c、传输方式，false为同步，true为异步。默认为true。如果是异步通信方式(true)，客户机就不等待服务器的响应；如果是同步方式(false)，客户机就要等到服务器返回消息后才去执行其他操作。我们需要根据实际需要来指定同步方式，在某些页面中，可能会发出多个请求，甚至是有组织有计划有队形大规模的高强度的request，而后一个是会覆盖前一个的，这个时候当然要指定同步方式。</p>
<p>Send方法用来发送请求。</p>
<p>　　知道了XMLHttpRequest的工作流程，我们可以看出，XMLHttpRequest是完全用来向服务器发出一个请求的，它的作用也局限于此，但它的作用是整个ajax实现的关键，因为ajax无非是两个过程，发出请求和响应请求。并且它完全是一种客户端的技术。而XMLHttpRequest正是处理了服务器端和客户端通信的问题所以才会如此的重要。</p>
<p>　　现在，我们对ajax的原理大概可以有一个了解了。我们可以把服务器端看成一个数据接口，它返回的是一个纯文本流，当然，这个文本流可以是XML格式，可以是Html，可以是Javascript代码，也可以只是一个字符串。这时候，XMLHttpRequest向服务器端请求这个页面，服务器端将文本的结果写入页面，这和普通的web开发流程是一样的，不同的是，客户端在异步获取这个结果后，不是直接显示在页面，而是先由javascript来处理，然后再显示在页面。至于现在流行的很多ajax控件，比如magicajax等，可以返回DataSet等其它数据类型，只是将这个过程封装了的结果，本质上他们并没有什么太大的区别。</p>
<p>　　<strong>5、ajax的缺点</strong></p>
<p>下面我着重讲一讲ajax的缺陷，因为平时我们大多注意的都是ajax给我们所带来的好处诸如用户体验的提升。而对ajax所带来的缺陷有所忽视。</p>
<p>　　下面所阐述的ajax的缺陷都是它先天所产生的。</p>
<p>  　1、ajax干掉了back按钮，即对浏览器后退机制的破坏。后退按钮是一个标准的web站点的重要功能，但是它没法和js进行很好的合作。这是ajax所带来的一个比较严重的问题，因为用户往往是希望能够通过后退来取消前一次操作的。那么对于这个问题有没有办法？答案是肯定的，用过Gmail的知道，Gmail下面采用的ajax技术解决了这个问题，在Gmail下面是可以后退的，但是，它也并不能改变ajax的机制，它只是采用的一个比较笨但是有效的办法，即用户单击后退按钮访问历史记录时，通过创建或使用一个隐藏的IFRAME来重现页面上的变更。（例如，当用户在Google Maps中单击后退时，它在一个隐藏的IFRAME中进行搜索，然后将搜索结果反映到Ajax元素上，以便将应用程序状态恢复到当时的状态。）</p>
<p>但是，虽然说这个问题是可以解决的，但是它所带来的开发成本是非常高的，和ajax框架所要求的快速开发是相背离的。这是ajax所带来的一个非常严重的问题。</p>
<p>   2、安全问题</p>
<p>技术同时也对IT企业带来了新的安全威胁，ajax技术就如同对企业数据建立了一个直接通道。这使得开发者在不经意间会暴露比以前更多的数据和服务器逻辑。ajax的逻辑可以对客户端的安全扫描技术隐藏起来，允许黑客从远端服务器上建立新的攻击。还有ajax也难以避免一些已知的安全弱点，诸如跨站点脚步攻击、SQL注入攻击和基于credentials的安全漏洞等。</p>
<p>   3、对搜索引擎的支持比较弱。</p>
<p>   4、破坏了程序的异常机制。至少从目前看来，像ajax.dll，ajaxpro.dll这些ajax框架是会破坏程序的异常机制的。关于这个问题，我曾经在开发过程中遇到过，但是查了一下网上几乎没有相关的介绍。后来我自己做了一次试验，分别采用ajax和传统的form提交的模式来删除一条数据……给我们的调试带来了很大的困难。</p>
<p>   5、另外，像其他方面的一些问题，比如说违背了url和资源定位的初衷。例如，我给你一个url地址，如果采用了ajax技术，也许你在该url地址下面看到的和我在这个url地址下看到的内容是不同的。这个和资源定位的初衷是相背离的。</p>
<p>   6、一些手持设备（如手机、PDA等）现在还不能很好的支持ajax，比如说我们在手机的浏览器上打开采用ajax技术的网站时，它目前是不支持的，当然，这个问题和我们没太多关系。</p>
<p>　　<strong>5、$.ajax()方法详解</strong>　　　</p>
<p>jquery中的ajax方法参数总是记不住，这里记录一下。</p>
<p><strong>1.url</strong>: </p>
<p>要求为String类型的参数，（默认为当前页地址）发送请求的地址。</p>
<p><strong>2.type</strong>: </p>
<p>要求为String类型的参数，请求方式（post或get）默认为get。注意其他http请求方法，例如put和delete也可以使用，但仅部分浏览器支持。</p>
<p><strong>3.timeout</strong>: </p>
<p>要求为Number类型的参数，设置请求超时时间（毫秒）。此设置将覆盖$.ajaxSetup()方法的全局设置。</p>
<p><strong>4.async</strong>: </p>
<p>要求为Boolean类型的参数，默认设置为true，所有请求均为异步请求。如果需要发送同步请求，请将此选项设置为false。注意，同步请求将锁住浏览器，用户其他操作必须等待请求完成才可以执行。</p>
<p><strong>5.cache</strong>: </p>
<p>要求为Boolean类型的参数，默认为true（当dataType为script时，默认为false），设置为false将不会从浏览器缓存中加载请求信息。</p>
<p><strong>6.data</strong>: </p>
<p>要求为Object或String类型的参数，发送到服务器的数据。如果已经不是字符串，将自动转换为字符串格式。get请求中将附加在url后。防止这种自动转换，可以查看　　processData选项。对象必须为key&#x2F;value格式，例如{foo1:”bar1”,foo2:”bar2”}转换为&amp;foo1&#x3D;bar1&amp;foo2&#x3D;bar2。如果是数组，JQuery将自动为不同值对应同一个名称。例如{foo:[“bar1”,”bar2”]}转换为&amp;foo&#x3D;bar1&amp;foo&#x3D;bar2。</p>
<p><strong>7.dataType</strong>: </p>
<p>要求为String类型的参数，预期服务器返回的数据类型。如果不指定，JQuery将自动根据http包mime信息返回responseXML或responseText，并作为回调函数参数传递。可用的类型如下：</p>
<p>xml：返回XML文档，可用JQuery处理。</p>
<p>html：返回纯文本HTML信息；包含的script标签会在插入DOM时执行。</p>
<p>script：返回纯文本JavaScript代码。不会自动缓存结果。除非设置了cache参数。注意在远程请求时（不在同一个域下），所有post请求都将转为get请求。</p>
<p>json：返回JSON数据。</p>
<p>jsonp：JSONP格式。使用SONP形式调用函数时，例如myurl?callback&#x3D;?，JQuery将自动替换后一个“?”为正确的函数名，以执行回调函数。</p>
<p>text：返回纯文本字符串。</p>
<p><strong>8.beforeSend</strong>：</p>
<p>要求为Function类型的参数，发送请求前可以修改XMLHttpRequest对象的函数，例如添加自定义HTTP头。在beforeSend中如果返回false可以取消本次ajax请求。XMLHttpRequest对象是惟一的参数。</p>
<p>​      function(XMLHttpRequest){</p>
<p>​        this;  &#x2F;&#x2F;调用本次ajax请求时传递的options参数</p>
<p>​      }</p>
<p><strong>9.complete</strong>：</p>
<p>要求为Function类型的参数，请求完成后调用的回调函数（请求成功或失败时均调用）。参数：XMLHttpRequest对象和一个描述成功请求类型的字符串。</p>
<p>​     function(XMLHttpRequest, textStatus){</p>
<p>​       this;  &#x2F;&#x2F;调用本次ajax请求时传递的options参数</p>
<p>​     }</p>
<p><strong>10.success</strong>：要求为Function类型的参数，请求成功后调用的回调函数，有两个参数。</p>
<p>​     (1)由服务器返回，并根据dataType参数进行处理后的数据。</p>
<p>​     (2)描述状态的字符串。</p>
<p>​     function(data, textStatus){</p>
<p>​      &#x2F;&#x2F;data可能是xmlDoc、jsonObj、html、text等等</p>
<p>​      this; &#x2F;&#x2F;调用本次ajax请求时传递的options参数</p>
<p>​     }</p>
<p><strong>11.error</strong>:</p>
<p>要求为Function类型的参数，请求失败时被调用的函数。该函数有3个参数，即XMLHttpRequest对象、错误信息、捕获的错误对象(可选)。ajax事件函数如下：</p>
<p>​    function(XMLHttpRequest, textStatus, errorThrown){</p>
<p>​     &#x2F;&#x2F;通常情况下textStatus和errorThrown只有其中一个包含信息</p>
<p>​     this;  &#x2F;&#x2F;调用本次ajax请求时传递的options参数</p>
<p>​    }</p>
<p><strong>12.contentType</strong>：</p>
<p>要求为String类型的参数，当发送信息至服务器时，内容编码类型默认为”application&#x2F;x-www-form-urlencoded”。该默认值适合大多数应用场合。</p>
<p><strong>13.dataFilter</strong>：</p>
<p>要求为Function类型的参数，给Ajax返回的原始数据进行预处理的函数。提供data和type两个参数。data是Ajax返回的原始数据，type是调用jQuery.ajax时提供的dataType参数。函数返回的值将由jQuery进一步处理。</p>
<p>​      function(data, type){</p>
<p>​        &#x2F;&#x2F;返回处理后的数据</p>
<p>​        return data;</p>
<p>​      }</p>
<p><strong>14.dataFilter</strong>：</p>
<p>要求为Function类型的参数，给Ajax返回的原始数据进行预处理的函数。提供data和type两个参数。data是Ajax返回的原始数据，type是调用jQuery.ajax时提供的dataType参数。函数返回的值将由jQuery进一步处理。</p>
<p>​      function(data, type){</p>
<p>​        &#x2F;&#x2F;返回处理后的数据</p>
<p>​        return data;</p>
<p>​      }</p>
<p><strong>15.global</strong>：</p>
<p>要求为Boolean类型的参数，默认为true。表示是否触发全局ajax事件。设置为false将不会触发全局ajax事件，ajaxStart或ajaxStop可用于控制各种ajax事件。</p>
<p><strong>16.ifModified</strong>：</p>
<p>要求为Boolean类型的参数，默认为false。仅在服务器数据改变时获取新数据。服务器数据改变判断的依据是Last-Modified头信息。默认值是false，即忽略头信息。</p>
<p><strong>17.jsonp</strong>：</p>
<p>要求为String类型的参数，在一个jsonp请求中重写回调函数的名字。该值用来替代在”callback&#x3D;?”这种GET或POST请求中URL参数里的”callback”部分，例如{jsonp:’onJsonPLoad’}会导致将”onJsonPLoad&#x3D;?”传给服务器。</p>
<p><strong>18.username</strong>：</p>
<p>要求为String类型的参数，用于响应HTTP访问认证请求的用户名。</p>
<p><strong>19.password</strong>：</p>
<p>要求为String类型的参数，用于响应HTTP访问认证请求的密码。</p>
<p><strong>20.processData</strong>：</p>
<p>要求为Boolean类型的参数，默认为true。默认情况下，发送的数据将被转换为对象（从技术角度来讲并非字符串）以配合默认内容类型”application&#x2F;x-www-form-urlencoded”。如果要发送DOM树信息或者其他不希望转换的信息，请设置为false。</p>
<p><strong>21.scriptCharset</strong>：</p>
<p>要求为String类型的参数，只有当请求时dataType为”jsonp”或者”script”，并且type是GET时才会用于强制修改字符集(charset)。通常在本地和远程的内容编码不同时使用。</p>
<p>案例代码：</p>
<p>​    <img src="https://note.youdao.com/yws/res/235/3EB867867B6C4083AFDEC192BB4C964A" alt="复制代码"></p>
<p>$(function(){    $(‘#send’).click(function(){         $.ajax({             type: “GET”,             url: “test.json”,             data: {username:$(“#username”).val(), content:$(“#content”).val()},             dataType: “json”,             success: function(data){                         $(‘#resText’).empty();   &#x2F;&#x2F;清空resText里面的所有内容                         var html &#x3D; ‘’;                          $.each(data, function(commentIndex, comment){                               html +&#x3D; ‘</p>
<h6 id="‘-comment-‘username’-‘"><a href="#‘-comment-‘username’-‘" class="headerlink" title="‘ + comment[‘username’]                                         + ‘:"></a>‘ + comment[‘username’]                                         + ‘:</h6><p>‘;                         });                         $(‘#resText’).html(html);                      }         });    });});</p>
<p>​    <img src="https://note.youdao.com/yws/res/237/AAABEE8CEF9F4C8F939708C74D3126EA" alt="复制代码"></p>
<p><a target="_blank" rel="noopener" href="http://www.cnblogs.com/tylerdonet/p/3520862.html"> </a></p>
<p>　</p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Python%EF%BC%8CJS/" rel="tag">Python，JS</a></li></ul>

    </footer>
  </div>

    
 
    
</article>

    
    <article
  id="post-Python/爬虫/P6-Py-2异步的事件轮询机制"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2023/04/07/Python/%E7%88%AC%E8%99%AB/P6-Py-2%E5%BC%82%E6%AD%A5%E7%9A%84%E4%BA%8B%E4%BB%B6%E8%BD%AE%E8%AF%A2%E6%9C%BA%E5%88%B6/"
    >爬虫学习笔记-6.2Scrapy、JS等异步的事件轮询机制（base百度）</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2023/04/07/Python/%E7%88%AC%E8%99%AB/P6-Py-2%E5%BC%82%E6%AD%A5%E7%9A%84%E4%BA%8B%E4%BB%B6%E8%BD%AE%E8%AF%A2%E6%9C%BA%E5%88%B6/" class="article-date">
  <time datetime="2023-04-07T03:34:47.000Z" itemprop="datePublished">2023-04-07</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/code/">code</a> / <a class="article-category-link" href="/categories/code/note/">note</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h1 id="Scrapy、JS等异步的事件轮询机制"><a href="#Scrapy、JS等异步的事件轮询机制" class="headerlink" title="Scrapy、JS等异步的事件轮询机制"></a>Scrapy、JS等异步的事件轮询机制</h1><p><strong>什么是异步</strong></p>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/lan-cheng/p/10223455.html">https://www.cnblogs.com/lan-cheng/p/10223455.html</a></p>
<p><strong>什么是异步</strong></p>
<p>提起异步大家大家首先应该想到同步，首先解释一下什么是同步。同步即为按照顺序执行，下一任务需要等前一个任务执行完成后才可以开始。那异步是什么呢，简单理解就是和同步相反，他不用等待上一个任务完成就可以开始，像io操作，网络请求一般会采用异步的方式进行</p>
<p><strong>JS是如何是实现异步操作的？</strong> </p>
<p>  js是单线程语言,JS的异步是通过回调函数实现的，即通过任务队列，在主线程执行完当前的任务栈（所有的同步操作），主线程空闲后<strong>轮询</strong>任务队列，并将任务队列中的任务（回调函数）取出来执行。”回调函数”（callback），就是那些会被主线程挂起来的代码。异步任务必须指定回调函数，当主线程开始执行异步任务，就是执行对应的回调函数。</p>
<p><strong>关于<strong><strong>异步中的轮询</strong></strong>机制和<strong><strong>OS中的轮询</strong></strong>机制的区别：异步中的轮询是指当一个线程执行完任务栈中所有任务后轮询任务队列中被挂起的任务——–cpu有事干，没事干了再统一问一次；OS中的轮询是指只要这个I&#x2F;O控制器没就绪，就一直问，就绪也在询问——–cpu有事没事都要问（输入输出系统中用到）；</strong></p>
<p>  虽然JS是单线程的但是浏览器的内核是多线程的，在浏览器的内核中不同的异步操作由不同的浏览器内核模块调度执行，异步操作会将相关回调添加到任务队列中。而不同的异步操作添加到任务队列的时机也不同，（看不懂）如 onclick, setTimeout, ajax 处理的方式都不同，这些异步操作是由浏览器内核的 webcore 来执行的，webcore 包含上图中的3种 webAPI，分别是 DOM Binding、network、timer模块。</p>
<p><strong>JS中的异步运行机制如下:</strong> </p>
<p>（1）所有同步任务都在主线程上执行，形成一个执行栈（execution context stack）。</p>
<p>（2）主线程之外，还存在一个”任务队列”（task queue）。只要异步任务有了运行结果，就在”任务队列”之中放置一个事件。</p>
<p>（3）一旦”执行栈”中的所有同步任务执行完毕，系统就会读取”任务队列”，看看里面有哪些事件。那些对应的异步任务，于是结束等待状态，进入执行栈，开始执行。</p>
<p>（4）主线程不断重复上面的第三步。</p>
<p>-—————————————————————————————————————————————————————————-</p>
<img src="./P6-Py-2%E5%BC%82%E6%AD%A5%E5%AD%A6%E4%B9%A0.assets/image-20230421174507864.png" alt="image-20230421174507864" style="zoom:50%;" />

<p>-————————————————————————————————————————————————————————————</p>
<img src="./P6-Py-2%E5%BC%82%E6%AD%A5%E5%AD%A6%E4%B9%A0.assets/image-20230421174442474.png" alt="image-20230421174442474" style="zoom:50%;" />

<p><strong>异步的几种实现方式</strong></p>
<ol>
<li>回调函数</li>
<li>使用promise</li>
<li>ES7的Async&#x2F;Await</li>
</ol>
<p> 　</p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Python%EF%BC%8CJS/" rel="tag">Python，JS</a></li></ul>

    </footer>
  </div>

    
 
    
</article>

    
    <article
  id="post-前端学习笔记/JS/Q4-JS-7过滤"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2023/04/07/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/JS/Q4-JS-7%E8%BF%87%E6%BB%A4/"
    >JS学习笔记-4.7过滤（base  gpt ）</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2023/04/07/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/JS/Q4-JS-7%E8%BF%87%E6%BB%A4/" class="article-date">
  <time datetime="2023-04-07T03:34:47.000Z" itemprop="datePublished">2023-04-07</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/code/">code</a> / <a class="article-category-link" href="/categories/code/note/">note</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h1 id="4-7-1数组过滤"><a href="#4-7-1数组过滤" class="headerlink" title="4.7.1数组过滤"></a>4.7.1数组过滤</h1><ol>
<li><p>filter():过滤出符合条件的元素,返回新数组。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">array.filter(callbackFunc)</span><br></pre></td></tr></table></figure>

<p>callbackFunc 是过滤函数,用于测试每个元素是否通过测试。<br>filter() 方法返回一个过滤后的新数组。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">const fruits = [&#x27;apple&#x27;, &#x27;banana&#x27;, &#x27;grape&#x27;, &#x27;mango&#x27;, &#x27;orange&#x27;];</span><br><span class="line"></span><br><span class="line">const filterItems = fruits.filter(fruit =&gt; fruit.length &gt; 6);</span><br><span class="line"></span><br><span class="line">console.log(filterItems); </span><br><span class="line">// [&#x27;banana&#x27;, &#x27;mango&#x27;, &#x27;orange&#x27;]</span><br></pre></td></tr></table></figure>
</li>
<li><p>slice():提取符合条件的元素,返回新数组，属于浅拷贝。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">array.slice(start, end)</span><br></pre></td></tr></table></figure>

<p>start 和 end 表示截取的起止位置,不包含 end 位置的元素。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">let fruits = [&#x27;apple&#x27;, &#x27;banana&#x27;, &#x27;grape&#x27;, &#x27;mango&#x27;, &#x27;orange&#x27;];</span><br><span class="line">let sliceFruits = fruits.slice(1, 3);</span><br><span class="line">// sliceFruits = [&#x27;banana&#x27;, &#x27;grape&#x27;]</span><br></pre></td></tr></table></figure>
</li>
<li><p>splice():移除元素,并可以在移除的位置添加新元素。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">array.splice(start, deleteCount, ...newItems) </span><br></pre></td></tr></table></figure>

<p>- start:移除元素的起始位置<br>- deleteCount:要移除的元素个数<br>- newItems:要添加的新元素示例:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">let fruits = [&#x27;apple&#x27;, &#x27;banana&#x27;, &#x27;grape&#x27;, &#x27;mango&#x27;, &#x27;orange&#x27;]; </span><br><span class="line">fruits.splice(1, 2, &#x27;strawberry&#x27;);</span><br><span class="line">// fruits = [&#x27;apple&#x27;, &#x27;strawberry&#x27;, &#x27;mango&#x27;, &#x27;orange&#x27;]</span><br></pre></td></tr></table></figure>
</li>
<li><p>pop()&#x2F;shift():移除数组的最后&#x2F;第一个元素。</p>
</li>
<li><p>concat():相当于C++里的set。连接两个数组,并返回新数组。可以用于过滤两个数组的公共元素。</p>
</li>
<li><p>…(展开运算符):将一个数组展开为用 , 分隔的参数序列,可以用于过滤数组中的某些元素。</p>
<p>除此之外,我们也可以使用 ES6 的 Set 和 Map 等新数据结构进行过滤。</p>
</li>
</ol>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/JS/" rel="tag">JS</a></li></ul>

    </footer>
  </div>

    
 
    
</article>

    
    <article
  id="post-前端学习笔记/JS/Q4-JS-8面向对象"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2023/04/07/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/JS/Q4-JS-8%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"
    >JS学习笔记-4.8面向对象（base  gpt/答疑 ）</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2023/04/07/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/JS/Q4-JS-8%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/" class="article-date">
  <time datetime="2023-04-07T03:34:47.000Z" itemprop="datePublished">2023-04-07</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/code/">code</a> / <a class="article-category-link" href="/categories/code/note/">note</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h1 id="4-8面向对象"><a href="#4-8面向对象" class="headerlink" title="4.8面向对象"></a>4.8面向对象</h1><h2 id="4-8-1浅薄的了解"><a href="#4-8-1浅薄的了解" class="headerlink" title="4.8.1浅薄的了解"></a>4.8.1浅薄的了解</h2><h3 id="1-构造函数"><a href="#1-构造函数" class="headerlink" title="1.构造函数"></a>1.构造函数</h3><p>用于反复创建相同的对象，和Java一样，就是父类。</p>
<p>this.price&#x3D;price;意味着把传进来的price参数挂载到构造函数内部当作属性用了。</p>
<h3 id="2-是否使用原型函数（prototype）"><a href="#2-是否使用原型函数（prototype）" class="headerlink" title="2.是否使用原型函数（prototype）"></a>2.是否使用原型函数（prototype）</h3><p>构造函数内的方法如果是不变的，那么每次new一个新实例的时候都会调用这个方法，从而造成资源浪费。所以要把它挂载到原型上，并写在函数外部，这样就相当于只初始化一次。这样他实例化时，就会通过实例化（子类）的声明覆盖掉父类的声明。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">//Car构造函数的初始化</span><br><span class="line">Car(price)&#123;</span><br><span class="line">	this.price=price;</span><br><span class="line">&#125;</span><br><span class="line">//给Car函数增加原型函数</span><br><span class="line">Car.run=function()&#123;console.log(&quot;run as 100km/h&quot;)&#125;</span><br></pre></td></tr></table></figure>

<p>构造函数内的方法如果是基于传进来的参数要进行选择性创建的，那么就不用写成原型函数，且可以写在构造函数内部。<br><img src="./Q4-JS-7%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1.assets/image-20230421171703306.png" alt="image-20230421171703306" style="zoom:33%;" /></p>
<h3 id="3-原型链"><a href="#3-原型链" class="headerlink" title="3.原型链"></a>3.原型链</h3><p>在调用某个类的子函数的时候，先去找它本身是否声明过（这会覆盖父类的声明），然后找父类内部是否声明过，再找父类的prototype（原型）函数中有没有。</p>
<h3 id="4-覆盖"><a href="#4-覆盖" class="headerlink" title="4.覆盖"></a>4.覆盖</h3><p>子类的重复声明，会把父类的声明覆盖掉。</p>
<h3 id="5-静态属性"><a href="#5-静态属性" class="headerlink" title="5.静态属性"></a>5.静态属性</h3><p>就是只属于自己的属性。简称属性。</p>
<p>注：构造函数也可以有只属于自己的（无法被继承的）属性。</p>
<h3 id="6-一些疑问"><a href="#6-一些疑问" class="headerlink" title="6.一些疑问"></a>6.一些疑问</h3><p>1.浅拷贝都有什么实现方式<br>2.为什么创建对象的时候，对象里面的方法用的是引用，而属性不是</p>
<pre><code>这是因为在 JavaScript 中,对象的方法和属性有不同的存储方式:
属性:
- 属性的值直接存储在对象中
- 当读取属性时,直接返回对象中存储的值方法:- 方法的值实际上是一个函数
- 函数是引用类型,所以方法的值是一个指向函数的引用
- 当读取方法时,返回的是对函数的引用
</code></pre>
<p>   <a target="_blank" rel="noopener" href="https://test-rnt2063.slack.com/archives/D053Z3YFB4Y/p1682137400226899">https://test-rnt2063.slack.com/archives/D053Z3YFB4Y/p1682137400226899</a><br>3.为什么函数是引用类型，而不是拷贝？</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">1.为了让函数实现共用</span><br><span class="line">2.避免每次传递函数时都需要创建一个函数的完整拷贝。</span><br><span class="line">因为函数也是对象,如果是值类型,每次传递都需要将整个函数对象拷贝一份,这会消耗额外资源。</span><br><span class="line">而作为引用类型,我们只需要传递函数的引用,就能在多个地方调用同一个函数,不需要每次都创建一个新的函数对象。</span><br><span class="line">3.支持函数的动态性。如果函数是值类型,那么函数创建后其引用就永远固定了。而作为引用类型,函数的引用是可以动态修改和重新赋值的。</span><br><span class="line">在 JavaScript 中,函数是对象,而对象是引用类型。</span><br><span class="line">所以当我们传递或赋值一个函数时,传递的其实是对该函数对象的引用,而不是函数的拷贝。</span><br></pre></td></tr></table></figure>

<p>   <a target="_blank" rel="noopener" href="https://test-rnt2063.slack.com/archives/D053Z3YFB4Y/p1682137463065349">https://test-rnt2063.slack.com/archives/D053Z3YFB4Y/p1682137463065349</a><br>4.引用在JS里有什么用？</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">1. 允许对象之间共享信息。因为对对象的引用可以在多个变量之间传递,所以指向同一对象的多个变量可以共享该对象中的信息。</span><br><span class="line">例如:</span><br><span class="line">js</span><br><span class="line">let obj = &#123; a: 1 &#125;;</span><br><span class="line">let ref1 = obj;</span><br><span class="line">let ref2 = obj;</span><br><span class="line"></span><br><span class="line">ref1.a = 2;  // 通过 ref1 修改</span><br><span class="line"></span><br><span class="line">console.log(ref2.a); // 2  ref2 也受到影响</span><br><span class="line">这里 ref1 和 ref2 指向同一对象 obj,所以通过 ref1 对 obj 的修改也影响了 ref2。</span><br><span class="line"></span><br><span class="line">2. 实现继承和原型链。JS 中的继承是通过原型链实现的,子对象通过__proto__属性指向父对象,这个过程其实就是引用传递。</span><br><span class="line">例如:</span><br><span class="line">js</span><br><span class="line">let parent = &#123;</span><br><span class="line">  name: &#x27;parent&#x27; </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">let child = &#123;</span><br><span class="line">  __proto__: parent  // child 的 __proto__ 属性引用 parent</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">console.log(child.name); // parent </span><br><span class="line">这里 child 对 parent 的引用允许其访问 parent 的属性和方法。</span><br><span class="line"></span><br><span class="line">3. 函数也是对象,所以对函数的传递和赋值也是通过引用来实现的。这意味着多个变量可以共享同一个函数,并且函数的内部状态会影响所有接受到其引用的变量。</span><br><span class="line">例如:</span><br><span class="line">js</span><br><span class="line">function foo() &#123;</span><br><span class="line">  foo.count++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let bar = foo;</span><br><span class="line"></span><br><span class="line">bar();  // foo.count 是 1 </span><br><span class="line">foo();  // foo.count 是 2</span><br><span class="line">这里 bar 和 foo 指向同一个函数对象,所以调用 bar 或 foo 都会修改这个共享的函数对象。</span><br><span class="line"></span><br><span class="line">4. 允许循环引用。通过引用,两个对象可以相互引用对方,形成闭环。</span><br><span class="line">例如:</span><br><span class="line">js</span><br><span class="line">let obj1 = &#123;</span><br><span class="line">  name: &#x27;obj1&#x27;,</span><br><span class="line">  ref: obj2  // 引用 obj2 </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">let obj2 = &#123;</span><br><span class="line">  name: &#x27;obj2&#x27;,</span><br><span class="line">  ref: obj1  // 引用 obj1</span><br><span class="line">&#125;;</span><br><span class="line">  </span><br><span class="line">所以,总结来说,引用在 JS 中实现了对象之间的连接,是支持大部分面向对象特性和功能的基础。</span><br></pre></td></tr></table></figure>

<p>   <a target="_blank" rel="noopener" href="https://test-rnt2063.slack.com/archives/D053Z3YFB4Y/p1682137511999319">https://test-rnt2063.slack.com/archives/D053Z3YFB4Y/p1682137511999319</a><br>5.为什么对象是引用类型？<br>   <a target="_blank" rel="noopener" href="https://test-rnt2063.slack.com/archives/D053Z3YFB4Y/p1682137569143519">https://test-rnt2063.slack.com/archives/D053Z3YFB4Y/p1682137569143519</a><br>6.构造函数可以被继承的部分一定是引用类型吗？<br>   <a target="_blank" rel="noopener" href="https://test-rnt2063.slack.com/archives/D053Z3YFB4Y/p1682137669380839">https://test-rnt2063.slack.com/archives/D053Z3YFB4Y/p1682137669380839</a><br>7.不是引用类型的部分怎么实现可以被继承的？<br>   <a target="_blank" rel="noopener" href="https://test-rnt2063.slack.com/archives/D053Z3YFB4Y/p1682137704757199">https://test-rnt2063.slack.com/archives/D053Z3YFB4Y/p1682137704757199</a><br>8.构造函数中，可继承的部分中，不是引用类型的部分为什么不用引用实现被继承？<br>    每一个继承对象理应拥有父对象中某些属性的一个独立拷贝,而不是共享一个属性的引用<br>    <a target="_blank" rel="noopener" href="https://test-rnt2063.slack.com/archives/D053Z3YFB4Y/p1682138844233269">https://test-rnt2063.slack.com/archives/D053Z3YFB4Y/p1682138844233269</a><br>9.完整拷贝对象比引用浪费了哪些资源？<br>    1更多的内存空间,需要存储对象的完整结构<br>    2更长的处理时间,需要遍历对象属性进行拷贝<br>    3创建额外的临时对象   </p>
<p>10.引用不用储存对象的完整结构吗？什么叫对象的完整结构？<br>    引用也需要存储对象的结构,但是与拷贝相比,引用只需要存储对象结构一次。<br>    引用的工作原理是:多个变量存储的是对同一个对象的引用,通过这个引用可以访问到对象的结构。</p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/JS/" rel="tag">JS</a></li></ul>

    </footer>
  </div>

    
 
    
</article>

    
    <article
  id="post-前端学习笔记/JS/Q4-JS-9衍生知识（es6、过滤思路、深浅拷贝的原理、debug、函数复用）"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2023/04/07/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/JS/Q4-JS-9%E8%A1%8D%E7%94%9F%E7%9F%A5%E8%AF%86%EF%BC%88es6%E3%80%81%E8%BF%87%E6%BB%A4%E6%80%9D%E8%B7%AF%E3%80%81%E6%B7%B1%E6%B5%85%E6%8B%B7%E8%B4%9D%E7%9A%84%E5%8E%9F%E7%90%86%E3%80%81debug%E3%80%81%E5%87%BD%E6%95%B0%E5%A4%8D%E7%94%A8%EF%BC%89/"
    >JS学习笔记-4.9衍生知识（base gpt/答疑）</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2023/04/07/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/JS/Q4-JS-9%E8%A1%8D%E7%94%9F%E7%9F%A5%E8%AF%86%EF%BC%88es6%E3%80%81%E8%BF%87%E6%BB%A4%E6%80%9D%E8%B7%AF%E3%80%81%E6%B7%B1%E6%B5%85%E6%8B%B7%E8%B4%9D%E7%9A%84%E5%8E%9F%E7%90%86%E3%80%81debug%E3%80%81%E5%87%BD%E6%95%B0%E5%A4%8D%E7%94%A8%EF%BC%89/" class="article-date">
  <time datetime="2023-04-07T03:34:47.000Z" itemprop="datePublished">2023-04-07</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/code/">code</a> / <a class="article-category-link" href="/categories/code/note/">note</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br></pre></td><td class="code"><pre><span class="line">// 一个数据里面去匹配</span><br><span class="line">// 1.字符的匹配</span><br><span class="line">const text = &#x27;hello world&#x27;;</span><br><span class="line">const reg = /helli/;</span><br><span class="line"></span><br><span class="line">const result = text.match(reg);</span><br><span class="line"></span><br><span class="line">// console.log(&quot;result&quot;,result)</span><br><span class="line"></span><br><span class="line">// 2.在一堆数据里面去筛选</span><br><span class="line"></span><br><span class="line">// 3.浅拷贝</span><br><span class="line">const shallowClone = (target) =&gt; &#123;</span><br><span class="line">  const result = &#123;&#125;;</span><br><span class="line">  for (let key in target) &#123;</span><br><span class="line">    result[key] = target[key];</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  return result;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">// // 4.深拷贝</span><br><span class="line">// const deepClone = (target) =&gt; &#123;</span><br><span class="line">//     const obj = &#123;&#125;</span><br><span class="line">//     for (let key in target) &#123;</span><br><span class="line">//         const value = target[key];</span><br><span class="line">//         if (isObj(target)) &#123;</span><br><span class="line">//             obj[key] = deepClone(value)</span><br><span class="line">//         &#125; else &#123;</span><br><span class="line">//             obj[key] = value</span><br><span class="line">//         &#125;</span><br><span class="line">//     &#125;</span><br><span class="line"></span><br><span class="line">//     return obj</span><br><span class="line">// &#125;</span><br><span class="line"></span><br><span class="line">//5.找到复杂对象中的某几个符合的数据</span><br><span class="line">const list = [</span><br><span class="line">  &#123; name: &#x27;zhangsan&#x27;, id: 1 &#125;,</span><br><span class="line">  &#123; name: &#x27;lisi&#x27;, id: 2 &#125;,</span><br><span class="line">  &#123; name: &#x27;wangwu&#x27;, id: 3 &#125;,</span><br><span class="line">  &#123; name: &#x27;wangwu&#x27;, id: 4 &#125;,</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line">// 得分字段 score:10</span><br><span class="line"></span><br><span class="line">const getName = function (item) &#123;</span><br><span class="line">  return item.name === &#x27;wangwu&#x27;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">// 5.1 forEach 遍历</span><br><span class="line"></span><br><span class="line">// 5.2 for of遍历，判断 数组是否满足条件</span><br><span class="line"></span><br><span class="line">//5.3 判断条件独立出来，函数复用</span><br><span class="line"></span><br><span class="line">// 5.2.1every 所有条件满足返回true,否则返回false</span><br><span class="line">const everyResult = list.every(getName);</span><br><span class="line">console.log(&#x27;everyResult&#x27;, everyResult);</span><br><span class="line"></span><br><span class="line">// 5.2.2some 任一条件满足返回true，否则返回false</span><br><span class="line">const someResult = list.some(getName);</span><br><span class="line">console.log(&#x27;someResult&#x27;, someResult);</span><br><span class="line"></span><br><span class="line">const target = [];</span><br><span class="line"></span><br><span class="line">list.forEach((item) =&gt; &#123;</span><br><span class="line">  target.push(&#123;</span><br><span class="line">    ...item,</span><br><span class="line">    score: 10,</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">return target;</span><br><span class="line"></span><br><span class="line">// 5.3map</span><br><span class="line"></span><br><span class="line">// 5.4reduce</span><br><span class="line"></span><br><span class="line">// 6.深拷贝的底层原理：判断数据类型是否为Object</span><br><span class="line">const isObj = (target) =&gt;</span><br><span class="line">  Object.prototype.toString.call(target) === &#x27;[object Object]&#x27;;</span><br><span class="line"></span><br><span class="line">const deepClone = (target) =&gt; &#123;</span><br><span class="line">  const obj = &#123;&#125;;</span><br><span class="line">  for (let key in target) &#123;</span><br><span class="line">    const value = target[key];</span><br><span class="line">    debugger;</span><br><span class="line">    if (isObj(value)) &#123;</span><br><span class="line">      debugger;</span><br><span class="line">      obj[key] = deepClone(value);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      debugger;</span><br><span class="line">      obj[key] = value;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  return obj;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">deepClone(&#123; a: &#123; b: 10 &#125; &#125;);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/JS/" rel="tag">JS</a></li></ul>

    </footer>
  </div>

    
 
    
</article>

    
    <article
  id="post-前端学习笔记/【【【【【疑问解答】】】】】/CSS/4.4 4.5position/3.粘性定位/main"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
     
    <div class="article-meta">
      <a href="/2023/04/05/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E3%80%90%E3%80%90%E3%80%90%E3%80%90%E3%80%90%E7%96%91%E9%97%AE%E8%A7%A3%E7%AD%94%E3%80%91%E3%80%91%E3%80%91%E3%80%91%E3%80%91/CSS/4.4%204.5position/3.%E7%B2%98%E6%80%A7%E5%AE%9A%E4%BD%8D/main/" class="article-date">
  <time datetime="2023-04-05T10:07:10.000Z" itemprop="datePublished">2023-04-05</time>
</a>    
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  * {
    margin: 0;
    padding: 0;
}
.box {
    position: relative;
}
ul {
    list-style: none;
    display: flex;
    background-color: #09d;
    padding: 6px 6px;
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
}
ul li {
    font-size: 14px;
    color: #fff;
}
ul li:not(:last-child) {
    margin-right: 8px;
}

.content div {
    margin: 60px 0;
} 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
    </footer>
  </div>

    
 
    
</article>

    
  </article>
  

  
  <nav class="page-nav">
    
    <a class="extend prev" rel="prev" href="/">上一页</a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><a class="page-number" href="/page/4/">4</a><a class="page-number" href="/page/5/">5</a><a class="extend next" rel="next" href="/page/3/">下一页</a>
  </nav>
  
</section>
</div>

      <footer class="footer">
  <div class="outer">
    <ul>
      <li>
        Copyrights &copy;
        2023
        <i class="ri-heart-fill heart_icon"></i> LIXiaohan
      </li>
    </ul>
    <ul>
      <li>
        
      </li>
    </ul>
    <ul>
      <li>
        
        
        <span>
  <span><i class="ri-user-3-fill"></i>访问人数:<span id="busuanzi_value_site_uv"></span></span>
  <span class="division">|</span>
  <span><i class="ri-eye-fill"></i>浏览次数:<span id="busuanzi_value_page_pv"></span></span>
</span>
        
      </li>
    </ul>
    <ul>
      
    </ul>
    <ul>
      
      <li>
          <img src="/images/beian.png"></img>
          <a href="http://www.beian.gov.cn/portal/registerSystemInfo?recordcode=01234567890123" target="_black" rel="nofollow">黑公网安备0123456789号</a>
      </li>
        
    </ul>
    <ul>
      <li>
        <!-- cnzz统计 -->
        
        <script type="text/javascript" src=''></script>
        
      </li>
    </ul>
  </div>
</footer>    
    </main>
    <div class="float_btns">
      <div class="totop" id="totop">
  <i class="ri-arrow-up-line"></i>
</div>

<div class="todark" id="todark">
  <i class="ri-moon-line"></i>
</div>

    </div>
    <aside class="sidebar on">
      <button class="navbar-toggle"></button>
<nav class="navbar">
  
  <div class="logo">
    <a href="/"><img src="/images/ayer-side.svg" alt="Pravite Home"></a>
  </div>
  
  <ul class="nav nav-main">
    
    <li class="nav-item">
      <a class="nav-item-link" href="/">主页</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/archives">归档</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/categories">分类</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/tags">标签</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/2019/about">关于我</a>
    </li>
    
  </ul>
</nav>
<nav class="navbar navbar-bottom">
  <ul class="nav">
    <li class="nav-item">
      
      <a class="nav-item-link nav-item-search"  title="搜索">
        <i class="ri-search-line"></i>
      </a>
      
      
      <a class="nav-item-link" target="_blank" href="/atom.xml" title="RSS Feed">
        <i class="ri-rss-line"></i>
      </a>
      
    </li>
  </ul>
</nav>
<div class="search-form-wrap">
  <div class="local-search local-search-plugin">
  <input type="search" id="local-search-input" class="local-search-input" placeholder="Search...">
  <div id="local-search-result" class="local-search-result"></div>
</div>
</div>
    </aside>
    <div id="mask"></div>

<!-- #reward -->
<div id="reward">
  <span class="close"><i class="ri-close-line"></i></span>
  <p class="reward-p"><i class="ri-cup-line"></i>请我喝杯咖啡吧~</p>
  <div class="reward-box">
    
    <div class="reward-item">
      <img class="reward-img" src="/images/alipay.jpg">
      <span class="reward-type">支付宝</span>
    </div>
    
    
    <div class="reward-item">
      <img class="reward-img" src="/images/wechat.jpg">
      <span class="reward-type">微信</span>
    </div>
    
  </div>
</div>
    
<script src="/js/jquery-3.6.0.min.js"></script>
 
<script src="/js/lazyload.min.js"></script>

<!-- Tocbot -->

<script src="https://cdn.staticfile.org/jquery-modal/0.9.2/jquery.modal.min.js"></script>
<link
  rel="stylesheet"
  href="https://cdn.staticfile.org/jquery-modal/0.9.2/jquery.modal.min.css"
/>
<script src="https://cdn.staticfile.org/justifiedGallery/3.8.1/js/jquery.justifiedGallery.min.js"></script>

<script src="/dist/main.js"></script>

<!-- ImageViewer -->
 <!-- Root element of PhotoSwipe. Must have class pswp. -->
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">

    <!-- Background of PhotoSwipe. 
         It's a separate element as animating opacity is faster than rgba(). -->
    <div class="pswp__bg"></div>

    <!-- Slides wrapper with overflow:hidden. -->
    <div class="pswp__scroll-wrap">

        <!-- Container that holds slides. 
            PhotoSwipe keeps only 3 of them in the DOM to save memory.
            Don't modify these 3 pswp__item elements, data is added later on. -->
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>

        <!-- Default (PhotoSwipeUI_Default) interface on top of sliding area. Can be changed. -->
        <div class="pswp__ui pswp__ui--hidden">

            <div class="pswp__top-bar">

                <!--  Controls are self-explanatory. Order can be changed. -->

                <div class="pswp__counter"></div>

                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>

                <button class="pswp__button pswp__button--share" style="display:none" title="Share"></button>

                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>

                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>

                <!-- Preloader demo http://codepen.io/dimsemenov/pen/yyBWoR -->
                <!-- element will get class pswp__preloader--active when preloader is running -->
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                        <div class="pswp__preloader__cut">
                            <div class="pswp__preloader__donut"></div>
                        </div>
                    </div>
                </div>
            </div>

            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div>
            </div>

            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>

            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>

            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>

        </div>

    </div>

</div>

<link rel="stylesheet" href="https://cdn.staticfile.org/photoswipe/4.1.3/photoswipe.min.css">
<link rel="stylesheet" href="https://cdn.staticfile.org/photoswipe/4.1.3/default-skin/default-skin.min.css">
<script src="https://cdn.staticfile.org/photoswipe/4.1.3/photoswipe.min.js"></script>
<script src="https://cdn.staticfile.org/photoswipe/4.1.3/photoswipe-ui-default.min.js"></script>

<script>
    function viewer_init() {
        let pswpElement = document.querySelectorAll('.pswp')[0];
        let $imgArr = document.querySelectorAll(('.article-entry img:not(.reward-img)'))

        $imgArr.forEach(($em, i) => {
            $em.onclick = () => {
                // slider展开状态
                // todo: 这样不好，后面改成状态
                if (document.querySelector('.left-col.show')) return
                let items = []
                $imgArr.forEach(($em2, i2) => {
                    let img = $em2.getAttribute('data-idx', i2)
                    let src = $em2.getAttribute('data-target') || $em2.getAttribute('src')
                    let title = $em2.getAttribute('alt')
                    // 获得原图尺寸
                    const image = new Image()
                    image.src = src
                    items.push({
                        src: src,
                        w: image.width || $em2.width,
                        h: image.height || $em2.height,
                        title: title
                    })
                })
                var gallery = new PhotoSwipe(pswpElement, PhotoSwipeUI_Default, items, {
                    index: parseInt(i)
                });
                gallery.init()
            }
        })
    }
    viewer_init()
</script> 
<!-- MathJax -->
 <script type="text/x-mathjax-config">
  MathJax.Hub.Config({
      tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
          processEscapes: true,
          skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
      }
  });

  MathJax.Hub.Queue(function() {
      var all = MathJax.Hub.getAllJax(), i;
      for(i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
      }
  });
</script>

<script src="https://cdn.staticfile.org/mathjax/2.7.7/MathJax.js"></script>
<script src="https://cdn.staticfile.org/mathjax/2.7.7/config/TeX-AMS-MML_HTMLorMML-full.js"></script>
<script>
  var ayerConfig = {
    mathjax: true,
  };
</script>

<!-- Katex -->

<!-- busuanzi  -->
 
<script src="/js/busuanzi-2.3.pure.min.js"></script>
 
<!-- ClickLove -->

<!-- ClickBoom1 -->

<!-- ClickBoom2 -->
 
<script src="/js/clickBoom2.js"></script>
 
<!-- CodeCopy -->
 
<link rel="stylesheet" href="/css/clipboard.css">
 <script src="https://cdn.staticfile.org/clipboard.js/2.0.10/clipboard.min.js"></script>
<script>
  function wait(callback, seconds) {
    var timelag = null;
    timelag = window.setTimeout(callback, seconds);
  }
  !function (e, t, a) {
    var initCopyCode = function(){
      var copyHtml = '';
      copyHtml += '<button class="btn-copy" data-clipboard-snippet="">';
      copyHtml += '<i class="ri-file-copy-2-line"></i><span>COPY</span>';
      copyHtml += '</button>';
      $(".highlight .code pre").before(copyHtml);
      $(".article pre code").before(copyHtml);
      var clipboard = new ClipboardJS('.btn-copy', {
        target: function(trigger) {
          return trigger.nextElementSibling;
        }
      });
      clipboard.on('success', function(e) {
        let $btn = $(e.trigger);
        $btn.addClass('copied');
        let $icon = $($btn.find('i'));
        $icon.removeClass('ri-file-copy-2-line');
        $icon.addClass('ri-checkbox-circle-line');
        let $span = $($btn.find('span'));
        $span[0].innerText = 'COPIED';
        
        wait(function () { // 等待两秒钟后恢复
          $icon.removeClass('ri-checkbox-circle-line');
          $icon.addClass('ri-file-copy-2-line');
          $span[0].innerText = 'COPY';
        }, 2000);
      });
      clipboard.on('error', function(e) {
        e.clearSelection();
        let $btn = $(e.trigger);
        $btn.addClass('copy-failed');
        let $icon = $($btn.find('i'));
        $icon.removeClass('ri-file-copy-2-line');
        $icon.addClass('ri-time-line');
        let $span = $($btn.find('span'));
        $span[0].innerText = 'COPY FAILED';
        
        wait(function () { // 等待两秒钟后恢复
          $icon.removeClass('ri-time-line');
          $icon.addClass('ri-file-copy-2-line');
          $span[0].innerText = 'COPY';
        }, 2000);
      });
    }
    initCopyCode();
  }(window, document);
</script>
 
<!-- CanvasBackground -->

<script>
  if (window.mermaid) {
    mermaid.initialize({ theme: "forest" });
  }
</script>


    
    <div id="music">
    
    
    
    <iframe frameborder="no" border="1" marginwidth="0" marginheight="0" width="200" height="52"
        src="//music.163.com/outchain/player?type=2&id=22707008&auto=1&height=32"></iframe>
</div>

<style>
    #music {
        position: fixed;
        right: 15px;
        bottom: 0;
        z-index: 998;
    }
</style>
    
    
<script>
  const password = "11";
  const lock_password = window.sessionStorage.getItem("lock_password");
  console.log(password, lock_password);
  if (lock_password !== password) {
    Swal.fire({
      title: "请输入访问密码",
      input: "text",
      inputAttributes: {
        autocapitalize: "off",
      },
      showCancelButton: false,
      showLoaderOnConfirm: true,
      allowOutsideClick: false,
      confirmButtonText: "确定",
    }).then((result) => {
      console.log(result);
      if (result.isConfirmed) {
        console.log(password);
        if (result.value === password) {
          window.sessionStorage.setItem("lock_password", result.value);
        } else {
          Swal.fire({
            icon: "error",
            title: "密码错误，请重试",
            confirmButtonText: "确定",
            allowOutsideClick: false,
          }).then(() => {
            window.location.reload();
          });
        }
      }
    });
  }
</script>


  </div>
</body>

</html>