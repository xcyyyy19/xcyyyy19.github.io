<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>大一社团练习与竞赛代码笔记</title>
    <url>/2023/03/11/ACM/C1-%E5%A4%A7%E4%B8%80%E7%A4%BE%E5%9B%A2%E7%BB%83%E4%B9%A0%E4%B8%8E%E7%AB%9E%E8%B5%9B%E4%BB%A3%E7%A0%81%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h2 id="附件见文末"><a href="#附件见文末" class="headerlink" title="附件见文末"></a>附件见文末</h2><p><img src="/../pic/C1/1.png"><br><img src="/../pic/C1/2.png"><br><img src="/../pic/C1/3.png"><br><img src="/../pic/C1/4.png"></p>
<h2 id="附件"><a href="#附件" class="headerlink" title="附件"></a>附件</h2><p><a href="https://xcyyyy19.github.io/code/C1/lxhcode.zip">代码下载链接</a></p>
]]></content>
      <categories>
        <category>code</category>
        <category>note</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
      </tags>
  </entry>
  <entry>
    <title>Java网站代码（Java结业项目）【待上传】</title>
    <url>/2023/03/11/Java/J1-Java%E7%BD%91%E7%AB%99%E4%BB%A3%E7%A0%81%EF%BC%88Java%E7%BB%93%E4%B8%9A%E9%A1%B9%E7%9B%AE%EF%BC%89/</url>
    <content><![CDATA[<ul>
<li><input disabled="" type="checkbox"> 当时老师要求模仿的网站是啥相关的来着？主力机上的Java代码放哪个云上了？</li>
</ul>
]]></content>
      <categories>
        <category>code</category>
        <category>project</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Python爬虫&amp;数据分析&amp;前后端代码（毕设）【待上传】</title>
    <url>/2023/03/13/Python/P3-Python%E7%88%AC%E8%99%AB-%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90-%E5%89%8D%E5%90%8E%E7%AB%AF%E4%BB%A3%E7%A0%81%EF%BC%88%E6%AF%95%E8%AE%BE%EF%BC%89/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>code</category>
        <category>project</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>大二社团练习与竞赛代码笔记</title>
    <url>/2023/03/11/ACM/C2-%E5%A4%A7%E4%BA%8C%E7%A4%BE%E5%9B%A2%E7%BB%83%E4%B9%A0%E4%B8%8E%E7%AB%9E%E8%B5%9B%E4%BB%A3%E7%A0%81%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h2 id="附件见文末"><a href="#附件见文末" class="headerlink" title="附件见文末"></a>附件见文末</h2><p><img src="/../pic/C2/1.png"><br><img src="/../pic/C2/2.png"><br><img src="/../pic/C2/3.png"></p>
<h2 id="附件"><a href="#附件" class="headerlink" title="附件"></a>附件</h2><p><a href="https://xcyyyy19.github.io/code/C2/LxhCode2.zip">代码下载链接</a></p>
]]></content>
      <categories>
        <category>code</category>
        <category>note</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
      </tags>
  </entry>
  <entry>
    <title>Python爬虫练习代码与笔记（社工）</title>
    <url>/2023/03/12/Python/P2-Python%E7%88%AC%E8%99%AB%E7%BB%83%E4%B9%A0%E4%BB%A3%E7%A0%81%E4%B8%8E%E7%AC%94%E8%AE%B0%EF%BC%88%E7%A4%BE%E5%B7%A5%EF%BC%89/</url>
    <content><![CDATA[<p>声明：仅供学习使用</p>
<p>以下黑色代码块包含入门时的学习链接以及中文标题</p>
<ul>
<li><p><input disabled="" type="checkbox"> 
待上传html链接版本</p>
</li>
<li><p><input disabled="" type="checkbox"> 
待上传代码</p>
<pre><code>                  &lt;H3 ADD_DATE=&quot;1678696134&quot; LAST_MODIFIED=&quot;1678696150&quot;&gt;河蟹&lt;/H3&gt;
                  &lt;DL&gt;
                      &lt;p&gt;
                          &lt;DT&gt;
                              &lt;H3 ADD_DATE=&quot;1678696134&quot; LAST_MODIFIED=&quot;1678696134&quot;&gt;github的河蟹&lt;/H3&gt;
                              &lt;DL&gt;
                                  &lt;p&gt;
                                      &lt;DT&gt;
                                          &lt;A HREF=&quot;https://github.com/lymwpc/phone_email_extract&quot; ADD_DATE=&quot;1678696134&quot;&gt;GitHub - lymwpc/phone_email_extract: 一个python的正则表达式模块，可以完成给定页面内容中符合格式要求的手机号和邮箱的提取&lt;/A&gt;
                                      &lt;DT&gt;
                                          &lt;A HREF=&quot;https://github.com/hahaxiaowei/spring-boot-login&quot; ADD_DATE=&quot;1678696134&quot;&gt;GitHub - hahaxiaowei/spring-boot-login: 里面包含了登录所需的所有接口，包括了手机号登录，邮箱登录，用户名登录&lt;/A&gt;
                                      &lt;DT&gt;
                                          &lt;A HREF=&quot;https://github.com/fenglingdeyi/Regular&quot; ADD_DATE=&quot;1678696134&quot;&gt;GitHub - fenglingdeyi/Regular: 该项目是对一些验证的封装，在登录注册中进行身份证、手机号、邮箱等验证的封装&lt;/A&gt;
                                      &lt;DT&gt;
                                          &lt;A HREF=&quot;https://github.com/hellozhengmingming/Utility&quot; ADD_DATE=&quot;1678696134&quot;&gt;GitHub - hellozhengmingming/Utility: 公共库，主要是字符串的判断，如：手机号，邮箱，身份证号的验证，颜色的转换，&lt;/A&gt;
                                      &lt;DT&gt;
                                          &lt;A HREF=&quot;https://github.com/toviLau/angular.strCover&quot; ADD_DATE=&quot;1678696134&quot;&gt;GitHub - toviLau/angular.strCover: 这是一个angular字符串格式化的过滤器，支持手机号 / 固定电话 / 银行卡 / 普通数字卡号 / 身份证 / 姓名 / 用户名 / 电子邮箱&lt;/A&gt;
                                      &lt;DT&gt;
                                          &lt;A HREF=&quot;https://github.com/PhoenixHai/Mobile-area&quot; ADD_DATE=&quot;1678696134&quot;&gt;GitHub - PhoenixHai/Mobile-area: 手机归属地号段大全，提ISSUE留下邮箱。&lt;/A&gt;
                                      &lt;DT&gt;
                                          &lt;A HREF=&quot;https://github.com/DandreYang/YFValidate&quot; ADD_DATE=&quot;1678696134&quot;&gt;GitHub - DandreYang/YFValidate: 用于手机号、邮箱、车牌号码、车架号、银行卡号、身份证号、URL等格式的验证&lt;/A&gt;
                                      &lt;DT&gt;
                                          &lt;A HREF=&quot;https://github.com/shuaiwang007/RE&quot; ADD_DATE=&quot;1678696134&quot;&gt;GitHub - shuaiwang007/RE: 正则使用的简单封装，验证用户名、密码、手机号、邮箱等等，只要一句话&lt;/A&gt;
                                      &lt;DT&gt;
                                          &lt;A HREF=&quot;https://github.com/Fairy-happy/checkNumber&quot; ADD_DATE=&quot;1678696134&quot;&gt;GitHub - Fairy-happy/checkNumber: 集成了检验各种号码包括手机号，邮箱，车牌合法性的方法&lt;/A&gt;
                                      &lt;DT&gt;
                                          &lt;A HREF=&quot;https://github.com/Conquer17/iOS-SQRegularExpression&quot; ADD_DATE=&quot;1678696134&quot;&gt;GitHub - Conquer17/iOS-SQRegularExpression: 手机号、密码、身份证号、银行卡号、邮箱等常用正则表达式&lt;/A&gt;
                                      &lt;DT&gt;
                                          &lt;A HREF=&quot;https://github.com/ChenZhongPu/checkReg&quot; ADD_DATE=&quot;1678696134&quot;&gt;GitHub - ChenZhongPu/checkReg: 检测一个邮箱或手机号在互联网上的注册情况&lt;/A&gt;
                                      &lt;DT&gt;
                                          &lt;A HREF=&quot;https://github.com/yshysh123/regular-expression&quot; ADD_DATE=&quot;1678696134&quot;&gt;GitHub - yshysh123/regular-expression: 正则验证QQ号，邮箱，手机，生日&lt;/A&gt;
                                      &lt;DT&gt;
                                          &lt;A HREF=&quot;https://github.com/fighting41love/funNLP&quot; ADD_DATE=&quot;1678696134&quot;&gt;超级丰富的re&lt;/A&gt;
                                      &lt;DT&gt;
                                          &lt;A HREF=&quot;https://github.com/zhengboss/sina_weibo_spider/blob/spider/target/test-classes/com/ideepwise/AppTest.class&quot; ADD_DATE=&quot;1678696134&quot;&gt;sina_weibo_spider/AppTest.class at spider · zhengboss/sina_weibo_spider · GitHub&lt;/A&gt;
                                      &lt;DT&gt;
                                          &lt;A HREF=&quot;https://github.com/zhengboss/sina_weibo_spider&quot; ADD_DATE=&quot;1678696134&quot;&gt;GitHub - zhengboss/sina_weibo_spider: 使用htmlunit框架的新浪微博爬虫&lt;/A&gt;
                                      &lt;DT&gt;
                                          &lt;A HREF=&quot;https://github.com/wshuai17//scrapy_spider&quot; ADD_DATE=&quot;1678696134&quot;&gt;王帅的spider&lt;/A&gt;
                                      &lt;DT&gt;
                                          &lt;A HREF=&quot;https://github.com/wshuai17/scrapy_spider/blob/master/first_spider/spiders/spider1.py&quot; ADD_DATE=&quot;1678696134&quot;&gt;ws_spider&lt;/A&gt;
                                      &lt;DT&gt;
                                          &lt;A HREF=&quot;https://github.com/PhoenixHai/Mobile-area/blob/master/README.md&quot; ADD_DATE=&quot;1678696134&quot;&gt;三年前的所有手机号归属地&lt;/A&gt;
                                      &lt;DT&gt;
                                          &lt;A HREF=&quot;https://github.com/zhaozichuan/wxby&quot; ADD_DATE=&quot;1678696134&quot;&gt;GitHub - zhaozichuan/wxby&lt;/A&gt;
                                      &lt;DT&gt;
                                          &lt;A HREF=&quot;https://github.com/eninem123/code&quot; ADD_DATE=&quot;1678696134&quot;&gt;GitHub - eninem123/code: 全是各种爬虫 京东，谷歌搜索，大象医生，ip池，百度搜索web实现，豆瓣，itchat,qq爬虫，词云，微博爬虫，知乎爬虫，微信机器人&lt;/A&gt;
                                      &lt;DT&gt;
                                          &lt;A HREF=&quot;https://github.com/VincentSit/ChinaMobilePhoneNumberRegex&quot; ADD_DATE=&quot;1678696134&quot;&gt;中国电话正则&lt;/A&gt;
                                      &lt;DT&gt;
                                          &lt;A HREF=&quot;https://github.com/dunizb/JS-Regular-expression-awesome&quot; ADD_DATE=&quot;1678696134&quot;&gt;各种re&lt;/A&gt;
                              &lt;/DL&gt;
                              &lt;p&gt;
                                  &lt;DT&gt;
                                      &lt;H3 ADD_DATE=&quot;1678696134&quot; LAST_MODIFIED=&quot;1678696134&quot;&gt;现在用不上的河蟹&lt;/H3&gt;
                                      &lt;DL&gt;
                                          &lt;p&gt;
                                              &lt;DT&gt;
                                                  &lt;A HREF=&quot;https://juejin.im/entry/59a764b96fb9a0249c007520&quot; ADD_DATE=&quot;1678696134&quot;&gt;利用搜索引擎做一些「不可描述」的事情 - 后端 - 掘金&lt;/A&gt;
                                              &lt;DT&gt;
                                                  &lt;A HREF=&quot;https://www.zoomeye.org/&quot; ADD_DATE=&quot;1678696134&quot;&gt;ZoomEye - Cyberspace Search Engine&lt;/A&gt;
                                              &lt;DT&gt;
                                                  &lt;A HREF=&quot;https://www.shodan.io/?language=en&quot; ADD_DATE=&quot;1678696134&quot;&gt;Shodan&lt;/A&gt;
                                              &lt;DT&gt;
                                                  &lt;A HREF=&quot;https://www.tianxia.la/wap/news/1628.html&quot; ADD_DATE=&quot;1678696134&quot;&gt;暗网&lt;/A&gt;
                                              &lt;DT&gt;
                                                  &lt;A HREF=&quot;http://www.hackdig.com/wap/hacktool.php&quot; ADD_DATE=&quot;1678696134&quot;&gt;黑客工具导航&lt;/A&gt;
                                              &lt;DT&gt;
                                                  &lt;A HREF=&quot;https://dns.aizhan.com/&quot; ADD_DATE=&quot;1678696134&quot;&gt;IP反查域名&lt;/A&gt;
                                              &lt;DT&gt;
                                                  &lt;A HREF=&quot;http://www.hackdig.com/?09/hack-13542.htm&quot; ADD_DATE=&quot;1678696134&quot;&gt;常用的渗透测试工具型网站整合【分享】_黑客技术&lt;/A&gt;
                                              &lt;DT&gt;
                                                  &lt;A HREF=&quot;https://who.is/&quot; ADD_DATE=&quot;1678696134&quot;&gt;WHOIS（ip 域名）&lt;/A&gt;
                                              &lt;DT&gt;
                                                  &lt;A HREF=&quot;https://booter.xyz/&quot; ADD_DATE=&quot;1678696134&quot;&gt;XyZ Booter/Stresser - TOP 1 IP Stresser&lt;/A&gt;
                                              &lt;DT&gt;
                                                  &lt;A HREF=&quot;https://thief.one/2017/05/19/1/&quot; ADD_DATE=&quot;1678696134&quot;&gt;【渗透神器系列】搜索引擎 | nMask &amp;#39;s Blog&lt;/A&gt;
                                              &lt;DT&gt;
                                                  &lt;A HREF=&quot;https://www.seebug.org/&quot; ADD_DATE=&quot;1678696134&quot;&gt;知道创宇 Seebug 漏洞平台 - 洞悉漏洞，让你掌握第一手漏洞情报！&lt;/A&gt;
                                              &lt;DT&gt;
                                                  &lt;A HREF=&quot;https://www.cnblogs.com/hackerschina/p/5063649.html&quot; ADD_DATE=&quot;1678696134&quot;&gt;2015.12.21日官方最新公告！中国骇客云安全响应平台正式上线啦！ - 中国寒龙联盟核心管理 - 博客园&lt;/A&gt;
                                      &lt;/DL&gt;
                                      &lt;p&gt;
                                          &lt;DT&gt;
                                              &lt;A HREF=&quot;https://zhuanlan.zhihu.com/p/39277625&quot; ADD_DATE=&quot;1678696134&quot;&gt;人肉搜索的思路分享／信息挖掘与情报收集 - 知乎&lt;/A&gt;
                                          &lt;DT&gt;
                                              &lt;A HREF=&quot;https://blog.csdn.net/huqianxun/article/details/54646497&quot; ADD_DATE=&quot;1678696134&quot;&gt;通过邮箱查询手机号/通过手机号查询邮箱【人肉搜索原理】 - 绫里千寻的栏目 - CSDN博客&lt;/A&gt;
                                          &lt;DT&gt;
                                              &lt;A HREF=&quot;https://blog.csdn.net/zrools/article/details/50678365&quot; ADD_DATE=&quot;1678696134&quot;&gt;手机号查QQ号（Python3版） - zrools的博客 - CSDN博客&lt;/A&gt;
                                          &lt;DT&gt;
                                              &lt;A HREF=&quot;https://www.jianshu.com/p/d73488564356&quot; ADD_DATE=&quot;1678696134&quot;&gt;我是如何通过手机号码得到ta的信息 - 瞬间秒杀 - 简书&lt;/A&gt;
                                          &lt;DT&gt;
                                              &lt;A HREF=&quot;https://www.52pojie.cn/thread-385527-1-1.html&quot; ADD_DATE=&quot;1678696134&quot;&gt;手机号2QQ号 - 『原创发布区』 - 吾爱破解 - LCG - LSG |安卓破解|病毒分析|破解软件|www.52pojie.cn&lt;/A&gt;
                                          &lt;DT&gt;
                                              &lt;A HREF=&quot;https://publicdbhost.dmca.gripe/&quot; ADD_DATE=&quot;1678696134&quot;&gt;Index of /&lt;/A&gt;
                                          &lt;DT&gt;
                                              &lt;A HREF=&quot;https://www.v2ex.com/t/416708&quot; ADD_DATE=&quot;1678696134&quot;&gt;那个查询你注册过哪些网站的网站又起死回生了 - V2EX&lt;/A&gt;
                                          &lt;DT&gt;
                                              &lt;A HREF=&quot;http://site2.sjk.space/dosgk1.php&quot; ADD_DATE=&quot;1678696134&quot;&gt;社工库免费查询&lt;/A&gt;
                                          &lt;DT&gt;
                                              &lt;A HREF=&quot;http://www.anonymouschina.org/?p=762&quot; ADD_DATE=&quot;1678696134&quot;&gt;中国骇客云教你社工之手机信息查询新技能！ – 中国骇客云平台官网&lt;/A&gt;
                                          &lt;DT&gt;
                                              &lt;A HREF=&quot;https://blog.csdn.net/Fly_hps/article/details/79406517&quot; ADD_DATE=&quot;1678696134&quot;&gt;11、信息收集篇————钟馗之眼使用 - Fly_鹏程万里 - CSDN博客&lt;/A&gt;
                                          &lt;DT&gt;
                                              &lt;A HREF=&quot;http://www.anonymouschina.org/&quot; ADD_DATE=&quot;1678696134&quot;&gt;中国骇客云平台官网 – Chinese hackers cloud platform international website&lt;/A&gt;
                                          &lt;DT&gt;
                                              &lt;A HREF=&quot;https://discord.en.softonic.com/windows/alternatives/free&quot; ADD_DATE=&quot;1678696134&quot;&gt;联系方式&lt;/A&gt;
                                          &lt;DT&gt;
                                              &lt;A HREF=&quot;https://www.5566.net/hack-.htm&quot; ADD_DATE=&quot;1678696134&quot;&gt;【黑客_网络安全_论坛】_中国精彩网址『 5566.NET，5566.ORG 』&lt;/A&gt;
                                          &lt;DT&gt;
                                              &lt;A HREF=&quot;https://www.zhihu.com/question/20289531/answer/277240688&quot; ADD_DATE=&quot;1678696134&quot;&gt;怎样防范被人肉搜索？ - 知乎&lt;/A&gt;
                                          &lt;DT&gt;
                                              &lt;A HREF=&quot;https://bbs.ichunqiu.com/thread-29654-1-1.html&quot; ADD_DATE=&quot;1678696134&quot;&gt;常见社工方法以及如何防社工_白帽子技术/思路_i春秋社区-分享你的技术，为安全加点温度.&lt;/A&gt;
                                          &lt;DT&gt;
                                              &lt;A HREF=&quot;http://whois.chinaz.com/reverse?ddlSearchMode=3&quot; ADD_DATE=&quot;1678696134&quot;&gt;域名Whois反查 - 站长之家&lt;/A&gt;
                                          &lt;DT&gt;
                                              &lt;A HREF=&quot;http://byr.wiki/&quot; ADD_DATE=&quot;1678696134&quot;&gt;Byr.wiki·北邮人导航&lt;/A&gt;
                                          &lt;DT&gt;
                                              &lt;A HREF=&quot;http://search.chongbuluo.com/&quot; ADD_DATE=&quot;1678696134&quot;&gt;快搜 - 搜索快人一步 - Google&lt;/A&gt;
                                          &lt;DT&gt;
                                              &lt;A HREF=&quot;http://www.chongbuluo.com/forum.php&quot; ADD_DATE=&quot;1678696134&quot;&gt;虫部落社区 — 在这里发现更大的世界！&lt;/A&gt;
                                          &lt;DT&gt;
                                              &lt;A HREF=&quot;https://www.qichacha.com/&quot; ADD_DATE=&quot;1678696134&quot;&gt;企查查-工商信息查询-公司企业注册信息查询-全国企业信用信息公示系统&lt;/A&gt;
                                          &lt;DT&gt;
                                              &lt;A HREF=&quot;https://www.linkedin.com/?trk=brandpage_baidu_pc-mainlink&quot; ADD_DATE=&quot;1678696134&quot;&gt;LinkedIn：登入或註冊&lt;/A&gt;
                                          &lt;DT&gt;
                                              &lt;A HREF=&quot;https://unroll.me/&quot; ADD_DATE=&quot;1678696134&quot;&gt;Unsubscribe from emails, instantly - Unroll.Me&lt;/A&gt;
                                          &lt;DT&gt;
                                              &lt;A HREF=&quot;https://haoma.baidu.com/query&quot; ADD_DATE=&quot;1678696134&quot;&gt;百度号码认证平台-号码查询&lt;/A&gt;
                                          &lt;DT&gt;
                                              &lt;A HREF=&quot;http://www.cellmap.cn/&quot; ADD_DATE=&quot;1678696134&quot;&gt;cellmap|基站查询|基站定位&lt;/A&gt;
                                          &lt;DT&gt;
                                              &lt;A HREF=&quot;http://www.gpsspg.com/bs.htm&quot; ADD_DATE=&quot;1678696134&quot;&gt;基站定位查询 — 移动基站联通基站电信基站 LBS —GPSspg&lt;/A&gt;
                                          &lt;DT&gt;
                                              &lt;A HREF=&quot;http://www.sohu.com/a/237452060_704736&quot; ADD_DATE=&quot;1678696134&quot;&gt;推荐几个手机基站位置查询的公开平台&lt;/A&gt;
                                          &lt;DT&gt;
                                              &lt;A HREF=&quot;http://www.cnblogs.com/cellmap/p/3669944.html&quot; ADD_DATE=&quot;1678696134&quot;&gt;Cellmap 基站查询 For Pc - cellmap - 博客园&lt;/A&gt;
                                          &lt;DT&gt;
                                              &lt;A HREF=&quot;http://www.researchclinic.net/&quot; ADD_DATE=&quot;1678696134&quot;&gt;Research Clinic&lt;/A&gt;
                                          &lt;DT&gt;
                                              &lt;A HREF=&quot;https://www.linkedin.com/&quot; ADD_DATE=&quot;1678696134&quot;&gt;LinkedIn：登入或註冊&lt;/A&gt;
                                          &lt;DT&gt;
                                              &lt;A HREF=&quot;http://s.xysjk.com/detail.aspx?sel=1&amp;keyword=17585468883&quot; ADD_DATE=&quot;1678696134&quot;&gt;信用数据库&lt;/A&gt;
                                          &lt;DT&gt;
                                              &lt;A HREF=&quot;http://s.xysjk.com/search.aspx&quot; ADD_DATE=&quot;1678696134&quot;&gt;信用数据库(www.xysjk.com) - 评论列表&lt;/A&gt;
                                          &lt;DT&gt;
                                              &lt;A HREF=&quot;https://cn.gijn.org/2015/10/15/bbc%E6%90%9C%E7%B4%A2%E4%B8%93%E5%AE%B6%EF%BC%9A%E5%8D%81%E6%AC%BE%E5%BC%BA%E5%8A%9B%E4%BA%BA%E8%82%89%E6%90%9C%E7%B4%A2%E5%B7%A5%E5%85%B7/&quot; ADD_DATE=&quot;1678696134&quot;&gt;BBC搜索专家：十款强力“人肉”搜索工具 | 全球深度报道网&lt;/A&gt;
                                          &lt;DT&gt;
                                              &lt;A HREF=&quot;https://blog.csdn.net/lzhd24/article/details/50667572&quot; ADD_DATE=&quot;1678696134&quot;&gt;Setoolkit社会工程学工具包 - 飞沙风中转 - CSDN博客&lt;/A&gt;
</code></pre>
</li>
</ul>
]]></content>
      <categories>
        <category>code</category>
        <category>note</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>Python大数据分析（企业竞赛项目）</title>
    <url>/2023/03/11/Python/P1-Python%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%EF%BC%88%E4%BC%81%E4%B8%9A%E7%AB%9E%E8%B5%9B%E9%A1%B9%E7%9B%AE%EF%BC%89/</url>
    <content><![CDATA[<p><a href="https://xcyyyy19.github.io/pic/P1/unicom.zip">银联数据分析代码下载链接（含原脱敏数据及交叉数据）</a><br><a href="https://xcyyyy19.github.io/pic/P1/unipay.zip">联通数据分析代码下载链接（含原脱敏数据及交叉数据）</a></p>
<p>【【【【【【【【【【【【【该完善这里了！！！！！！】】】】】】】】】】】】】</p>
<p>1.代码设计想法展现，数据切入点展现</p>
<p>2.获奖证书及答辩现场</p>
]]></content>
      <categories>
        <category>code</category>
        <category>project</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>网站完善与专业学习ToDoList</title>
    <url>/2023/03/08/%E8%AF%B4%E6%98%8E%E6%96%87%E6%A1%A3/Z1-hello-world/</url>
    <content><![CDATA[<h2 id="网页完善计划"><a href="#网页完善计划" class="headerlink" title="网页完善计划"></a>网页完善计划</h2><ul>
<li><input checked="" disabled="" type="checkbox"> 初步搞清楚hexo框架文件体系</li>
<li><input checked="" disabled="" type="checkbox"> 学markdown</li>
<li><input checked="" disabled="" type="checkbox"> 看看hexo框架和自己写的项目有什么区别</li>
<li><input checked="" disabled="" type="checkbox"> 试错，随便上传点东西</li>
<li><input checked="" disabled="" type="checkbox"> 新电脑里想上传的的文件，全部搞成markdown格式，并进行精修</li>
<li><input checked="" disabled="" type="checkbox"> 上传、调试</li>
<li><input checked="" disabled="" type="checkbox"> 写个专门用来做计划的md</li>
<li><input checked="" disabled="" type="checkbox"> 把确定要发布的所有文章进行分类和贴标签</li>
<li><input disabled="" type="checkbox"> 把“我是谁，我在干什么”搞好【非常重要！！！！】</li>
<li><input disabled="" type="checkbox"> 把“关于我”做成网站说明书</li>
<li><input checked="" disabled="" type="checkbox"> 搞清楚最近的上传幽灵事件，是浏览器缓存问题还是github部署延迟问题</li>
<li><input checked="" disabled="" type="checkbox"> 为什么hexo s本地结束后，网站部署才能更新？幽灵事件就是因为这个？翻翻逻辑</li>
<li><input checked="" disabled="" type="checkbox"> 看看图片是hexo内嵌上传好，还是单独列个文件夹直接部署然后导入好</li>
<li><input checked="" disabled="" type="checkbox"> 深入搞清楚hexo框架文件体系，花一个点专门看整个代码构架，找找想自定义的其它地方都有啥<ul>
<li><input checked="" disabled="" type="checkbox"> 侧边栏相关的几个文件</li>
<li><input checked="" disabled="" type="checkbox"> 告示板</li>
<li><input checked="" disabled="" type="checkbox"> 侧边栏更改</li>
<li><input checked="" disabled="" type="checkbox"> 底下的浙江改成自己家这边</li>
<li><input checked="" disabled="" type="checkbox"> 有空的话弄一个置顶栏</li>
</ul>
</li>
<li><input checked="" disabled="" type="checkbox"> 看看代码是上传到hexo内嵌里好，还是直接上传部署好，还是搞个预览再加个下载链接好。</li>
<li><input disabled="" type="checkbox"> 看看markdown图片怎么排版，和vue一样能调吗？</li>
</ul>
<h2 id="代码翻出来"><a href="#代码翻出来" class="headerlink" title="代码翻出来"></a>代码翻出来</h2><ul>
<li><input checked="" disabled="" type="checkbox"> 高级网页设计（HtmlCssVue）</li>
<li><input checked="" disabled="" type="checkbox"> 数据库（Mysql）</li>
<li><input checked="" disabled="" type="checkbox"> 大一竞赛代码（- [ ] 待上传）</li>
<li><input checked="" disabled="" type="checkbox"> 把大一竞赛代码的目录结构优化一下</li>
<li><input checked="" disabled="" type="checkbox"> 大二竞赛代码（- [ ] 待上传）</li>
<li><input checked="" disabled="" type="checkbox"> 把大二竞赛代码的目录结构优化一下</li>
<li><input disabled="" type="checkbox"> JavaWeb（翻翻主力机，把便携机的环境配好）</li>
<li><input disabled="" type="checkbox"> 毕设</li>
</ul>
<h2 id="读读代码，看看它还认不认主了，一群逆子"><a href="#读读代码，看看它还认不认主了，一群逆子" class="headerlink" title="读读代码，看看它还认不认主了，一群逆子"></a>读读代码，看看它还认不认主了，一群逆子</h2><ul>
<li><input checked="" disabled="" type="checkbox"> 数据分析代码</li>
<li><input checked="" disabled="" type="checkbox"> 高级网页设计</li>
<li><input disabled="" type="checkbox"> 数据库</li>
<li><input disabled="" type="checkbox"> JavaWeb</li>
<li><input disabled="" type="checkbox"> 毕设</li>
</ul>
<h2 id="便携用电脑环境配置"><a href="#便携用电脑环境配置" class="headerlink" title="便携用电脑环境配置"></a>便携用电脑环境配置</h2><ul>
<li><input checked="" disabled="" type="checkbox"> annaconda系列</li>
<li><input checked="" disabled="" type="checkbox"> JetBrains系列</li>
<li><input checked="" disabled="" type="checkbox"> 找找JetBrains破解激活</li>
<li><input disabled="" type="checkbox"> Vscode</li>
<li><input disabled="" type="checkbox"> 看看主力机Vscode自定义的两个配置是哪个更好使来着？</li>
</ul>
]]></content>
      <categories>
        <category>必看！我是谁，我在干什么</category>
      </categories>
      <tags>
        <tag>profile</tag>
      </tags>
  </entry>
  <entry>
    <title>Python网站--废品回收（数据库结业项目）</title>
    <url>/2023/03/15/Python/P5-Python%E7%BD%91%E7%AB%99--%E5%BA%9F%E5%93%81%E5%9B%9E%E6%94%B6%EF%BC%88%E6%95%B0%E6%8D%AE%E5%BA%93%E7%BB%93%E4%B8%9A%E9%A1%B9%E7%9B%AE%EF%BC%89/</url>
    <content><![CDATA[<h2 id="基于Django的废品回收网站设计与实现（附件见文末）"><a href="#基于Django的废品回收网站设计与实现（附件见文末）" class="headerlink" title="基于Django的废品回收网站设计与实现（附件见文末）"></a>基于Django的废品回收网站设计与实现（附件见文末）</h2><h2 id="系统原型"><a href="#系统原型" class="headerlink" title="系统原型"></a>系统原型</h2><p>进入系统登录页面，在该部分向<img src="/../pic/media-fp/0a11328ae013230e51ec2122e8c73146.jpeg" alt="登录页面">用户提供登录、注册功能。</p>
<p>图 4.3 登录原型图</p>
<p>用户进入用户主页后，可以看到自己的昵称，以及侧边栏的功能选项，点击个人中心按钮进入个人中心页面填写个人信息，用户个人中心页原型图如图 4.4 所示。</p>
<p><img src="/../pic/media-fp/41231ccab047ccc8732e1e56347d8482.png" alt="用户个人中心"></p>
<p>图 4.4 用户个人中心页原型图</p>
<p>当用户进入首页点击废品回收按钮进行废品回收下单、提交订单、查看订单，用户</p>
<p>废品回收下单页原型图如图 4.5 所示。</p>
<p><img src="/../pic/media-fp/7498b440d234dfb821ddb787290a14e5.png" alt="用户废品回收下单"></p>
<p>图 4.5 用户废品回收下单页原型图</p>
<p>当商户进入首页可以看到自己的昵称、侧边栏的功能选项、订单列表，点击个人中心按钮进入个人中心页面填写个人信息，商户进行接单并价格评估、提交后跳转到我的订单页面、查看物流信息，商户接单并价格评估页原型图如图 4.6 所示。</p>
<p><img src="/../pic/media-fp/140bd019df0d9c9a446c30cedb55637b.png" alt="1650091871(1)"></p>
<p>图 4.6 商户接单页原型图</p>
<p>当取货员进入首页可以看到自己的昵称、侧边栏的功能选项、订单列表，点击个人中心按钮进入个人中心页面填写个人信息，取货员进行接单并在我的订单进行取送更新、查看物流信息，取货员在我的订单页进行取送更新原型图如图 4.7 所示。</p>
<p><img src="/../pic/media-fp/a1da75dc091b0ea5d2f40c0d23b103ee.jpeg" alt="1650092841(1)"></p>
<p>图 4.7 取货员更新取货信息原型图</p>
<p>商户对取货员返回的回收单进行确认并支付，商户支付原型图如图 4.8 所示。</p>
<p><img src="/../pic/media-fp/a4249b2ca3270865d7d1ecaf26399ede.jpeg" alt="1650093591(1)"></p>
<p>图 4.8 商户支付页原型图</p>
<p>用户对商户及取货员评价原型图如图 4.9 所示，取货员在我的评价页查看评价如图</p>
<p>4.10 所示。</p>
<p><img src="/../pic/media-fp/84105aeafa7c5bf079182f776d9ce0c2.png" alt="1650093839(1)"></p>
<p>图 4.9 用户评价页原型图</p>
<p><img src="/../pic/media-fp/8e86672c1fd2c26db40a57bbce1b3a68.jpeg" alt="1650094008(1)"></p>
<p>图 4.10 取货员查看评价页原型图</p>
<h2 id="系统结构设计"><a href="#系统结构设计" class="headerlink" title="系统结构设计"></a>系统结构设计</h2><p><strong>第 4 章 系统设计</strong></p>
<p>系统分为 4 个角色，前端为用户、商户、取货员，后端管理员负责对信息与用户身份的审核、账户管理、订单信息管理、回收物品种类管理等功能。系统功能结构图如图</p>
<ol>
<li>所示。</li>
</ol>
<p><img src="/../pic/media-fp/864dad1dd7c74064545295cbd6797623.jpeg" alt="1650098816(1)"></p>
<p>图 4.1 体系功能结构图</p>
<h2 id="数据库设计"><a href="#数据库设计" class="headerlink" title="数据库设计"></a>数据库设计</h2><h3 id="E-R-图"><a href="#E-R-图" class="headerlink" title="E-R 图"></a>E-R 图</h3><p>数据库设计的 E-R 图如图 4.2 所示。</p>
<p><img src="/../pic/media-fp/7c5162deeb0293f04285f66386a091af.jpeg" alt="废品回收E-R图"></p>
<p>图 4.2 系统 E-R 图</p>
<h3 id="表结构设计"><a href="#表结构设计" class="headerlink" title="表结构设计"></a>表结构设计</h3><p>用户登录需要账户密码，下单时需要填写姓名、联系电话及地址便于商户与取货员查看订单信息取货回收，注册时需要有 id 账号方便管理员管理。用户信息表结构如表</p>
<p>4.1 所示。</p>
<p>表 4.1 用户表</p>
<table>
<thead>
<tr>
<th><strong>字段名</strong></th>
<th><strong>名称</strong></th>
<th><strong>数据类型</strong></th>
<th><strong>约束</strong></th>
</tr>
</thead>
<tbody><tr>
<td>id</td>
<td>用户 id</td>
<td>int(11)</td>
<td>PK， AUTO_INCREMENT ,not null</td>
</tr>
<tr>
<td>username</td>
<td>账户</td>
<td>varchar(32)</td>
<td>not null</td>
</tr>
<tr>
<td>password</td>
<td>密码</td>
<td>varchar(32)</td>
<td>not null</td>
</tr>
<tr>
<td>name</td>
<td>姓名</td>
<td>varchar(20)</td>
<td></td>
</tr>
<tr>
<td>phone</td>
<td>电话</td>
<td>varchar(11)</td>
<td></td>
</tr>
<tr>
<td>addr</td>
<td>地址</td>
<td>varchar(256)</td>
<td></td>
</tr>
</tbody></table>
<p>商户登录需要账户密码，接单时需要填写姓名、联系电话及地址便于取货员查看信息送货，注册时需要有 id 账号方便管理员管理。商户表结构如表 4.2 所示。</p>
<p>表 4.2 商户表</p>
<table>
<thead>
<tr>
<th><strong>字段名</strong></th>
<th><strong>名称</strong></th>
<th><strong>数据类型</strong></th>
<th><strong>约束</strong></th>
</tr>
</thead>
<tbody><tr>
<td>id</td>
<td>用户 id</td>
<td>int(11)</td>
<td>PK， AUTO_INCREMENT ，not null</td>
</tr>
<tr>
<td>username</td>
<td>账户</td>
<td>varchar(32)</td>
<td>not null</td>
</tr>
<tr>
<td>password</td>
<td>密码</td>
<td>varchar(32)</td>
<td>not null</td>
</tr>
<tr>
<td>name</td>
<td>姓名</td>
<td>varchar(20)</td>
<td></td>
</tr>
<tr>
<td>phone</td>
<td>电话</td>
<td>varchar(11)</td>
<td></td>
</tr>
<tr>
<td>addr</td>
<td>地址</td>
<td>varchar(256)</td>
<td></td>
</tr>
</tbody></table>
<p>取货员登录需要账户密码，接单时需要填写姓名、联系电话便于用户及商户查看信配送信息，有问题便于联系，注册时需要有 id 账号方便管理员管理。取货员表结构如表</p>
<p>4.3 所示。</p>
<p>表 4.3 取货员表</p>
<table>
<thead>
<tr>
<th><strong>字段名</strong></th>
<th><strong>名称</strong></th>
<th><strong>数据类型</strong></th>
<th><strong>约束</strong></th>
</tr>
</thead>
<tbody><tr>
<td>id</td>
<td>用户 id</td>
<td>int(11)</td>
<td>PK， AUTO_INCREMENT ，not null</td>
</tr>
<tr>
<td>username</td>
<td>账户</td>
<td>varchar(32)</td>
<td>not null</td>
</tr>
<tr>
<td>password</td>
<td>密码</td>
<td>varchar(32)</td>
<td>not null</td>
</tr>
<tr>
<td>name</td>
<td>姓名</td>
<td>varchar(20)</td>
<td></td>
</tr>
<tr>
<td>phone</td>
<td>电话</td>
<td>varchar(11)</td>
<td></td>
</tr>
</tbody></table>
<p>废品类别便于用户选择，编号 id 便于管理员管理。废品类别表结构如表 4.4 所示。</p>
<p>表 4.4 废品类别表</p>
<table>
<thead>
<tr>
<th><strong>字段名</strong></th>
<th><strong>名称</strong></th>
<th><strong>数据类型</strong></th>
<th><strong>约束</strong></th>
</tr>
</thead>
<tbody><tr>
<td>id</td>
<td>废品种类 id</td>
<td>int(11)</td>
<td>PK， AUTO_INCREMENT ，not null</td>
</tr>
<tr>
<td>name</td>
<td>类别名称</td>
<td>varchar(20)</td>
<td>not null</td>
</tr>
</tbody></table>
<p>订单信息会被记录，当用户、商户、取货员对订单存在疑惑时需要查看订单信息， 便于处理。订单信息表结构如表 4.5 所示。</p>
<p>表 4.5 订单信息表</p>
<table>
<thead>
<tr>
<th><strong>字段名</strong></th>
<th><strong>名称</strong></th>
<th><strong>数据类型</strong></th>
<th><strong>约束</strong></th>
</tr>
</thead>
<tbody><tr>
<td>id</td>
<td>订单 id</td>
<td>varchar(20)</td>
<td>PK， AUTO_INCREMENT ，not null</td>
</tr>
<tr>
<td>name</td>
<td>用户名</td>
<td>varchar(20)</td>
<td>not null</td>
</tr>
<tr>
<td>phone</td>
<td>电话</td>
<td>varchar(11)</td>
<td>not null</td>
</tr>
<tr>
<td>addr</td>
<td>地址</td>
<td>varchar(256)</td>
<td>not null</td>
</tr>
<tr>
<td>date</td>
<td>下单日期</td>
<td>date(0)</td>
<td>not null</td>
</tr>
<tr>
<td>time</td>
<td>取货时间</td>
<td>time(6)</td>
<td>not null</td>
</tr>
<tr>
<td>type_id</td>
<td>废品类别 id</td>
<td>int(11)</td>
<td>not null</td>
</tr>
<tr>
<td>create</td>
<td>订单创建时间</td>
<td>datetime(6)</td>
<td>not null</td>
</tr>
<tr>
<td>detail</td>
<td>备注</td>
<td>varchar(500)</td>
<td></td>
</tr>
<tr>
<td>price</td>
<td>价格</td>
<td>decimal(6)</td>
<td>not null</td>
</tr>
<tr>
<td>comment_d</td>
<td>对商户评价</td>
<td>varchar(500)</td>
<td></td>
</tr>
<tr>
<td>comment_b</td>
<td>对取货员评价</td>
<td>varchar(500)</td>
<td></td>
</tr>
<tr>
<td>status</td>
<td>状态</td>
<td>varchar(11)</td>
<td>not null</td>
</tr>
<tr>
<td>user_id</td>
<td>用户 id</td>
<td>int(11)</td>
<td>not null</td>
</tr>
</tbody></table>
<p>管理员注册时有 id 编号，管理员登录需要账户、密码。管理员表结构如表 4.6 所示。</p>
<p>表 4.6 管理员表</p>
<table>
<thead>
<tr>
<th><strong>字段名</strong></th>
<th><strong>名称</strong></th>
<th><strong>数据类型</strong></th>
<th><strong>约束</strong></th>
</tr>
</thead>
<tbody><tr>
<td>id</td>
<td>管理员 id</td>
<td>int(11)</td>
<td>PK， AUTO_INCREMENT ，not null</td>
</tr>
<tr>
<td>username</td>
<td>账户</td>
<td>varchar(32)</td>
<td>not null</td>
</tr>
<tr>
<td>password</td>
<td>密码</td>
<td>varchar(32)</td>
<td>not null</td>
</tr>
</tbody></table>
<p>物流信息由商户、取货员操作更新，直接显示当前订单状态、创建日期、订单编号。</p>
<p>物流信息表结构如表 4.7 所示。</p>
<p>表 4.7 物流信息表</p>
<table>
<thead>
<tr>
<th><strong>字段名</strong></th>
<th><strong>名称</strong></th>
<th><strong>数据类型</strong></th>
<th><strong>约束</strong></th>
</tr>
</thead>
<tbody><tr>
<td>id</td>
<td>id</td>
<td>int(11)</td>
<td>PK， AUTO_INCREMENT ，not null</td>
</tr>
<tr>
<td>name</td>
<td>物流状态</td>
<td>varchar(50)</td>
<td>not null</td>
</tr>
<tr>
<td>create</td>
<td>创建日期</td>
<td>varchar(6)</td>
<td>not null</td>
</tr>
<tr>
<td>order_id</td>
<td>订单编号</td>
<td>varchar(20)</td>
<td>not null</td>
</tr>
</tbody></table>
<p>管理员可对用户、商户、取货员账户及订单进行增加、删除、修改、查看功能。管理员操作记录表结构如表 4.8 所示。</p>
<p>表 4.8 管理员操作记录表</p>
<table>
<thead>
<tr>
<th><strong>字段名</strong></th>
<th><strong>名称</strong></th>
<th><strong>数据类型</strong></th>
<th><strong>约束</strong></th>
</tr>
</thead>
<tbody><tr>
<td>id</td>
<td>id</td>
<td>int(11)</td>
<td>PK， AUTO_INCREMENT</td>
</tr>
<tr>
<td>action_time</td>
<td>开始时间</td>
<td>datetime(6)</td>
<td>not null</td>
</tr>
<tr>
<td>object_id</td>
<td>目标 id</td>
<td>longtext</td>
<td></td>
</tr>
<tr>
<td>object_repr</td>
<td>更改结果</td>
<td>varchar(200)</td>
<td>not null</td>
</tr>
<tr>
<td>action_flag</td>
<td>开始标记</td>
<td>smallint(5)</td>
<td>not null</td>
</tr>
<tr>
<td>change_message</td>
<td>更改信息</td>
<td>longtext</td>
<td>not null</td>
</tr>
<tr>
<td>content_type_id</td>
<td>满足类型 id</td>
<td>int(11)</td>
<td></td>
</tr>
<tr>
<td>user_id</td>
<td>用户 id</td>
<td>int(11)</td>
<td>not null</td>
</tr>
</tbody></table>
<h3 id="后台功能模块设计"><a href="#后台功能模块设计" class="headerlink" title="后台功能模块设计"></a>后台功能模块设计</h3><p><img src="/../pic/media-fp/2431961e9d108c0b210377502065bc5a.png" alt=" ">管理员功能设计实现增删改查用户、商户、取货员、订单信息、回收废品分类功能， 认证和授权功能。管理员功能类图如图 4.3 所示。</p>
<p>图 4.3 废品回收后台管理系统类图</p>
<p>设计顺序图，管理员修改功能的顺序图如图 4.4 所示。</p>
<p><img src="/../pic/media-fp/fc74638232853c65d510c7cb298c865a.png" alt=" "></p>
<p>图 4.4 修改订单功能顺序图</p>
<h2 id="前台功能模块设计"><a href="#前台功能模块设计" class="headerlink" title="前台功能模块设计"></a>前台功能模块设计</h2><p>前台功能设计实现用户用户下单、查看订单状态，商户接单、评估价格并支付确认、查看物流信息、订单信息、用户评价，取货员接单、取货、送货、更新物流信息、查看用户评价等功能。前台功能类图如图 4.5 所示。</p>
<p><img src="/../pic/media-fp/31b594a824aca47dc78a33e2950bf5de.png" alt=" "></p>
<p>图 4.5 前端功能系统类图</p>
<p>设计顺序图，用户下单功能的顺序图如图 4.6 所示。</p>
<p><img src="/../pic/media-fp/39eaecc93f36d50a1449ed4e60d34a1d.png" alt=" "></p>
<p>图 4.6 用户下单功能顺序图</p>
<p>设计顺序图，商户接单功能的顺序图如图 4.7 所示。</p>
<p><img src="/../pic/media-fp/97a9c7bc9f5c0d50ea59ff01d20daf3e.png" alt=" "></p>
<p>图 4.7 商户接单功能顺序图</p>
<p>设计顺序图，取货员接单取货功能的顺序图如图 4.8 所示。</p>
<p><img src="/../pic/media-fp/f7bfe83dea82121aba4e524a9fbf4432.png" alt=" "></p>
<p>图 4.8 取货员接单取货功能顺序图</p>
<h2 id="JSON-接口设计"><a href="#JSON-接口设计" class="headerlink" title="JSON 接口设计"></a>JSON 接口设计</h2><p>用户注册接口，用于用户的注册账户请求，具体如表 4.9 所示。</p>
<p>表 4.9 用户注册接口</p>
<table>
<thead>
<tr>
<th><strong>URL 地址</strong></th>
<th><a href="http://127.0.0.1:8000/user/register/">http://127.0.0.1:8000/user/register/</a></th>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td><strong>请求参数列表</strong></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td><strong>参数名称</strong></td>
<td><strong>是否必须</strong></td>
<td><strong>类型</strong></td>
<td><strong>描述</strong></td>
</tr>
<tr>
<td>username</td>
<td>是</td>
<td>String</td>
<td>用户名</td>
</tr>
<tr>
<td>password</td>
<td>是</td>
<td>String</td>
<td>用户设置密码</td>
</tr>
<tr>
<td>cpassword</td>
<td>是</td>
<td>String</td>
<td>确认密码</td>
</tr>
<tr>
<td><strong>请求类型</strong></td>
<td>POST</td>
<td></td>
<td></td>
</tr>
<tr>
<td><strong>返回参数类型</strong></td>
<td>JSON</td>
<td></td>
<td></td>
</tr>
<tr>
<td><strong>返回参数列表</strong></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td><strong>参数名称</strong></td>
<td><strong>描述</strong></td>
<td></td>
<td></td>
</tr>
<tr>
<td>code</td>
<td>数据状态码（成功状态码是 200）</td>
<td></td>
<td></td>
</tr>
<tr>
<td>message</td>
<td>返回消息</td>
<td></td>
<td></td>
</tr>
</tbody></table>
<p>添加订单接口设计，该接口用于废品回收用户下单。添加订单接口设计如表 4.10</p>
<p>所示。</p>
<p>表 4.10 用户下单接口</p>
<table>
<thead>
<tr>
<th><strong>URL 地址</strong></th>
<th><a href="http://127.0.0.1:8000/user/order/insert/">http://127.0.0.1:8000/user/order/insert/</a></th>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td><strong>参数列表</strong></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td><strong>参数名称</strong></td>
<td><strong>是否必须</strong></td>
<td><strong>类型</strong></td>
<td><strong>描述</strong></td>
</tr>
<tr>
<td>name</td>
<td>是</td>
<td>String</td>
<td>寄件人</td>
</tr>
<tr>
<td>phone</td>
<td>是</td>
<td>String</td>
<td>联系电话</td>
</tr>
</tbody></table>
<p>续表 4.10 用户下单接口</p>
<table>
<thead>
<tr>
<th>addr</th>
<th>是</th>
<th>String</th>
<th>取件地址</th>
</tr>
</thead>
<tbody><tr>
<td>date</td>
<td>是</td>
<td>String</td>
<td>取件日期</td>
</tr>
<tr>
<td>time</td>
<td>是</td>
<td>String</td>
<td>取件时间</td>
</tr>
<tr>
<td>create</td>
<td>是</td>
<td>String</td>
<td>创建日期</td>
</tr>
<tr>
<td>heavy</td>
<td>是</td>
<td>String</td>
<td>废品重量</td>
</tr>
<tr>
<td>type_id</td>
<td>是</td>
<td>String</td>
<td>废品种类</td>
</tr>
<tr>
<td>datail</td>
<td>是</td>
<td>String</td>
<td>用户备注</td>
</tr>
<tr>
<td><strong>请求类型</strong></td>
<td>POST</td>
<td></td>
<td></td>
</tr>
<tr>
<td><strong>返回参数类型</strong></td>
<td>JSON</td>
<td></td>
<td></td>
</tr>
<tr>
<td><strong>返回参数列表</strong></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td><strong>参数名称</strong></td>
<td><strong>描述</strong></td>
<td></td>
<td></td>
</tr>
<tr>
<td>code</td>
<td>数据状态码（成功状态码是 200）</td>
<td></td>
<td></td>
</tr>
<tr>
<td>message</td>
<td>返回消息</td>
<td></td>
<td></td>
</tr>
</tbody></table>
<h1 id="系统实现"><a href="#系统实现" class="headerlink" title="系统实现"></a>系统实现</h1><h2 id="后台功能模块实现"><a href="#后台功能模块实现" class="headerlink" title="后台功能模块实现"></a>后台功能模块实现</h2><p>管理员登入后台管理系统，对用户、商户、取货员、可选废品种类进行增、删、改、查，管理员可认证授权，查看用户评价、商户接单状态、取货员物流更新等功能。</p>
<h3 id="用户账户管理功能模块实现"><a href="#用户账户管理功能模块实现" class="headerlink" title="用户账户管理功能模块实现"></a>用户账户管理功能模块实现</h3><p>管理员登入后台管理系统，对用户账户进行增加，删除，修改和查询功能，用户账户管理页面如图 5.1 所示。</p>
<p><img src="/../pic/media-fp/74979e80b7462770ae509b7ed83eb2fb.jpeg" alt=" "></p>
<p>图 5.1 用户账户管理页面 1</p>
<p>其中相关代码如下所示：</p>
<h3 id="用户订单管理功能模块实现"><a href="#用户订单管理功能模块实现" class="headerlink" title="用户订单管理功能模块实现"></a>用户订单管理功能模块实现</h3><p>管理员登入后台管理系统，对用户订单进行增加，删除，修改和查询功能，用户订单管理页面如图 5.2 所示。</p>
<p><img src="/../pic/media-fp/344bb40423d7d3ac19237bdf18776fa7.jpeg" alt=" "></p>
<p>图 5.2 用户订单管理页面</p>
<p>其中相关代码如下所示：</p>
<h2 id="前台功能模块实现"><a href="#前台功能模块实现" class="headerlink" title="前台功能模块实现"></a>前台功能模块实现</h2><h3 id="用户下单功能模块实现"><a href="#用户下单功能模块实现" class="headerlink" title="用户下单功能模块实现"></a>用户下单功能模块实现</h3><p>用户登入后，可选择回收废品种类、填写重量进行废品回收下单，查看订单状态、进行评价等功能，用户下单页面如图 5.3 所示。</p>
<p><img src="/../pic/media-fp/00e67545776dea2bba11b85729c515dc.png" alt=" "></p>
<p>图 5.3 用户下单页面</p>
<p>其中相关代码如下所示：</p>
<p>def order_insert(request):</p>
<h3 id="商户接单功能模块实现"><a href="#商户接单功能模块实现" class="headerlink" title="商户接单功能模块实现"></a>商户接单功能模块实现</h3><p>商户登入后，进行接单并根据废品种类和重量对其价格评估，对取货员反馈的订单信息确认且支付订单，查看订单状态、查看用户评价等功能，商户接单页面如图 5.4 所示。</p>
<p><img src="/../pic/media-fp/d8625e28bcb9c953b6e91c97c4baae12.png" alt="1650430668(1)"></p>
<p>图 5.4 商户接单页面</p>
<p>其中相关代码如下所示：</p>
<h3 id="用户查看订单信息并评价功能模块实现"><a href="#用户查看订单信息并评价功能模块实现" class="headerlink" title="用户查看订单信息并评价功能模块实现"></a>用户查看订单信息并评价功能模块实现</h3><p>用户登入后，查看订单信息、物流及进行评价功能，用户查看订单信息并评价页面如图 5.5 所示。</p>
<p><img src="/../pic/media-fp/3c0d8723422b8a36c0d43c25d9194ae1.png" alt=" "></p>
<p>图 5.5 用户查看订单信息并评价页面</p>
<h2 id="附件"><a href="#附件" class="headerlink" title="附件"></a>附件</h2><p><a href="https://xcyyyy19.github.io/code/P5-fp/%E7%A8%8B%E5%BA%8F%E4%BB%A3%E7%A0%81/program.zip">代码下载链接</a><br><a href="https://xcyyyy19.github.io/code/P5-fp/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%96%87%E4%BB%B6/fp.sql">数据库下载链接</a></p>
]]></content>
      <categories>
        <category>code</category>
        <category>project</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>Vue</tag>
        <tag>Django</tag>
      </tags>
  </entry>
  <entry>
    <title>快速了解我在大学期间学了什么</title>
    <url>/2023/03/10/%E8%AF%B4%E6%98%8E%E6%96%87%E6%A1%A3/Z2-%E5%BF%AB%E9%80%9F%E4%BA%86%E8%A7%A3%E6%88%91%E5%9C%A8%E5%A4%A7%E5%AD%A6%E6%9C%9F%E9%97%B4%E5%AD%A6%E4%BA%86%E4%BB%80%E4%B9%88/</url>
    <content><![CDATA[<h1 id="获奖证书"><a href="#获奖证书" class="headerlink" title="获奖证书"></a>获奖证书</h1><p><a href="https://xcyyyy19.github.io/pic/Z2/%E5%9B%BD%E5%AE%B6%E7%BA%A7%EF%BC%9AACM.jpg">国家级：ACM</a><br><img src="/..%5Cpic%5CZ2%5C%E5%9B%BD%E5%AE%B6%E7%BA%A7%EF%BC%9AACM.jpg"></p>
<p><a href="https://xcyyyy19.github.io/pic/Z2/%E7%9C%81%E7%BA%A7%EF%BC%9A%E8%93%9D%E6%A1%A51.jpg">省级：蓝桥1</a><br><img src="/..%5Cpic%5CZ2%5C%E7%9C%81%E7%BA%A7%EF%BC%9A%E8%93%9D%E6%A1%A51.jpg"></p>
<p><a href="https://xcyyyy19.github.io/pic/Z2/%E7%9C%81%E7%BA%A7%EF%BC%9A%E8%93%9D%E6%A1%A52.jpg">省级：蓝桥2</a><br><img src="/..%5Cpic%5CZ2%5C%E7%9C%81%E7%BA%A7%EF%BC%9A%E8%93%9D%E6%A1%A52.jpg"></p>
<p><a href="https://xcyyyy19.github.io/pic/Z2/%E7%9C%81%E7%BA%A7%EF%BC%9A%E8%93%9D%E6%A1%A53.jpg">省级：蓝桥3</a><br><img src="/..%5Cpic%5CZ2%5C%E7%9C%81%E7%BA%A7%EF%BC%9A%E8%93%9D%E6%A1%A53.jpg"></p>
<p><a href="https://xcyyyy19.github.io/pic/Z2/%E5%B8%82%E7%BA%A7%EF%BC%9A%E5%A4%A7%E8%BF%9E%E5%B8%82%E5%A4%A7%E6%95%B0%E6%8D%AE%E7%AB%9E%E8%B5%9B.jpg">市级：大连市大数据竞赛</a><br><img src="/..%5Cpic%5CZ2%5C%E5%B8%82%E7%BA%A7%EF%BC%9A%E5%A4%A7%E8%BF%9E%E5%B8%82%E5%A4%A7%E6%95%B0%E6%8D%AE%E7%AB%9E%E8%B5%9B.jpg"></p>
<p><a href="https://xcyyyy19.github.io/pic/Z2/%E6%A0%A1%E5%86%85%EF%BC%9A%E7%AB%9E%E8%B5%9B.jpg">校级：竞赛</a><br><img src="/..%5Cpic%5CZ2%5C%E6%A0%A1%E5%86%85%EF%BC%9A%E7%AB%9E%E8%B5%9B.jpg"></p>
<p>Codevita证书</p>
<p>【【【【【【找邮件附件】】】】】】】】</p>
<p><a href="https://xcyyyy19.github.io/pic/Z2/%E8%8B%B1%E8%AF%AD%EF%BC%9A%E5%9B%9B%E7%BA%A7.jpg">英语：四级证书下载链接</a><br><a href="https://xcyyyy19.github.io/pic/Z2/%E8%8B%B1%E8%AF%AD%EF%BC%9A%E5%85%AD%E7%BA%A7.jpg">英语：六级证书下载链接</a></p>
<h1 id="及部分专业满分成绩证明"><a href="#及部分专业满分成绩证明" class="headerlink" title="及部分专业满分成绩证明"></a>及部分专业满分成绩证明</h1><p><a href="https://xcyyyy19.github.io/pic/Z2/%E5%85%B6%E4%BB%96%EF%BC%9A%E5%A4%A7%E5%AD%A6%E5%88%86%E6%95%B0.jpg">其他：大学部分专业课满分证明</a><br><img src="/..%5Cpic%5CZ2%5C%E5%85%B6%E4%BB%96%EF%BC%9A%E5%A4%A7%E5%AD%A6%E5%88%86%E6%95%B0.jpg"></p>
<h1 id="“我的收藏夹”附件"><a href="#“我的收藏夹”附件" class="headerlink" title="“我的收藏夹”附件"></a>“我的收藏夹”附件</h1><p><a href="https://xcyyyy19.github.io/pic/Z2/%E7%88%AC%E8%99%AB%E4%B8%8E%E6%B2%B3%E8%9F%B9.html">爬虫社工相关内容下载链接</a><br><img src="/..%5Cpic%5CZ2%5C%E7%88%AC%E8%99%AB%E4%B8%8E%E6%B2%B3%E8%9F%B9.jpg"></p>
<p>【【【【【【【【【该完善这里了！！！！！】】】】】】】】】】】</p>
<p><a href="https://xcyyyy19.github.io/pic/Z2/lxhpic.zip">JavaWeb与小程序相关内容下载链接</a></p>
<p>[相关内容下载链接]<br>[相关内容下载链接]<br>[相关内容下载链接]<br>[相关内容下载链接]<br>[相关内容下载链接]<br>[相关内容下载链接]</p>
]]></content>
      <categories>
        <category>必看！我是谁，我在干什么</category>
      </categories>
      <tags>
        <tag>profile</tag>
      </tags>
  </entry>
  <entry>
    <title>Python网站--盘中餐（Vue结业项目）</title>
    <url>/2023/03/14/Python/P4-Python%E7%BD%91%E7%AB%99--%E7%9B%98%E4%B8%AD%E9%A4%90%EF%BC%88Vue%E7%BB%93%E4%B8%9A%E9%A1%B9%E7%9B%AE%EF%BC%89/</url>
    <content><![CDATA[<h2 id="基于Django-的“盘中餐”健康饮食网站的设计与实现（附件见文末）"><a href="#基于Django-的“盘中餐”健康饮食网站的设计与实现（附件见文末）" class="headerlink" title="基于Django 的“盘中餐”健康饮食网站的设计与实现（附件见文末）"></a>基于Django 的“盘中餐”健康饮食网站的设计与实现（附件见文末）</h2><h2 id="系统原型"><a href="#系统原型" class="headerlink" title="系统原型"></a>系统原型</h2><p>用户在想要评论的文章详情页面点击评论，系统弹出添加评论窗口，含有两个按钮， 分别对应评论发表成功和重置评论。用户评论文章原型图如下图所示。</p>
<p><img src="/../pic/media-pzc/67be40de8257f28f7e6bd8bf78c6e5e5.jpeg"></p>
<p>用户评论文章原型图</p>
<p>用户进入后台管理页面，在新增每日打卡详情页输入打卡名称、照片、空盘次数、打卡时间等信息进行每日打卡。用户新增每日打卡原型图如下图所示。</p>
<p><img src="/../pic/media-pzc/e1476e996ddfd3bc7ac1934cf1003d94.jpeg"></p>
<p>用户新增每日打卡原型图</p>
<p>管理员在后台管理的食物信息页面，点击对应食物的详情按钮，查看对应食物信息的详情页。管理员查看食物信息原型图如下图所示。</p>
<p><img src="/../pic/media-pzc/313282be30af592bd821fe765042c477.jpeg"></p>
<p>管理员查看食物信息原型图</p>
<p>管理员在后台管理的榜单页面，在修改榜单的详情，修改榜单信息。管理员修改榜单原型图如下图所示。</p>
<p><img src="/../pic/media-pzc/cb54c343d764453b60e94571a48d192b.jpeg"></p>
<p>管理员修改榜单原型图</p>
<h1 id="系统设计"><a href="#系统设计" class="headerlink" title="系统设计"></a>系统设计</h1><h2 id="体系结构设计"><a href="#体系结构设计" class="headerlink" title="体系结构设计"></a>体系结构设计</h2><p>盘中餐健康饮食网站分为前台、用户后台和管理员后台三个部分。前台主要功能包括用户登录注册、查看食物 、查看新闻资讯、查看每日打卡、文章分享等。用户后台负责用户个人中心管理、每日打卡管理和榜单管理。管理员后台负责用户管理、食物类别管理、食物信息管理、每日打卡管理、系统管理等。系统体系结构图aaaaa。</p>
<p><img src="/../pic/media-pzc/2629b3477b3dc434c069857ded0bbc97.jpeg"></p>
<p>体系结构图</p>
<h2 id="数据库设计"><a href="#数据库设计" class="headerlink" title="数据库设计"></a>数据库设计</h2><ol>
<li><p><strong>E-R</strong> 图</p>
<p>系统的 E-R 图主要核心从用户角色出发，展示包括用户、每日打卡信息、榜单信息、新闻资讯信息、食物类型信息、食物信息和文章分享信息实体间的联系。数据库设计的E-R 图如下图所示。</p>
</li>
</ol>
<p><img src="/../pic/media-pzc/f1919788f4ccac7886104007acca1d91.jpeg"></p>
<h3 id="表结构设计"><a href="#表结构设计" class="headerlink" title="表结构设计"></a>表结构设计</h3><p>数据库 E-R 图</p>
<p>用户表的字段为创建时间、用户名、姓名、头像、密码等。id 为主键。该表存储用户基本信息用于用户注册，登录等。用户表结构如表所示。</p>
<p>表用户表</p>
<table>
<thead>
<tr>
<th>字段名</th>
<th>名称</th>
<th>数据类型</th>
<th>约束</th>
</tr>
</thead>
<tbody><tr>
<td>id</td>
<td>用户 ID</td>
<td>bigint(20)</td>
<td>PK</td>
</tr>
<tr>
<td>addtime</td>
<td>创建时间</td>
<td>timestamp</td>
<td>NOT NULL</td>
</tr>
<tr>
<td>yonghuming</td>
<td>用户名</td>
<td>varchar(200)</td>
<td>NOT NULL</td>
</tr>
<tr>
<td>xingming</td>
<td>姓名</td>
<td>varchar(200)</td>
<td>NOT NULL</td>
</tr>
<tr>
<td>touxiang</td>
<td>头像</td>
<td>varchar(200)</td>
<td>无</td>
</tr>
<tr>
<td>xingbie</td>
<td>性别</td>
<td>varchar(200)</td>
<td>无</td>
</tr>
</tbody></table>
<p>用户表</p>
<table>
<thead>
<tr>
<th>字段名</th>
<th>名称</th>
<th>数据类型</th>
<th>约束</th>
</tr>
</thead>
<tbody><tr>
<td>mima</td>
<td>密码</td>
<td>varchar(200)</td>
<td>NOT NULL</td>
</tr>
<tr>
<td>shouji</td>
<td>手机</td>
<td>varchar(200)</td>
<td>无</td>
</tr>
</tbody></table>
<p>新闻资讯表的字段为标题、简介、图片、内容等，id 为主键。该表存储新闻资讯的相关信息。新闻资讯表结构如表所示。</p>
<p>表新闻资讯表</p>
<table>
<thead>
<tr>
<th>字段名</th>
<th>名称</th>
<th>数据类型</th>
<th>约束</th>
</tr>
</thead>
<tbody><tr>
<td>id</td>
<td>新闻资讯 ID</td>
<td>bigint(20)</td>
<td>PK</td>
</tr>
<tr>
<td>addtime</td>
<td>创建时间</td>
<td>timestamp</td>
<td>NOT NULL</td>
</tr>
<tr>
<td>title</td>
<td>标题</td>
<td>varchar(200)</td>
<td>NOT NULL</td>
</tr>
<tr>
<td>introduction</td>
<td>简介</td>
<td>longtext</td>
<td></td>
</tr>
<tr>
<td>picture</td>
<td>图片</td>
<td>varchar(200)</td>
<td>NOT NULL</td>
</tr>
<tr>
<td>content</td>
<td>内容</td>
<td>longtext</td>
<td>NOT NULL</td>
</tr>
</tbody></table>
<p>每日打卡表的字段为打卡编号、打卡名称、空盘次数、打卡时间等，id 为主键。该表用于存储用户每日打卡的相关信息。每日打卡表结构如表所示。</p>
<p>表每日打卡表</p>
<table>
<thead>
<tr>
<th>字段名</th>
<th>名称</th>
<th>数据类型</th>
<th>约束</th>
</tr>
</thead>
<tbody><tr>
<td>id</td>
<td>打卡 ID</td>
<td>bigint(20)</td>
<td>PK</td>
</tr>
<tr>
<td>addtime</td>
<td>创建时间</td>
<td>timestamp</td>
<td>NOT NULL</td>
</tr>
<tr>
<td>Dakabianhao</td>
<td>打卡编号</td>
<td>varchar(200)</td>
<td>NOT NULL</td>
</tr>
<tr>
<td>Dakamingcheng</td>
<td>打卡名称</td>
<td>varchar(200)</td>
<td>无</td>
</tr>
<tr>
<td>tupian</td>
<td>图片</td>
<td>varchar(200)</td>
<td>无</td>
</tr>
<tr>
<td>Kongpancishu</td>
<td>空盘次数</td>
<td>int</td>
<td>无</td>
</tr>
<tr>
<td>Dakashijian</td>
<td>打卡时间</td>
<td>datetime</td>
<td>无</td>
</tr>
<tr>
<td>Yonghuming</td>
<td>用户名</td>
<td>varchar(200)</td>
<td>无</td>
</tr>
<tr>
<td>Xingming</td>
<td>姓名</td>
<td>varchar(200)</td>
<td>无</td>
</tr>
<tr>
<td>beizhu</td>
<td>备注</td>
<td>varchar(200)</td>
<td>无</td>
</tr>
</tbody></table>
<p>食物信息表的字段为食物名称、食物类型、图片、热量值等，id 为主键。该表存储每个食物的详细信息。食物信息表结构如表所示。</p>
<p>表食物信息表</p>
<table>
<thead>
<tr>
<th>字段名</th>
<th>名称</th>
<th>数据类型</th>
<th>约束</th>
</tr>
</thead>
<tbody><tr>
<td>id</td>
<td>食物信息 ID</td>
<td>bigint(20)</td>
<td>PK</td>
</tr>
<tr>
<td>addtime</td>
<td>创建时间</td>
<td>timestamp</td>
<td>NOT NULL</td>
</tr>
<tr>
<td>shiwumingcheng</td>
<td>食物名称</td>
<td>varchar(200)</td>
<td>无</td>
</tr>
<tr>
<td>tupian</td>
<td>图片</td>
<td>varchar(200)</td>
<td>无</td>
</tr>
<tr>
<td>shiwuleixing</td>
<td>食物类型</td>
<td>varchar(200)</td>
<td>无</td>
</tr>
<tr>
<td>reliangzhi</td>
<td>热量值</td>
<td>varchar(200)</td>
<td>无</td>
</tr>
</tbody></table>
<p>榜单表的字段为打卡编号、空盘次数、图片、更新时间等，id 为主键。该表存储管理员根据用户的每日打卡信息所发布的榜单中，每个榜单的详细信息。榜单表结构如表</p>
<p> 所示。</p>
<p>表榜单表</p>
<table>
<thead>
<tr>
<th>字段名</th>
<th>名称</th>
<th>数据类型</th>
<th>约束</th>
</tr>
</thead>
<tbody><tr>
<td>id</td>
<td>榜单 ID</td>
<td>bigint(20)</td>
<td>PK</td>
</tr>
<tr>
<td>addtime</td>
<td>创建时间</td>
<td>timestamp</td>
<td>NOT NULL</td>
</tr>
<tr>
<td>dakabianhao</td>
<td>打卡编号</td>
<td>varchar(200)</td>
<td>无</td>
</tr>
<tr>
<td>tupian</td>
<td>图片</td>
<td>varchar(200)</td>
<td>无</td>
</tr>
<tr>
<td>kongpancishu</td>
<td>空盘次数</td>
<td>varchar(200)</td>
<td>无</td>
</tr>
<tr>
<td>yonghuming</td>
<td>用户名</td>
<td>varchar(200)</td>
<td>无</td>
</tr>
<tr>
<td>xingming</td>
<td>姓名</td>
<td>varchar(200)</td>
<td>无</td>
</tr>
<tr>
<td>gengxinshijian</td>
<td>更新时间</td>
<td>date</td>
<td>无</td>
</tr>
</tbody></table>
<p>食物类型表的字段为食物类型和创建时间，id 为主键。该表存储着每个食物类型的详细信息。食物类型表结构如表所示。</p>
<p>表食物类型表</p>
<table>
<thead>
<tr>
<th>字段名</th>
<th>名称</th>
<th>数据类型</th>
<th>约束</th>
</tr>
</thead>
<tbody><tr>
<td>id</td>
<td>食物类型 ID</td>
<td>bigint(20)</td>
<td>PK</td>
</tr>
<tr>
<td>addtime</td>
<td>创建时间</td>
<td>timestamp</td>
<td>NOT NULL</td>
</tr>
<tr>
<td>shiwuleixing</td>
<td>食物类型</td>
<td>varchar(200)</td>
<td>NOT NULL</td>
</tr>
</tbody></table>
<p>文章分享表的字段为帖子标题、帖子内容、用户 id、状态等，id 为主键。该表存储着每篇文章的详细信息。文章分享表结构如表所示。</p>
<p>表文章分享表</p>
<table>
<thead>
<tr>
<th>字段名</th>
<th>名称</th>
<th>数据类型</th>
<th>约束</th>
</tr>
</thead>
<tbody><tr>
<td>id</td>
<td>文章 ID</td>
<td>bigint(20)</td>
<td>PK</td>
</tr>
<tr>
<td>addtime</td>
<td>创建时间</td>
<td>timestamp</td>
<td>NOT NULL</td>
</tr>
<tr>
<td>title</td>
<td>帖子标题</td>
<td>varchar(200)</td>
<td>无</td>
</tr>
<tr>
<td>content</td>
<td>帖子内容</td>
<td>longtext</td>
<td>NOT NULL</td>
</tr>
<tr>
<td>parentid</td>
<td>父节点 id</td>
<td>bignit</td>
<td>无</td>
</tr>
<tr>
<td>userid</td>
<td>用户 id</td>
<td>bignit</td>
<td>NOT NULL</td>
</tr>
<tr>
<td>username</td>
<td>用户名</td>
<td>varchar(200)</td>
<td>无</td>
</tr>
<tr>
<td>isdone</td>
<td>状态</td>
<td>varchar(200)</td>
<td>无</td>
</tr>
</tbody></table>
<h2 id="JSON-接口设计"><a href="#JSON-接口设计" class="headerlink" title="JSON 接口设计"></a>JSON 接口设计</h2><p>网站获取食物类型列表接口设计。该接口用于在前端显示食物类型列表。获取食物类型列表接口设计如表所示。</p>
<p>表获取食物类型列表接口</p>
<table>
<thead>
<tr>
<th>功能说明</th>
<th>获取食物类型列表接口</th>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td><strong>URL</strong> 地址</td>
<td><a href="http://localhost:8080/django1q7tt/shiwuleixing/list">http://localhost:8080/django1q7tt/shiwuleixing/list</a></td>
<td></td>
<td></td>
</tr>
<tr>
<td>参数列表</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>参数名称</td>
<td>是否必须</td>
<td>类型</td>
<td>描述</td>
</tr>
<tr>
<td>无参数</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>请求类型</td>
<td>POST</td>
<td></td>
<td></td>
</tr>
<tr>
<td>返回参数类型</td>
<td>JSON</td>
<td></td>
<td></td>
</tr>
<tr>
<td>返回参数列表</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>参数名称</td>
<td>描述</td>
<td></td>
<td></td>
</tr>
<tr>
<td>code</td>
<td>数据状态码（成功状态码是 200）</td>
<td></td>
<td></td>
</tr>
<tr>
<td>data</td>
<td>具体数据</td>
<td></td>
<td></td>
</tr>
</tbody></table>
<p>网站获取食物信息列表接口设计。该接口用于在前端显示食物信息列表。获取食物信息列表接口设计如表所示。</p>
<p>表获取食物信息列表接口</p>
<table>
<thead>
<tr>
<th>功能说明</th>
<th>获取食物信息列表接口</th>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td><strong>URL</strong> 地址</td>
<td><a href="http://localhost:8080/django1q7tt/shiwuxinxi/list">http://localhost:8080/django1q7tt/shiwuxinxi/list</a></td>
<td></td>
<td></td>
</tr>
<tr>
<td>参数列表</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>参数名称</td>
<td>是否必须</td>
<td>类型</td>
<td>描述</td>
</tr>
<tr>
<td>无参数</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>请求类型</td>
<td>POST</td>
<td></td>
<td></td>
</tr>
<tr>
<td>返回参数类型</td>
<td>JSON</td>
<td></td>
<td></td>
</tr>
<tr>
<td>返回参数列表</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>参数名称</td>
<td>描述</td>
<td></td>
<td></td>
</tr>
<tr>
<td>code</td>
<td>数据状态码（成功状态码是 200）</td>
<td></td>
<td></td>
</tr>
<tr>
<td>data</td>
<td>具体数据</td>
<td></td>
<td></td>
</tr>
</tbody></table>
<p>网站获取每日打卡详细信息接口设计。该接口用于在前端、后端获取每日打卡的详细信息。获取每日打卡详细信息接口设计如表 0 所示。</p>
<p>表 0 获取每日打卡详细信息接口</p>
<table>
<thead>
<tr>
<th>功能说明</th>
<th>获取每日打卡详细信息接口</th>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td><strong>URL</strong> 地址</td>
<td><a href="http://localhost:8080/">http://localhost:8080/</a> django1q7tt&#x2F; meiridaka&#x2F;detail</td>
<td></td>
<td></td>
</tr>
<tr>
<td>参数列表</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>参数名称</td>
<td>是否必须</td>
<td>类型</td>
<td>描述</td>
</tr>
<tr>
<td>id</td>
<td>是</td>
<td>Number</td>
<td>打卡 id</td>
</tr>
<tr>
<td>dakabianhao</td>
<td>否</td>
<td>String</td>
<td>打卡编号</td>
</tr>
<tr>
<td>tupian</td>
<td>否</td>
<td>String</td>
<td>订单状态</td>
</tr>
<tr>
<td>kongpancishu</td>
<td>否</td>
<td>Number</td>
<td>空盘次数</td>
</tr>
<tr>
<td>dakashijian</td>
<td>否</td>
<td>String</td>
<td>打卡时间</td>
</tr>
<tr>
<td>yonghuming</td>
<td>否</td>
<td>String</td>
<td>用户名</td>
</tr>
<tr>
<td>xingming</td>
<td>否</td>
<td>String</td>
<td>姓名</td>
</tr>
<tr>
<td>dakamingcheng</td>
<td>否</td>
<td>String</td>
<td>打卡名称</td>
</tr>
<tr>
<td>beizhu</td>
<td>否</td>
<td>String</td>
<td>备注</td>
</tr>
<tr>
<td>请求类型</td>
<td>POST</td>
<td></td>
<td></td>
</tr>
</tbody></table>
<p>续表 0 获取每日打卡详细信息接口</p>
<table>
<thead>
<tr>
<th>返回参数类型</th>
<th>JSON</th>
</tr>
</thead>
<tbody><tr>
<td>返回参数列表</td>
<td></td>
</tr>
<tr>
<td>参数名称</td>
<td>描述</td>
</tr>
<tr>
<td>code</td>
<td>数据状态码（成功状态码是 200）</td>
</tr>
<tr>
<td>data</td>
<td>具体数据</td>
</tr>
</tbody></table>
<p>网站保存榜单信息接口设计，该接口保存创建或修改好的榜单信息。保存榜单接口设计如表 1 所示。</p>
<p>表 1 保存榜单接口</p>
<table>
<thead>
<tr>
<th>功能说明</th>
<th>保存榜单接口</th>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td><strong>URL</strong> 地址</td>
<td><a href="http://localhost:8080/django1q7tt/bangdan/save">http://localhost:8080/django1q7tt/bangdan/save</a></td>
<td></td>
<td></td>
</tr>
<tr>
<td>参数列表</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>参数名称</td>
<td>是否必须</td>
<td>类型</td>
<td>描述</td>
</tr>
<tr>
<td>id</td>
<td>是</td>
<td>Number</td>
<td>榜单 id</td>
</tr>
<tr>
<td>dakabianhao</td>
<td>否</td>
<td>String</td>
<td>打卡编号</td>
</tr>
<tr>
<td>tupian</td>
<td>否</td>
<td>String</td>
<td>订单状态</td>
</tr>
<tr>
<td>kongpancishu</td>
<td>否</td>
<td>Number</td>
<td>空盘次数</td>
</tr>
<tr>
<td>yonghuming</td>
<td>否</td>
<td>String</td>
<td>用户名</td>
</tr>
<tr>
<td>xingming</td>
<td>否</td>
<td>String</td>
<td>姓名</td>
</tr>
<tr>
<td>gengxingshijian</td>
<td>否</td>
<td>String</td>
<td>更新时间</td>
</tr>
<tr>
<td>请求类型</td>
<td>POST</td>
<td></td>
<td></td>
</tr>
<tr>
<td>返回参数类型</td>
<td>JSON</td>
<td></td>
<td></td>
</tr>
<tr>
<td>返回参数列表</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>参数名称</td>
<td>描述</td>
<td></td>
<td></td>
</tr>
<tr>
<td>code</td>
<td>数据状态码（成功状态码是 200）</td>
<td></td>
<td></td>
</tr>
<tr>
<td>data</td>
<td>具体数据</td>
<td></td>
<td></td>
</tr>
</tbody></table>
<h1 id="系统实现"><a href="#系统实现" class="headerlink" title="系统实现"></a>系统实现</h1><h2 id="后台功能模块实现"><a href="#后台功能模块实现" class="headerlink" title="后台功能模块实现"></a>后台功能模块实现</h2><h3 id="新增食物类型功能模块实现"><a href="#新增食物类型功能模块实现" class="headerlink" title="新增食物类型功能模块实现"></a>新增食物类型功能模块实现</h3><p>新增食物类型功能的实现，前端发送请求后，通过 URL 调用 shiwuleixing 的 list、add 和 save 接口操作后台对 shiwuleixing 数据库表进行增、删、改、查操作，最后将数据逐级返回到前端。查看食物类型列表如下图所示，新增食物类型功能实现如下图所示。</p>
<p><img src="/../pic/media-pzc/49f1599942f4c7756c8f80f9e57a9f7d.jpeg"></p>
<p>查看食物类型列表</p>
<p><img src="/../pic/media-pzc/93d9948d56fbef1c4c62fd9d5c6c6075.jpeg"></p>
<p>新增食物类型功能实现</p>
<p>后台新增食物类型功能代码如下所示：</p>
<h3 id="删除文章分享的帖子功能模块实现"><a href="#删除文章分享的帖子功能模块实现" class="headerlink" title="删除文章分享的帖子功能模块实现"></a>删除文章分享的帖子功能模块实现</h3><p>删除文章分享的帖子功能的实现，前端发送请求后，通过 URL 先调用 forum_page 接口权限为管理员查看 forum 记录，再调用 forum_delete 接口操作后台对 forum 数据库表的信息进行删除操作，最后将数据逐级返回到前端。删除文章分享的帖子功能模块实现如下图所示。</p>
<p><img src="/../pic/media-pzc/1bdfc65ae82daf224f15abdc827dfbe1.jpeg"></p>
<p>删除文章分享的帖子模块实现</p>
<p>删除文章分享的帖子模块功能代码如下所示：</p>
<h3 id="修改每日打卡信息模块实现"><a href="#修改每日打卡信息模块实现" class="headerlink" title="修改每日打卡信息模块实现"></a>修改每日打卡信息模块实现</h3><p>修改每日打卡信息模块的实现，前端发送请求后，通过 URL 调用 meiridaka_update 接口，对从 meiridaka 数据库表中通过 meiridaka_info 接口选定数据的修改，最后将数据逐级返回到前端。修改每日打卡信息功能模块实现如下图所示</p>
<p><img src="/../pic/media-pzc/c465a20dbab11799620e8963a6c38f96.jpeg"></p>
<p>修改每日打卡信息功能实现</p>
<p>修改每日打卡信息模块功能代码如下所示：</p>
<h2 id="前台功能模块实现"><a href="#前台功能模块实现" class="headerlink" title="前台功能模块实现"></a>前台功能模块实现</h2><h3 id="用户查看每日打卡详情功能模块实现"><a href="#用户查看每日打卡详情功能模块实现" class="headerlink" title="用户查看每日打卡详情功能模块实现"></a>用户查看每日打卡详情功能模块实现</h3><p>用户查看每日打卡详情功能的实现，前端发送请求后，通过 URL 调用 meiridaka 的list 和 detail 接口操作后台对 meiridaka 数据库表进行查找查看操作，最后将数据逐级返回到前端。用户查看每日打卡详情功能实现如下图所示。</p>
<p><img src="/../pic/media-pzc/78806c6edc2e45dfe333a6c8f5e71681.jpeg"></p>
<h2 id="附件"><a href="#附件" class="headerlink" title="附件"></a>附件</h2><p><a href="https://xcyyyy19.github.io/code/P4-pzc/%E7%A8%8B%E5%BA%8F%E4%BB%A3%E7%A0%81/django.zip">代码下载链接</a><br><a href="https://xcyyyy19.github.io/code/P4-pzc/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%96%87%E4%BB%B6django.sql">数据库下载链接</a></p>
]]></content>
      <categories>
        <category>code</category>
        <category>project</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>Vue</tag>
        <tag>Django</tag>
      </tags>
  </entry>
  <entry>
    <title>CSS学习笔记-1.2实践</title>
    <url>/2023/03/29/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/CSS/Q2-CSS-2%E5%AE%9E%E8%B7%B5%EF%BC%88%E5%9F%BA%E6%9C%AC%E6%A0%B7%E5%BC%8F%EF%BC%89/</url>
    <content><![CDATA[<h1 id="CSS学习笔记-1-2实践"><a href="#CSS学习笔记-1-2实践" class="headerlink" title="CSS学习笔记-1.2实践"></a>CSS学习笔记-1.2实践</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang=&quot;en&quot;&gt;</span><br><span class="line">  &lt;head&gt;</span><br><span class="line">  	&lt;meta charset=&quot;UTF-8&quot;&gt;</span><br><span class="line">  	&lt;title&gt;Title&lt;/title&gt;</span><br><span class="line">    &lt;title&gt;Cafe Menu&lt;/title&gt;</span><br><span class="line">    &lt;link href=&quot;../CSS/咖啡.css&quot; rel=&quot;stylesheet&quot;&gt;</span><br><span class="line">  &lt;/head&gt;</span><br><span class="line">  &lt;body&gt;</span><br><span class="line">    &lt;div class=&quot;menu&quot;&gt;</span><br><span class="line">      &lt;main&gt;</span><br><span class="line">        &lt;h1&gt;CAMPER CAFE&lt;/h1&gt;</span><br><span class="line">        &lt;p class=&quot;established&quot;&gt;Est. 2020&lt;/p&gt;</span><br><span class="line">        &lt;hr&gt;</span><br><span class="line">        &lt;section&gt;</span><br><span class="line">          &lt;h2&gt;Coffee&lt;/h2&gt;</span><br><span class="line">          &lt;img src=&quot;https://cdn.freecodecamp.org/curriculum/css-cafe/coffee.jpg&quot; alt=&quot;coffee icon&quot;/&gt;</span><br><span class="line">          &lt;article class=&quot;item&quot;&gt;</span><br><span class="line">            &lt;p class=&quot;flavor&quot;&gt;French Vanilla&lt;/p&gt;&lt;p class=&quot;price&quot;&gt;3.00&lt;/p&gt;</span><br><span class="line">          &lt;/article&gt;</span><br><span class="line">          &lt;article class=&quot;item&quot;&gt;</span><br><span class="line">            &lt;p class=&quot;flavor&quot;&gt;Caramel Macchiato&lt;/p&gt;&lt;p class=&quot;price&quot;&gt;3.75&lt;/p&gt;</span><br><span class="line">          &lt;/article&gt;</span><br><span class="line">          &lt;article class=&quot;item&quot;&gt;</span><br><span class="line">            &lt;p class=&quot;flavor&quot;&gt;Pumpkin Spice&lt;/p&gt;&lt;p class=&quot;price&quot;&gt;3.50&lt;/p&gt;</span><br><span class="line">          &lt;/article&gt;</span><br><span class="line">          &lt;article class=&quot;item&quot;&gt;</span><br><span class="line">            &lt;p class=&quot;flavor&quot;&gt;Hazelnut&lt;/p&gt;&lt;p class=&quot;price&quot;&gt;4.00&lt;/p&gt;</span><br><span class="line">          &lt;/article&gt;</span><br><span class="line">          &lt;article class=&quot;item&quot;&gt;</span><br><span class="line">            &lt;p class=&quot;flavor&quot;&gt;Mocha&lt;/p&gt;&lt;p class=&quot;price&quot;&gt;4.50&lt;/p&gt;</span><br><span class="line">          &lt;/article&gt;</span><br><span class="line">        &lt;/section&gt;</span><br><span class="line">        &lt;section&gt;</span><br><span class="line">          &lt;h2&gt;Desserts&lt;/h2&gt;</span><br><span class="line">          &lt;img src=&quot;https://cdn.freecodecamp.org/curriculum/css-cafe/pie.jpg&quot; alt=&quot;pie icon&quot;/&gt;</span><br><span class="line">          &lt;article class=&quot;item&quot;&gt;</span><br><span class="line">            &lt;p class=&quot;dessert&quot;&gt;Donut&lt;/p&gt;&lt;p class=&quot;price&quot;&gt;1.50&lt;/p&gt;</span><br><span class="line">          &lt;/article&gt;</span><br><span class="line">          &lt;article class=&quot;item&quot;&gt;</span><br><span class="line">            &lt;p class=&quot;dessert&quot;&gt;Cherry Pie&lt;/p&gt;&lt;p class=&quot;price&quot;&gt;2.75&lt;/p&gt;</span><br><span class="line">          &lt;/article&gt;</span><br><span class="line">          &lt;article class=&quot;item&quot;&gt;</span><br><span class="line">            &lt;p class=&quot;dessert&quot;&gt;Cheesecake&lt;/p&gt;&lt;p class=&quot;price&quot;&gt;3.00&lt;/p&gt;</span><br><span class="line">          &lt;/article&gt;</span><br><span class="line">          &lt;article class=&quot;item&quot;&gt;</span><br><span class="line">            &lt;p class=&quot;dessert&quot;&gt;Cinnamon Roll&lt;/p&gt;&lt;p class=&quot;price&quot;&gt;2.50&lt;/p&gt;</span><br><span class="line">          &lt;/article&gt;</span><br><span class="line">        &lt;/section&gt;</span><br><span class="line">      &lt;/main&gt;</span><br><span class="line">      &lt;hr class=&quot;bottom-line&quot;&gt;</span><br><span class="line">      &lt;footer&gt;</span><br><span class="line">        &lt;p&gt;</span><br><span class="line">          &lt;a href=&quot;https://www.freecodecamp.org&quot; target=&quot;_blank&quot;&gt;Visit our website&lt;/a&gt;</span><br><span class="line">        &lt;/p&gt;</span><br><span class="line">        &lt;p class=&quot;address&quot;&gt;123 Free Code Camp Drive&lt;/p&gt;</span><br><span class="line">      &lt;/footer&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  &lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>



<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">body &#123;</span><br><span class="line">  background-image: url(https://cdn.freecodecamp.org/curriculum/css-cafe/beans.jpg);</span><br><span class="line">  font-family: sans-serif;</span><br><span class="line">  padding: 20px;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">h1 &#123;</span><br><span class="line">  font-size: 40px;</span><br><span class="line">  margin-top: 0;</span><br><span class="line">  margin-bottom: 15px;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">h2 &#123;</span><br><span class="line">  font-size: 30px;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.established &#123;</span><br><span class="line">  font-style: italic;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">h1, h2, p &#123;</span><br><span class="line">  text-align: center;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.menu &#123;</span><br><span class="line">  width: 80%;</span><br><span class="line">  background-color: burlywood;</span><br><span class="line">  margin-left: auto;</span><br><span class="line">  margin-right: auto;</span><br><span class="line">  padding: 20px;</span><br><span class="line">  max-width: 500px;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">img &#123;</span><br><span class="line">  display: block;</span><br><span class="line">  margin-left: auto;</span><br><span class="line">  margin-right: auto;</span><br><span class="line">  margin-top: -25;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">hr &#123;</span><br><span class="line">  height: 2px;</span><br><span class="line">  background-color: brown;</span><br><span class="line">  border-color: brown;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.bottom-line &#123;</span><br><span class="line">  margin-top: 25px;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">h1, h2 &#123;</span><br><span class="line">  font-family: Impact, serif;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.item p &#123;</span><br><span class="line">  display: inline-block;</span><br><span class="line">  margin-top: 5px;</span><br><span class="line">  margin-bottom: 5px;</span><br><span class="line">  font-size: 18px;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.flavor, .dessert &#123;</span><br><span class="line">  text-align: left;</span><br><span class="line">  width: 75%;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.price &#123;</span><br><span class="line">  text-align: right;</span><br><span class="line">  width: 25%;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/* FOOTER */</span><br><span class="line"></span><br><span class="line">footer &#123;</span><br><span class="line">  font-size: 14px;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.address &#123;</span><br><span class="line">  margin-bottom: 5px;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">a &#123;</span><br><span class="line">  color: black;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">a:visited &#123;</span><br><span class="line">  color: black;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">a:hover &#123;</span><br><span class="line">  color: brown;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">a:active &#123;</span><br><span class="line">  color: brown;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>code</category>
        <category>note</category>
      </categories>
      <tags>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title>CSS学习笔记-1.1基本样式</title>
    <url>/2023/03/29/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/CSS/Q2-CSS-1%E5%9F%BA%E6%9C%AC%E6%A0%B7%E5%BC%8F+%E7%9B%92%E5%AD%90%E6%A8%A1%E5%9E%8B/</url>
    <content><![CDATA[<h1 id="CSS学习笔记-1-1基本样式"><a href="#CSS学习笔记-1-1基本样式" class="headerlink" title="CSS学习笔记-1.1基本样式"></a>CSS学习笔记-1.1基本样式</h1><p>注释:</p>
<p>​			CSS:&#x2F;**&#x2F;</p>
<p>技巧：</p>
<p>​			先写html框架，再考虑CSS</p>
<p>​			定义主要容器时，要定义成宽度是由我们固定的，高度完全是由内容撑开的。</p>
<p>CSS游戏：</p>
<p>​			<a href="https://frontend30.com/css-selectors-cheatsheet/">CSS Selectors Cheatsheet - FrontEnd30</a></p>
<p>思维导图：</p>
<p>​			<a href="https://flowus.cn/d3cec49a-35cf-46aa-a095-f5ed4406287e">CSS思维导图 (flowus.cn)</a></p>
<h3 id="0-CSS基本样式"><a href="#0-CSS基本样式" class="headerlink" title="0.CSS基本样式"></a>0.CSS基本样式</h3><p>选择器（Selector）<br>HTML 元素的名称位于规则集开始。它选择了一个或多个需要添加样式的元素）。要给不同元素添加样式只需要更改选择器就行了。可以用固定标签名，或.+自定义名称来进行选择。如用.menu来选择class属性为menu的盒子。</p>
<p>通配符选择器作用：给当前界面上所有的标签设置属性。（*的意思是选中所有的标签）</p>
<p>声明（Declaration）<br>一个单独的规则，如 color: red; 用来指定添加样式元素的属性。</p>
<p>属性（Properties）<br>改变 HTML 元素样式的途径。（本例中 color 就是 <p> 元素的属性。）CSS 中，由编写人员决定修改哪个属性以改变规则。</p>
<p>属性的值（Property value）<br>在属性的右边，冒号后面即属性的值，它从指定属性的众多外观中选择一个值（我们除了 red 之外还有很多属性值可以用于 color ）。</p>
<h3 id="1-常见基础样式"><a href="#1-常见基础样式" class="headerlink" title="1.常见基础样式"></a>1.常见基础样式</h3><h3 id=""><a href="#" class="headerlink" title=""></a></h3><ul>
<li><p>基础：</p>
<p>声明该边框的类型：display ：可选项如下</p>
<p>​								flex灵活布局</p>
<p>​								grid网格布局</p>
<p><img src="/markdown-img/Q2-CSS-1%E5%9F%BA%E6%9C%AC%E6%A0%B7%E5%BC%8F+%E7%9B%92%E5%AD%90%E6%A8%A1%E5%9E%8B.assets/image-20230329162830851.png" alt="image-20230329162830851"></p>
<p>​							</p>
<ul>
<li><p>通用（框架相关）:</p>
<p>宽度:   width: 300px;（百分制也行），div默认居左，所以背景颜色随着宽度的改变也居左。</p>
<p>最大宽度: max-width: 500px;</p>
<p>​				（背景是不动的，主页面随着浏览器大小变化，有最大宽度的约束，内容看起来就不会过宽）</p>
<p>最小宽度：</p>
<p>最大高度：</p>
<p>最小高度：</p>
</li>
</ul>
<h3 id="2-文字相关"><a href="#2-文字相关" class="headerlink" title="2.文字相关"></a>2.文字相关</h3><p>单位：</p>
<p>​		em设置成几个字符大小（根据用户使用的字体自适应）</p>
<p>​		px像素</p>
<p>​		%百分比</p>
<p>颜色：</p>
<p>​		<img src="../其它/markdown-img\Q2-CSS-1基本样式+盒子模型.assets\image-20230407121714988.png" alt="image-20230407121714988" style="zoom:25%;" /></p>
<p>文本对齐：<strong>text-align</strong></p>
<p>​	居中: text-align: <strong>center;</strong></p>
<p>​	居左: text-align: <strong>left;</strong></p>
<p>​	居右: text-align: <strong>right;</strong></p>
<p>​	居左: text-align: <strong>justify;</strong></p>
<p>​	应用：文本的垂直居中（flex也行）</p>
<p>[CSS 布局 – 水平 &amp; 垂直对齐 | 菜鸟教程 (runoob.com)](<a href="https://www.runoob.com/css/css-align.html#:~:text=CSS">https://www.runoob.com/css/css-align.html#:~:text=CSS</a> 布局 - 水平 %26 垂直对齐 1 元素居中对齐,8 垂直居中 - 使用 position 和 transform 更多项目)</p>
<p>字间距：<strong>letter-spacing</strong></p>
<p>​	取值：2px&#x2F;-2px</p>
<p>行高：<strong>line-height</strong></p>
<p>​	取值：14px&#x2F;1.5em几倍行高&#x2F;120%基于当前字符的百分比行高</p>
<p>装饰线：<strong>text-decoration</strong> </p>
<p>​	上划线：<strong>overline</strong></p>
<p>​	删除线：<strong>line-throuth</strong></p>
<p>​	下划线：<strong>underling</strong></p>
<p>​	删除：<strong>none</strong>（针对a标签，去掉自带的下划线）</p>
<p>字体：</p>
<p>​		字体所有属性：<strong>font</strong>：很多设定 字号及行高（用斜线隔开） 字体名称；</p>
<p>​					例子：font：bold（粗体） italic（斜体） 18px&#x2F;1.5em ‘幼圆’</p>
<p>​		字体系列: <strong>font-family:</strong> Impact,serif;</p>
<p>​					重点：可以写多个字体，用逗号隔开。找不到第一种字体就用第二种，都找不到就用默认字体。</p>
<p>​					易错点：字体含有空格时，应加双引号</p>
<p>​					例子：font-family：“Microsoft YaHei”</p>
<p>​		字体大小：<strong>font-size：</strong>18px；</p>
<p>​		字重：<strong>font-weight</strong>（字体粗细）</p>
<p>​		斜体： font-style:italic;</p>
<p>CSS3中三种文本相关属性：</p>
<p>​				文本阴影：<strong>text-shadow</strong>：水平偏移量 垂直偏移量  阴影大小（可省略） 颜色；</p>
<p>​									常用效果：</p>
<p>​													文本描边：0 0 3px black；</p>
<p>​													文字浮雕效果：color：white； text-shadow：2px 2px 4px #000；</p>
<p>​								   类似于《CSS-1定位与布局》中的盒子阴影。</p>
<p>​				长文本换行：<strong>word-warp</strong>：break-word；</p>
<p>​				网络字体：**@font-face**</p>
<p>​									需要从网络上下载字体到服务器本地，并转化成各种浏览器支持的格式</p>
<p>​									最后通过引用本地的字体文件来给用户端进行显示。</p>
<h3 id="3-其它"><a href="#3-其它" class="headerlink" title="3.其它"></a>3.其它</h3><p>圆角：<img src="/markdown-img/Q2-CSS-1%E5%9F%BA%E6%9C%AC%E6%A0%B7%E5%BC%8F+%E7%9B%92%E5%AD%90%E6%A8%A1%E5%9E%8B.assets/1680769113691.png" alt="1680769113691" style="zoom:30%;" />值为px</p>
<p>​			border-radius：25px；圆角边框。</p>
<p>阴影：属性box-shadow</p>
<p>​			选项为inside&#x2F;outside（默认值为外部阴影），值为水平偏移px 垂直偏移px 模糊强度px 颜色。</p>
<p>​			举例：<img src="/markdown-img/Q2-CSS-1%E5%9F%BA%E6%9C%AC%E6%A0%B7%E5%BC%8F+%E7%9B%92%E5%AD%90%E6%A8%A1%E5%9E%8B.assets/1680769413222.png" alt="1680769413222" style="zoom:38%;" />就是阴影是盒子往右下角偏移10px的效果。</p>
<p>​			举例2：<img src="/markdown-img/Q2-CSS-1%E5%9F%BA%E6%9C%AC%E6%A0%B7%E5%BC%8F+%E7%9B%92%E5%AD%90%E6%A8%A1%E5%9E%8B.assets/1680769550505.png" alt="1680769550505" style="zoom:38%;" /></p>
<h1 id="分割线：html的hr标签"><a href="#分割线：html的hr标签" class="headerlink" title="分割线：html的hr标签"></a>分割线：html的hr标签</h1><h1 id="样式有heigh、background-color、border-color（边框颜色）border-width（边框宽度）"><a href="#样式有heigh、background-color、border-color（边框颜色）border-width（边框宽度）" class="headerlink" title="样式有heigh、background-color、border-color（边框颜色）border-width（边框宽度）"></a>样式有heigh、background-color、border-color（边框颜色）border-width（边框宽度）</h1><h1 id="（看起来会有凹陷效果）"><a href="#（看起来会有凹陷效果）" class="headerlink" title="（看起来会有凹陷效果）"></a>（看起来会有凹陷效果）</h1><p>链接文字的颜色：a{color：black；}</p>
<p>链接访问后：a:visited {  }</p>
<p>链接上有鼠标悬停时：a:hover{}</p>
<p>链接被点击时：a:active{}</p>
</li>
<li><p>背景相关:</p>
<p>背景颜色:background-color:</p>
<p>背景图:background-image: url(<a href="https://cdn.freecodecamp.org/curriculum/css-cafe/beans.jpg">https://cdn.freecodecamp.org/curriculum/css-cafe/beans.jpg</a>);</p>
</li>
<li><p>盒子相关:</p>
</li>
</ul>
<p>​				对块级元素进行强制内联状:display: inline-block;</p>
<p>​				去除元素前端可能存在的空白符:<style>   div{font-size:0;}    </style></p>
<p>​					</p>
<blockquote>
<p>​	【【Q1为什么不能直接用内联元素？】】</p>
<p>​	【inline-block是元素具备了块级和内联元素的功能，inline最重要的一点就是:</p>
<p>​	元素能够在一行展示，而inline元素所缺失的设置宽高，是block 元素的功能】</p>
</blockquote>
<blockquote>
<p>​	【【Q2为什么用了i-b会导致，设置宽度时，总和必须小于100%？（否则会另起一行）】】</p>
<p>​	【因为HTML 中的换行符、空格符、制表符等合并为空白符，字体大小不为 0 的情况下，</p>
<pre><code> 空白符自然占据定的宽度，使用inline-block 会产生了元素间的空隙。】
</code></pre>
</blockquote>
<blockquote>
<p>​	【【Q3不想自己调试合适的宽度怎么办？】】</p>
<p>​	【在写用了强制内联化的块级元素时，全部写在同一行，一个空格都不要加。比如<p>1</p><p>2</p>】</p>
</blockquote>
<blockquote>
<p>​	【【Q4最佳解决办法是什么？】】</p>
<p>​	【父元素设置font-size:0,子元素有需要可以另外设置font-size，</p>
<p>​	 这样空白符因为font-size:0就不会占据宽度了】</p>
</blockquote>
<blockquote>
<p>实例:</p>
<p><a href="https://www.zhangxinxu.com/study/201011/img-blank-space.html">display:inline-block元素间换行符的空格间隙 </a></p>
<p><a href="https://www.zhangxinxu.com/study/201011/img-font-size-clear-blank.html">font-size:0清除display:inline-block元素换行符间隙</a></p>
</blockquote>
<h3 id="4-style元素"><a href="#4-style元素" class="headerlink" title="4.style元素"></a><strong>4.style元素</strong></h3><ul>
<li><p>单独写在css文件夹里，并在head里通过link来链接。 </p>
<link rel="stylesheet" href="styles.css">
</li>
<li><p>用于给body里的某一种&#x2F;多种元素指定样式。</p>
</li>
</ul>
<h3 id="5-多端样式归一化必加代码【【【【】】】】"><a href="#5-多端样式归一化必加代码【【【【】】】】" class="headerlink" title="5.多端样式归一化必加代码【【【【】】】】"></a><strong>5.多端样式归一化必加代码</strong>【【【【】】】】</h3><p>​    <meta name="viewport" content="width=device-width, initial-scale=1.0" /></p>
<h3 id="6-过度与动画"><a href="#6-过度与动画" class="headerlink" title="6.过度与动画"></a>6.过度与动画</h3><p>过渡：<strong>transition</strong>属性</p>
<p>​				知识：  transition：属性    时间    速度；<img src="/markdown-img/Q2-CSS-1%E5%9F%BA%E6%9C%AC%E6%A0%B7%E5%BC%8F+%E7%9B%92%E5%AD%90%E6%A8%A1%E5%9E%8B.assets/image-20230406211511826.png" alt="image-20230406211511826" style="zoom:25%;" /></p>
<p>​							transition：a，p   1s    linear；          </p>
<p>​							transition：     all   1s    linear；</p>
<p>​				作用：在规定时间内，暂时改变选定元素属性的值（和选择器一起使用）</p>
<p>​				举例：鼠标悬停在确认按钮上的时候，按钮显示为绿色。</p>
<p>动画：<strong>animation</strong>属性（需要连续的过渡时，改用动画）</p>
<p>@keyframes规则（关键帧规则）</p>
]]></content>
      <categories>
        <category>code</category>
        <category>note</category>
      </categories>
      <tags>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title>CSS学习笔记-2.2选择器</title>
    <url>/2023/03/28/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/CSS/Q3-CSS-2%E9%80%89%E6%8B%A9%E5%99%A8/</url>
    <content><![CDATA[<h1 id="CSS学习笔记-2-2选择器"><a href="#CSS学习笔记-2-2选择器" class="headerlink" title="CSS学习笔记-2.2选择器"></a>CSS学习笔记-2.2选择器</h1><h4 id="选择器字典"><a href="#选择器字典" class="headerlink" title="选择器字典"></a>选择器字典</h4><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/Attribute_selectors">属性选择器 - CSS：层叠样式表 | MDN (mozilla.org)</a></p>
<p><a href="https://www.ruanyifeng.com/blog/2009/03/css_selectors.html">CSS选择器笔记 - 阮一峰的网络日志 (ruanyifeng.com)</a></p>
<p><a href="https://frontend30.com/css-selectors-cheatsheet/">CSS Selectors Cheatsheet - FrontEnd30</a></p>
<h4 id="选择器的优先级"><a href="#选择器的优先级" class="headerlink" title="选择器的优先级"></a>选择器的优先级</h4><p><img src="/.%5CQ3%5Cimage-20230401185155310.png" alt="image-20230401185155310"></p>
<h4 id="选择器的构成"><a href="#选择器的构成" class="headerlink" title="选择器的构成"></a>选择器的构成</h4><p>选择器分为符号和框架</p>
<p>关系选择符：＄ ~ # ^等（可组合到框架中）</p>
<p>框架：[ ] , nth-of-child等 </p>
<h2 id="一-基本选择器"><a href="#一-基本选择器" class="headerlink" title="一.基本选择器"></a>一.基本选择器</h2><h3 id="id选择器"><a href="#id选择器" class="headerlink" title="id选择器"></a>id选择器</h3><ol>
<li><h6 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h6><ul>
<li>#id</li>
</ul>
</li>
<li><h6 id="易错点"><a href="#易错点" class="headerlink" title="易错点"></a>易错点</h6><ul>
<li>id不能有任何数字</li>
</ul>
</li>
</ol>
<h3 id="属性选择器"><a href="#属性选择器" class="headerlink" title="属性选择器"></a>属性选择器</h3><p><img src="C:\Users\11096\AppData\Roaming\Typora\typora-user-images\image-20230404152420883.png" alt="image-20230404152420883" style="zoom: 50%;" /><img src=".\Q3\image-20230404152441816.png" alt="image-20230404152441816" style="zoom:50%;" /></p>
<h6 id=""><a href="#" class="headerlink" title=""></a><img src=".\Q3\1680587935181.png" alt="1680587935181" style="zoom:50%;" /></h6><p>元素[属性1] [属性2]</p>
<ul>
<li>同时有两个选择的元素</li>
</ul>
<p>元素[属性&#x3D;值] 	</p>
<ul>
<li>属性的值&#x3D;值的元素</li>
<li>a[href&#x3D;”<a href="https://example.org"]">https://example.org&quot;]</a></li>
</ul>
<p>元素[属性^&#x3D;开头值]</p>
<ul>
<li>[attr^&#x3D;value]：表示带有以 <em>attr</em> 命名的属性，且属性值是以 <em>value</em> 开头的元素。</li>
</ul>
<p>元素[属性$&#x3D;结尾值]</p>
<ul>
<li><p>属性的值的结尾是”结尾值“的元素。</p>
</li>
<li><p>a[href$&#x3D;”.org”]：存在 href 属性并且属性值结尾是”.org”的 <a> 元素</p>
</li>
</ul>
<p>元素[属性*&#x3D;”值“]</p>
<ul>
<li>属性的值包含”值“的元素</li>
</ul>
<p>元素[属性~&#x3D;值]</p>
<ul>
<li><p>属性的值包含”值“的元素，该属性是一个以空格作为分隔的值列表</p>
</li>
<li><p>a[class~&#x3D;”logo”]：存在 class 属性并且属性值包含单词”logo”的<a>元素</p>
</li>
</ul>
<p>元素[       i]</p>
<ul>
<li>在属性选择器的右方括号前添加一个用空格隔开的字母 <code>i</code>（或 <code>I</code>），可以在匹配属性值时忽略大小写（支持 ASCII 字符范围之内的字母）。</li>
</ul>
<p>元素[		s]</p>
<ul>
<li>在属性选择器的右方括号前添加一个用空格隔开的字母 <code>s</code>（或 <code>S</code>），可以在匹配属性值时区分大小写（支持 ASCII 字符范围之内的字母）。</li>
</ul>
<h3 id="3-元素选择器"><a href="#3-元素选择器" class="headerlink" title="3.元素选择器"></a>3.元素选择器</h3><h4 id="通用元素选择器"><a href="#通用元素选择器" class="headerlink" title="通用元素选择器"></a>通用元素选择器</h4><ul>
<li></li>
</ul>
<p>**【【【【【【没有找到】】】】】】】</p>
<h4 id="同级元素通用选择器"><a href="#同级元素通用选择器" class="headerlink" title="同级元素通用选择器"></a>同级元素通用选择器</h4><img src=".\Q3\image-20230404151520256.png" alt="image-20230404151520256" style="zoom:50%;" />

<h4 id="多元素的组合选择器"><a href="#多元素的组合选择器" class="headerlink" title="多元素的组合选择器"></a>多元素的组合选择器</h4><img src=".\Q3\1680592298848.png" alt="1680592298848" style="zoom: 50%;" />

<h2 id="二-关系型选择器"><a href="#二-关系型选择器" class="headerlink" title="二.关系型选择器"></a>二.关系型选择器</h2><p>子选择器<img src=".\Q3\image-20230404132255364.png" alt="image-20230404132255364" style="zoom:50%;" /></p>
<p>后代选择器<img src=".\Q3\image-20230404132326607.png" alt="image-20230404132326607" style="zoom: 50%;" /></p>
<p>相邻兄弟选择器<img src=".\Q3\image-20230404133357624.png" alt="image-20230404133357624" style="zoom:50%;" /></p>
<p>通用兄弟选择<img src=".\Q3\image-20230404133450743.png" alt="image-20230404133450743" style="zoom:50%;" /></p>
<p><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/Column_combinator">列组合器</a> </p>
<p><code>||</code> 组合器选择属于某个表格行的节点。</p>
<p><strong>语法：</strong><code>A || B</code></p>
<p><strong>例子：</strong><code>col || td</code> 会匹配所有 作用域内的td元素。</p>
<p>独子选择器<img src=".\Q3\image-20230404133754657.png" alt="image-20230404133754657" style="zoom:50%;" />		a 表示选择a元素的独子，b表示如果b是独子则被选择</p>
<p>第 N 个最后一个子选择器<img src=".\Q3\image-20230404134515253.png" alt="image-20230404134515253" style="zoom:50%;" /></p>
<p>首项选择器<img src=".\Q3\image-20230404134548820.png" alt="image-20230404134548820" style="zoom:50%;" />可以根据元素、属性进行选择</p>
<p>尾项选择器<img src=".\Q3\image-20230404134901176.png" alt="image-20230404134901176" style="zoom:50%;" />尾属性的class不等于x则不选任何东西</p>
<h2 id="三-伪类选择器"><a href="#三-伪类选择器" class="headerlink" title="三.伪类选择器"></a>三.伪类选择器</h2><p>用户界面伪类选择器</p>
<img src=".\Q3\image-20230404150313528.png" alt="image-20230404150313528" style="zoom: 50%;" />

<img src=".\Q3\image-20230404150546942.png" alt="image-20230404150546942" style="zoom:50%;" />

<img src=".\Q3\image-20230404152535460.png" alt="image-20230404152535460" style="zoom:50%;" />

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">两个写法相同的选择器，意思为子元素的父元素的第n个子元素</span><br><span class="line">父元素 子元素：nth-child(1)</span><br><span class="line">父元素 子元素：first-child</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">/*意思是.dot的父元素的第二个孩子*/</span><br><span class="line">.bg2 .dot:nth-child(2)&#123;</span><br><span class="line">    align-self: flex-end;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>反选伪类选择器<img src=".\Q3\image-20230404135618254.png" alt="image-20230404135618254" style="zoom:50%;" /></p>
<p>看不懂</p>
<img src=".\Q3\image-20230404152643373.png" alt="image-20230404152643373" style="zoom: 50%;" />

<h2 id="四-伪元素选择器"><a href="#四-伪元素选择器" class="headerlink" title="四.伪元素选择器"></a>四.伪元素选择器</h2><img src=".\Q3\image-20230404150514659.png" alt="image-20230404150514659" style="zoom:50%;" />



<h2 id="五-易错点"><a href="#五-易错点" class="headerlink" title="五.易错点"></a>五.易错点</h2><p>1.~：写在[ ]里表示字符串匹配，匹配到就选择。写在[ ]外表示通用兄弟选择器。</p>
]]></content>
      <categories>
        <category>code</category>
        <category>note</category>
      </categories>
      <tags>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title>HTML学习笔记-1基础</title>
    <url>/2023/03/28/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/HTML/Q1-HTML-Note1/</url>
    <content><![CDATA[<h1>HTML学习笔记-1基础</h1>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1.&lt;标签名 属性1=“值1” 属性2=“值2”&gt;</span><br><span class="line">2.元素==标签+内容</span><br><span class="line">3.Dom树：文档对象模型，以树形的方式直观的表示标签嵌套结构</span><br><span class="line">4.html不区分大小写</span><br><span class="line">5.文档基础</span><br><span class="line">&lt;!DOCTYPE html&gt;:</span><br><span class="line">声明文档类型。需要包含它才能使其他东西正常工作。</span><br><span class="line"></span><br><span class="line">&lt;html&gt;&lt;/html&gt;:</span><br><span class="line">这个元素包裹了页面中所有的内容，有时被称为根元素。</span><br><span class="line"></span><br><span class="line">&lt;head&gt;&lt;/head&gt;:</span><br><span class="line">这个元素是一个容器，它包含了所有你想包含在 HTML 页面中但不在 HTML 页面中显示的内容。</span><br><span class="line">这些内容包括你想在搜索结果中出现的关键字和页面描述、CSS 样式、字符集声明等等。以后的章节中会学到更多相关的内容。</span><br><span class="line"></span><br><span class="line">&lt;meta charset=&quot;utf-8&quot;&gt;:</span><br><span class="line">    这个元素代表了不能由其他 HTML 元相关元素表示的元数据【描述html页面的数据】，比如 &lt;base&gt;、&lt;link&gt;、&lt;script&gt;、&lt;style&gt; 或 &lt;title&gt;。</span><br><span class="line"></span><br><span class="line">&lt;title&gt;&lt;/title&gt;:</span><br><span class="line">这设置了页面的标题，也就是出现在该页面加载的浏览器标签中的内容。当页面被加入书签时，页面标题也被用来描述该页面。</span><br><span class="line"></span><br><span class="line">&lt;body&gt;&lt;/body&gt;:</span><br><span class="line">包含了你访问页面时所有显示在页面上的内容，包含文本、图片、视频、游戏、可播放音频轨道等等。</span><br><span class="line"></span><br><span class="line">&lt;!--  ctrl+alt+L 格式化代码--&gt;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>code</category>
        <category>note</category>
      </categories>
      <tags>
        <tag>HTML</tag>
      </tags>
  </entry>
  <entry>
    <title>CSS学习笔记-2.1盒子、定位与布局</title>
    <url>/2023/04/01/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/CSS/Q3-CSS-1%E5%AE%9A%E4%BD%8D%E4%B8%8E%E5%B8%83%E5%B1%80/</url>
    <content><![CDATA[<h1 id="CSS学习笔记-2-1盒子、定位与布局-三种重要布局及其它布局"><a href="#CSS学习笔记-2-1盒子、定位与布局-三种重要布局及其它布局" class="headerlink" title="CSS学习笔记-2.1盒子、定位与布局-三种重要布局及其它布局"></a>CSS学习笔记-2.1盒子、定位与布局-三种重要布局及其它布局</h1><p><a href="https://www.icourse163.org/learn/BFU-1003382003?tid=1469987444#/learn/content?type=detail&id=1253020763&sm=1">Web前端开发_中国大学MOOC(慕课) (icourse163.org)</a></p>
<h2 id="布局三种定位机制："><a href="#布局三种定位机制：" class="headerlink" title="布局三种定位机制："></a>布局三种定位机制：</h2><p>文档流（元素分类inlineblock.元素类型转换display）→浮动（float属性）→层（position属性）</p>
<img src=".\Q3\1680613753098.png" alt="1680613753098" style="zoom:50%;" />

<h2 id="1-元素布局（终极布局，最好用）"><a href="#1-元素布局（终极布局，最好用）" class="headerlink" title="1.元素布局（终极布局，最好用）"></a>1.元素布局（终极布局，最好用）</h2><ol>
<li><h3 id="灵活-x2F-弹性-x2F-伸缩布局flex"><a href="#灵活-x2F-弹性-x2F-伸缩布局flex" class="headerlink" title="灵活&#x2F;弹性&#x2F;伸缩布局flex"></a>灵活&#x2F;弹性&#x2F;伸缩布局flex</h3><p><a href="https://www.bilibili.com/video/BV1Lp4y1S7XM/?spm_id_from=333.337.search-card.all.click&vd_source=ef1cf51b50e94d98e56cf1e5ecbbeb92">五分钟掌握 css3 flex弹性布局</a></p>
<p>Flex 布局教程：语法篇</p>
<p><a href="https://www.ruanyifeng.com/blog/2015/07/flex-grammar.html">https://www.ruanyifeng.com/blog/2015/07/flex-grammar.html</a></p>
<p>Flex 布局教程：实例篇</p>
<p><a href="https://www.ruanyifeng.com/blog/2015/07/flex-examples.html">https://www.ruanyifeng.com/blog/2015/07/flex-examples.html</a></p>
<p>小青蛙游戏学flex</p>
<p><a href="http://flexboxfroggy.com/">Flexbox Froggy - A game for learning CSS flexbox</a></p>
<h4 id="属性作用域分类："><a href="#属性作用域分类：" class="headerlink" title="属性作用域分类："></a>属性作用域分类：</h4><img src=".\Q3\image-20230406114818874.png" alt="image-20230406114818874" style="zoom: 25%;" />



<h4 id="易错点："><a href="#易错点：" class="headerlink" title="易错点："></a>易错点：</h4><ol>
<li><p>display：flex；</p>
<p>常用于有高度的类（body也能用）。且不能用于有其它display需求的类。（如inline-block）。</p>
</li>
<li><p>主轴侧轴的改变</p>
<p>当flex-derection的值改变时，两个轴也会跟着变，也就是说justify-content和align-items也要变。</p>
</li>
<li><p>flex的作用域</p>
<p>只有所在的类，所在类的子类都不算。比如body里写了的flex，justify只能控制body的布局，想控制内部元素的布局就只能嵌套，在.div里也写flex。</p>
</li>
<li><p><strong>弹性布局是一维的，网页是二维的</strong>，想要控制盒子，就需要父元素控制一个轴，子元素控制另一个轴。</p>
</li>
<li><p>弹性布局是可以嵌套的，祖宗元素设置display：flex，父元素也设置display：flex。</p>
</li>
</ol>
<h4 id="知识点："><a href="#知识点：" class="headerlink" title="知识点："></a>知识点：</h4><p>1.布局原理：采用 Flex 布局的元素，称为容器。它的所有子元素自动成为容器成员，称为项目。</p>
<p>2.易错点：父盒子设为 flex 后，子元素的float、clear和 vertical-align属性将失效。</p>
<p>3.flex布局父项常见属性<br>            <strong>flex-direction：</strong>设置主轴的方	</p>
<blockquote>
<p>​	   row：行    column：柱子</p>
</blockquote>
<img src=".\Q3\image-20230329190849686.png" alt="image-20230329190849686" style="zoom:50%;" />

<p>​			<strong>flex-wrap：</strong>设置子元素是否换行</p>
<p>​						nowrap 不换行	(装不下会缩小子元素的宽度)<br>​						wrap 换行</p>
<p>​			<strong>justify-content：</strong>设置<strong>主轴</strong>上的子元素排列方式【【【【【不分单行多行吗？】】】】】】</p>
<img src=".\Q3\image-20230329190910922.png" alt="image-20230329190910922" style="zoom:50%;" />


<p>​			<strong>align-items：</strong>设置<strong>辅轴</strong>上的子元素排列方式（单行）</p>
<p>​						该属性是控制子项在侧轴上的排列方式 在子项为单行的时候使用<br>​						flex-start 从头部开始<br>​						flex-end 从尾部开始<br>​						center 居中显示<br>​						stretch 拉伸      拉伸高度直至完整的占据父元素的高度。</p>
<p>​			<strong>align-content：</strong> 设置<strong>辅轴</strong>上的子元素的排列方式（多行）</p>
<p>​				<img src=".\Q3\image-20230329190910922.png" alt="image-20230329190910922" style="zoom: 50%;" /></p>
<p>​			align-content 和align-items区别<br>​						align-items 适用于单行情况下， 只有上对齐、下对齐、居中和 拉伸<br>​						align-content适用多行换行的情况（单行无效）</p>
<p>​			<strong>flex-flow：</strong>复合属性，相当于同时设置了 flex-direction 和 flex-wrap</p>
<p>3.flex布局子项常见属性【少用】<br>            flex子项目占的份数<br>            align-self控制子项自己在侧轴的排列方式<br>            order属性定义子项的排列顺序（前后顺序）<br>4.flex属性<br>            flex 属性定义子项目分配剩余空间，用flex来表示占多少份数。</p>
<p>​			<strong>【重点：flex：1；表示flex-grow1；&amp;&amp;  flex-shrink：1；</strong></p>
<p>​			<strong>意味着如果盒子剩余的布局大就自适应缩小，反之就自适应增大】</strong></p>
<p>5.align-self控制子项自己在侧轴上的排列方式【少用】<br>            align-self 属性允许单个项目有与其他项目不一样的对齐方式，可覆盖 align-items 属性。<br>            默认值为 auto，表示继承父元素的 align-items 属性，如果没有父元素，则等同于 stretch。</p>
</li>
<li><h3 id="网格布局Grid"><a href="#网格布局Grid" class="headerlink" title="网格布局Grid"></a>网格布局Grid</h3><p><a href="https://www.runoob.com/css3/css-grid.html">CSS 网格布局 | 菜鸟教程 (runoob.com)</a></p>
<h4 id="属性作用域分类：-1"><a href="#属性作用域分类：-1" class="headerlink" title="属性作用域分类："></a>属性作用域分类：</h4><img src=".\Q3\image-20230406160133663.png" alt="image-20230406160133663" style="zoom:50%;" /></li>
</ol>
<h4 id="知识点：-1"><a href="#知识点：-1" class="headerlink" title="知识点："></a>知识点：</h4><p>​					<img src=".\Q3\image-20230406160552994.png" alt="image-20230406160552994" style="zoom: 25%;" /></p>
<h1 id="2-文档流定位（默认布局）"><a href="#2-文档流定位（默认布局）" class="headerlink" title="2.文档流定位（默认布局）"></a>2.文档流定位（默认布局）</h1><h1 id="（元素分类inlineblock-元素类型转换display）"><a href="#（元素分类inlineblock-元素类型转换display）" class="headerlink" title="（元素分类inlineblock.元素类型转换display）"></a>（元素分类inlineblock.元素类型转换display）</h1><p>元素分类：</p>
<p>​			inline：两个inline元素之间会有一个间隙，需要去除。</p>
<p>​			block：</p>
<p>​			inline-block：</p>
<p>元素转换：</p>
<h1 id="3-浮动定位"><a href="#3-浮动定位" class="headerlink" title="3.浮动定位"></a>3.浮动定位</h1><h4 id="float属性值："><a href="#float属性值：" class="headerlink" title="float属性值："></a>float属性值：</h4><p>​			1.left</p>
<p>​			2.right</p>
<p>​			3.top</p>
<p>​			4.bottom</p>
<h4 id="应用："><a href="#应用：" class="headerlink" title="应用："></a>应用：</h4><h4 id=""><a href="#" class="headerlink" title=""></a><img src=".\Q3\image-20230405161130046.png" alt="image-20230405161130046" style="zoom: 33%;" /><img src="C:\Users\11096\AppData\Roaming\Typora\typora-user-images\image-20230405161204082.png" alt="image-20230405161204082" style="zoom:33%;" /><img src="C:\Users\11096\AppData\Roaming\Typora\typora-user-images\image-20230405161227150.png" alt="image-20230405161227150" style="zoom: 25%;" /></h4><h4 id="易错点：1注意浮动时，宽度是否够用的情况"><a href="#易错点：1注意浮动时，宽度是否够用的情况" class="headerlink" title="易错点：1注意浮动时，宽度是否够用的情况"></a>易错点：1注意浮动时，宽度是否够用的情况</h4><p>​					<img src="C:\Users\11096\AppData\Roaming\Typora\typora-user-images\image-20230405161350930.png" alt="image-20230405161350930" style="zoom: 25%;" /><img src=".\Q3\image-20230405161312570.png" alt="image-20230405161312570" style="zoom: 25%;" /></p>
<h4 id="易错点：2浮动与flex互斥"><a href="#易错点：2浮动与flex互斥" class="headerlink" title="易错点：2浮动与flex互斥"></a>易错点：2浮动与flex互斥</h4><h4 id="clear清除浮动："><a href="#clear清除浮动：" class="headerlink" title="clear清除浮动："></a>clear清除浮动：</h4><p>​	易错点：清除某一方向的浮动不是把某方向上的浮动元素删除，</p>
<p>​								而是该元素的某一方向不能有浮动元素。也就是说，该元素会另起一行。</p>
<p>​	属性值：both（两侧）left right</p>
<p>​	举例：</p>
<p>​			单向清除浮动举例<img src=".\Q3\image-20230405165442568.png" alt="image-20230405165442568" style="zoom:25%;" /></p>
<p>​			both清除浮动举例</p>
<p>​											<img src="C:\Users\11096\AppData\Roaming\Typora\typora-user-images\image-20230405165348256.png" alt="image-20230405165348256" style="zoom:25%;" /><img src=".\Q3\image-20230405165322218.png" alt="image-20230405165322218" style="zoom: 25%;" /></p>
<h4 id="float总结："><a href="#float总结：" class="headerlink" title="float总结："></a>float总结：</h4><p>​		1.浮动定位是在同一层面的，可以两个都设置成向左浮动或者一个向左一个向右，来实现同样的效果。 </p>
<p>​		2.清除浮动不是删除元素，相当于另起一行的效果 。</p>
<p>​		3.实现几行几列的效果，最初用的都是浮动。想要实现分行，就用清除浮动，想要实现分列，就用增加浮动。</p>
<h1 id="4-层定位"><a href="#4-层定位" class="headerlink" title="4.层定位"></a>4.层定位</h1><h4 id="1-position属性"><a href="#1-position属性" class="headerlink" title="1.position属性"></a>1.position属性</h4><p><a href="https://www.w3school.com.cn/css/css_positioning.asp">CSS 布局 - position 属性 (w3school.com.cn)</a></p>
<p>​	概念：</p>
<p>​		<code>position</code> 属性规定应用于元素的定位方法的类型。</p>
<p>​	四个不同的平面定位属性：</p>
<p>​		top bottom left right</p>
<p>​	一个层叠定位属性：</p>
<p>​		z-index：哪个元素应放置在其他元素的前面或后面，正负都可，取值大的在上方。</p>
<p>​	五种不同的定位方式：</p>
<p>​		static（无定位，还是文件流模式定位）</p>
<p>​						易错点：top bottom left right z-index无效。</p>
<p>​		fixed（固定定位，相对于浏览器窗口进行定位）</p>
<p>​										<strong>用于侧边栏</strong></p>
<p>​										<strong>易错点：必须设置宽度高度，因为旧有的框架被position打破了。记得设置成100%</strong></p>
<p>​		relative（相对定位，相对于直接父元素进行定位，不管直接父元素是什么定位方式）</p>
<p>​						易错点：偏移后，偏移前的位置依然被保留，所以不会有其它元素自动占据它原来的位置。</p>
<p>​										如果附近有块级元素，它的相对定位会被影响。</p>
<p>​		absolute（绝对定位，从直接父元素开始向外层查找，</p>
<p>​						直到找到不是static定位的父元素。如果都是static，则相对于body进行定位）</p>
<p>​						易错点：偏移后，偏移前的位置不再被保留，所以会有其它元素自动占据它原来的位置。</p>
<p>​		sticky（粘性定位，根据用户的滚动位置进行定位）</p>
<p>​						适用于：导航栏本身并不在网页的边边上，在文章中间。直到用户下拉页面，使导航栏到了边边上，为了继续展示导航栏，导航栏就会附着在边上。不是这种情况的话，relative就行了。</p>
<p>​										<strong>用于吸顶吸底广告</strong>。</p>
<p>​										兼容性<a href="https://caniuse.com/?search=position:sticky;">“position:sticky;” | Can I use… Support tables for HTML5, CSS3, etc</a></p>
<p>​	粘性定位与固定定位的区别：</p>
<p>​					<a href="https://blog.csdn.net/weixin_51093047/article/details/126923647"> 固定定位（fixed）和粘性定位（sticky）的比较-CSDN博客</a>						</p>
<p>​					粘性定位算在文档流中，固定定位不算。所以固定的小广告会挡视线，粘性的不会</p>
<p>​	总结：</p>
<p>​					祖宗元素相对定位，子孙元素全部绝对定位。这样保证更改祖宗元素时，子孙元素都能跟它一起动。</p>
<p>​	实例：</p>
<p>​					<a href="https://juejin.cn/post/7175552665974210615">CSS固定定位与粘性定位4大企业级案例 - 掘金 (juejin.cn)</a></p>
<h1 id="3-盒子模型"><a href="#3-盒子模型" class="headerlink" title="3.盒子模型"></a>3.盒子模型</h1><p><a href="https://developer.mozilla.org/zh-CN/docs/Learn/CSS/Building_blocks/The_box_model">盒模型 - 学习 Web 开发 | MDN</a></p>
<p>内边距:   <strong>padding</strong></p>
<p>​                padding-left&#x2F;right&#x2F;top&#x2F;bottom:20px;  </p>
<p>​				padding:10px;（上下左右都是10）</p>
<p>​				<a href="https://www.w3school.com.cn/cssref/pr_padding.asp">CSS padding 属性更多用法</a></p>
<p>框架：<strong>border</strong></p>
<p>​				框架为宽度50px的实心黑色，border: 50px <strong>solid</strong> black;</p>
<p>外边距：   <strong>margin</strong></p>
<p>​                水平居中:margin-left: auto; &amp;&amp; margin-right: auto;</p>
<p>​				可用于块级标签，p、div等。</p>
<p>​                去除默认边框宽度：margin：0；（font-size：0是为了解决多余空白符的问题）</p>
<p>​                缩小上方过大的宽度： margin-top:-25px;（需要来回调试）</p>
<p>盒子大小：box-sizing</p>
<p>CSS3中对盒子进行2D变换的属性：<strong>transform</strong></p>
<p>​				旋转：**transform:rotate(30deg);**顺时针旋转30度。transform:rotate(-30deg);逆时针旋转30度。</p>
<p>​				缩放：<strong>transform:scale(x,y);</strong></p>
<p>​							xy取值范围为 【0-1缩小】 【1 ~ +∞放大】</p>
<h5 id="盒子种类"><a href="#盒子种类" class="headerlink" title="盒子种类:"></a>盒子种类:</h5><img src=".\Q3\image-20230404195037016.png" alt="image-20230404195037016" style="zoom:50%;" />

<h5 id="两种盒模型的区别："><a href="#两种盒模型的区别：" class="headerlink" title="两种盒模型的区别："></a>两种盒模型的区别：</h5><p>​		分别定义了user agent应该如何计算一个元素的总宽度和总高度的方法</p>
<ul>
<li>box-sizing：<code>content-box</code> 是默认值。如果你设置一个元素的宽为 100px，那么这个元素的内容区会有 100px 宽，并且任何边框和内边距的宽度都会被增加到最后绘制出来的元素宽度中。</li>
<li>box-sizing：<code>border-box</code> 告诉浏览器：你想要设置的边框和内边距的值是包含在 width 内的。也就是说，如果你将一个元素的 width 设为 100px，那么这 100px 会包含它的 border 和 padding，内容区的实际宽度是 width 减去 (border + padding) 的值。大多数情况下，这使得我们更容易地设定一个元素的宽高。</li>
</ul>
<h5 id="盒子相关的问题："><a href="#盒子相关的问题：" class="headerlink" title="盒子相关的问题："></a>盒子相关的问题：</h5><p>​		<a href="https://zhuanlan.zhihu.com/p/110617108">CSS 的两种盒模型 - 及边距异常合并问题</a></p>
<h4 id="outline和border的区别"><a href="#outline和border的区别" class="headerlink" title="outline和border的区别"></a>outline和border的区别</h4><p>​	主要区别在于: </p>
<p>​		1.应用场景:一般border能适用于任何元素的样式，outline针对链接、表单控件和ImageMap等元素设计(比如input&#x2F;textarea) </p>
<p>​		2.特性不一样：border一般会被计算在元素的宽高大小里面，影响元素的尺寸、位置。outline不会</p>
<p>​		3.outline 的效果将随元素的 focus 而自动出现，相应的由 blur 而自动消失，常设置悬停的动态效果。</p>
<h3 id="相关层次图"><a href="#相关层次图" class="headerlink" title="相关层次图"></a>相关层次图</h3><p>​	margin：外边距</p>
<p>​	border：边框</p>
<p>​	outline：边框</p>
<p>​	padding：内边距</p>
<img src=".\Q3\image-20230329124305228.png" alt="image-20230329124305228" style="zoom: 33%;" />
]]></content>
      <categories>
        <category>code</category>
        <category>note</category>
      </categories>
      <tags>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title>CSS学习笔记-2.3flex布局实现</title>
    <url>/2023/04/01/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/CSS/Q3-CSS-3%E5%AE%9E%E8%B7%B5%EF%BC%88flex%E5%B8%83%E5%B1%80%EF%BC%89/</url>
    <content><![CDATA[<h1 id="CSS学习笔记-2-3实践"><a href="#CSS学习笔记-2-3实践" class="headerlink" title="CSS学习笔记-2.3实践"></a>CSS学习笔记-2.3实践</h1><p><a href="https://www.bilibili.com/video/BV1Lp4y1S7XM/?spm_id_from=333.337.search-card.all.click&vd_source=ef1cf51b50e94d98e56cf1e5ecbbeb92">五分钟掌握 css3 flex弹性布局</a></p>
<p>Flex 布局教程：语法篇</p>
<p><a href="https://www.ruanyifeng.com/blog/2015/07/flex-grammar.html">https://www.ruanyifeng.com/blog/2015/07/flex-grammar.html</a></p>
<p>Flex 布局教程：实例篇</p>
<p><a href="https://www.ruanyifeng.com/blog/2015/07/flex-examples.html">https://www.ruanyifeng.com/blog/2015/07/flex-examples.html</a></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang=&quot;en&quot;&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">  &lt;meta charset=&quot;UTF-8&quot;&gt;</span><br><span class="line">  &lt;title&gt;Title&lt;/title&gt;</span><br><span class="line">  &lt;link  rel=&quot;stylesheet&quot; href=&quot;../CSS/实践二参考答案.css&quot;&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;!--</span><br><span class="line">/*1水平垂直居中*/</span><br><span class="line">/*2第一个点不动，第二个点用水平垂直flex-end*/</span><br><span class="line">/*3第一个点不动，第二个点水平垂直居中，第三个点用水平垂直flex-end*/</span><br><span class="line">/*4第一个第二个点用between分开，第三四个用垂直end且between*/</span><br><span class="line">/*5上一个的基础上加上一个水平垂直居中的*/</span><br><span class="line">/*6三个between / 自动换行且between / 挨个设置横纵轴位置*/</span><br><span class="line"></span><br><span class="line">/*1水平垂直居中*/</span><br><span class="line">/*2水平垂直flex-end*/</span><br><span class="line">/*3between*/</span><br><span class="line">/*4水平垂直且between*/</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">以上内容，不用self无法实现</span><br><span class="line">--&gt;</span><br><span class="line"></span><br><span class="line">&lt;body&gt;</span><br><span class="line">  &lt;div class=&quot;first-face&quot;&gt;</span><br><span class="line">    &lt;span class=&quot;pip&quot;&gt;&lt;/span&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  &lt;div class=&quot;second-face&quot;&gt;</span><br><span class="line">    &lt;span class=&quot;pip&quot;&gt;&lt;/span&gt;</span><br><span class="line">    &lt;span class=&quot;pip&quot;&gt;&lt;/span&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&lt;div class=&quot;third-face&quot;&gt;</span><br><span class="line">  &lt;span class=&quot;pip&quot;&gt;&lt;/span&gt;</span><br><span class="line">  &lt;span class=&quot;pip&quot;&gt;&lt;/span&gt;</span><br><span class="line">  &lt;span class=&quot;pip&quot;&gt;&lt;/span&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&lt;div class=&quot;fourth-face&quot;&gt;</span><br><span class="line">  &lt;div class=&quot;column&quot;&gt;</span><br><span class="line">    &lt;span class=&quot;pip&quot;&gt;&lt;/span&gt;</span><br><span class="line">    &lt;span class=&quot;pip&quot;&gt;&lt;/span&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line"></span><br><span class="line">  &lt;div class=&quot;column&quot;&gt;</span><br><span class="line">    &lt;span class=&quot;pip&quot;&gt;&lt;/span&gt;</span><br><span class="line">    &lt;span class=&quot;pip&quot;&gt;&lt;/span&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&lt;div class=&quot;fifth-face&quot;&gt;</span><br><span class="line">  &lt;div class=&quot;column&quot;&gt;</span><br><span class="line">    &lt;span class=&quot;pip&quot;&gt;&lt;/span&gt;</span><br><span class="line">    &lt;span class=&quot;pip&quot;&gt;&lt;/span&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line"></span><br><span class="line">  &lt;div class=&quot;column&quot;&gt;</span><br><span class="line">    &lt;span class=&quot;pip&quot;&gt;&lt;/span&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">  &lt;div class=&quot;column&quot;&gt;</span><br><span class="line">    &lt;span class=&quot;pip&quot;&gt;&lt;/span&gt;</span><br><span class="line">    &lt;span class=&quot;pip&quot;&gt;&lt;/span&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&lt;div class=&quot;sixth-face&quot;&gt;</span><br><span class="line">  &lt;div class=&quot;column&quot;&gt;</span><br><span class="line">    &lt;span class=&quot;pip&quot;&gt;&lt;/span&gt;</span><br><span class="line">    &lt;span class=&quot;pip&quot;&gt;&lt;/span&gt;</span><br><span class="line">    &lt;span class=&quot;pip&quot;&gt;&lt;/span&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line"></span><br><span class="line">  &lt;div class=&quot;column&quot;&gt;</span><br><span class="line">    &lt;span class=&quot;pip&quot;&gt;&lt;/span&gt;</span><br><span class="line">    &lt;span class=&quot;pip&quot;&gt;&lt;/span&gt;</span><br><span class="line">    &lt;span class=&quot;pip&quot;&gt;&lt;/span&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br><span class="line"></span><br><span class="line">&lt;!--【为什么写div的话，再写flex就没有用了？因为是块级元素，flex只能作用于内联样式得元素，所以要display：inline-block】--&gt;</span><br><span class="line">&lt;!--【【【【【【【为什么把dotdiv改成span后，除了只有一个点的，其它得一个点都没有？】】】】】--&gt;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.first-face &#123;</span><br><span class="line">    display: flex;</span><br><span class="line">    justify-content: center;</span><br><span class="line">    align-items: center;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.second-face &#123;</span><br><span class="line">    display: flex;</span><br><span class="line">    justify-content: space-between;</span><br><span class="line">&#125;</span><br><span class="line">/*nth-child(n) 选择器：选择其父元素的第n个子元素*/</span><br><span class="line">.second-face .pip:nth-of-type(2) &#123;</span><br><span class="line">    align-self: flex-end;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.third-face &#123;</span><br><span class="line">    display: flex;</span><br><span class="line">    justify-content: space-between;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.third-face .pip:nth-of-type(2) &#123;</span><br><span class="line">    align-self: center;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.third-face .pip:nth-of-type(3) &#123;</span><br><span class="line">    align-self: flex-end;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.fourth-face, .sixth-face &#123;</span><br><span class="line">    display: flex;</span><br><span class="line">    justify-content: space-between;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.fourth-face .column, .sixth-face .column &#123;</span><br><span class="line">    display: flex;</span><br><span class="line">    flex-direction: column;</span><br><span class="line">    justify-content: space-between;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.fifth-face &#123;</span><br><span class="line">    display: flex;</span><br><span class="line">    justify-content: space-between;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.fifth-face .column &#123;</span><br><span class="line">    display: flex;</span><br><span class="line">    flex-direction: column;</span><br><span class="line">    justify-content: space-between;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.fifth-face .column:nth-of-type(2) &#123;</span><br><span class="line">    justify-content: center;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/* OTHER STYLES */</span><br><span class="line"></span><br><span class="line">* &#123;</span><br><span class="line">    box-sizing: border-box;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">html, body &#123;</span><br><span class="line">    height: 100%;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">body &#123;</span><br><span class="line">    display: flex;</span><br><span class="line">    align-items: center;</span><br><span class="line">    justify-content: center;</span><br><span class="line">    vertical-align: center;</span><br><span class="line">    flex-wrap: wrap;</span><br><span class="line">    align-content: center;</span><br><span class="line">    font-family: &#x27;Open Sans&#x27;, sans-serif;</span><br><span class="line"></span><br><span class="line">    background: linear-gradient(top, #222, #333);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/*这是什么选择器*/</span><br><span class="line">[class$=&quot;face&quot;] &#123;</span><br><span class="line">    margin: 16px;</span><br><span class="line">    padding: 4px;</span><br><span class="line"></span><br><span class="line">    background-color: #e7e7e7;</span><br><span class="line">    width: 104px;</span><br><span class="line">    height: 104px;</span><br><span class="line">    object-fit: contain;</span><br><span class="line"></span><br><span class="line">    /*insert 不会用*/</span><br><span class="line">    box-shadow:</span><br><span class="line">            inset 0 5px white,</span><br><span class="line">            inset 0 -5px #bbb,</span><br><span class="line">            inset 5px 0 #d7d7d7,</span><br><span class="line">            inset -5px 0 #d7d7d7;</span><br><span class="line"></span><br><span class="line">    border-radius: 10%;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.pip &#123;</span><br><span class="line">    display: block;</span><br><span class="line">    width: 24px;</span><br><span class="line">    height: 24px;</span><br><span class="line">    border-radius: 50%;</span><br><span class="line">    margin: 4px;</span><br><span class="line"></span><br><span class="line">    background-color: #333;</span><br><span class="line">    box-shadow: inset 0 3px #111, inset 0 -3px #555;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>code</category>
        <category>note</category>
      </categories>
      <tags>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title>HTML学习笔记-3进阶标签与属性</title>
    <url>/2023/03/28/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/HTML/Q1-HTML-Note3/</url>
    <content><![CDATA[<h1 id="HTML学习笔记-3进阶标签与属性"><a href="#HTML学习笔记-3进阶标签与属性" class="headerlink" title="HTML学习笔记-3进阶标签与属性"></a>HTML学习笔记-3进阶标签与属性</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1.超链接     	&lt;a href=&quot;网址&quot; target=&quot;_blank&quot; &gt; 文字或图片 &lt;/a&gt;</span><br><span class="line"> 注：href就是属性的一种</span><br><span class="line"></span><br><span class="line">2.内联元素与块级元素</span><br><span class="line"> 内联：不会自动换行，比如em、strong、input、button。也就是说。如果不特意指定button的作用的话，如果input、button相邻，button就会被默认关联在input上。</span><br><span class="line"> 块级：会自动换行，比如p、fieldset。注：section跟他们有点像,不管什么东西，都要记得用section包裹。</span><br><span class="line">【【【【【【【&lt;article&gt;是干什么用的？？】】】】】</span><br><span class="line">&lt;article&gt; 标签规定独立的自包含内容。</span><br><span class="line">一篇文章应有其自身的意义，应该有可能独立于站点的其余部分对其进行分发。【【【分发是什么意思】】】</span><br><span class="line">&lt;article&gt; 元素的潜在来源：</span><br><span class="line">论坛帖子</span><br><span class="line">报纸文章</span><br><span class="line">博客条目</span><br><span class="line">用户评论】</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">11.内容分块元素      &lt;section&gt;&lt;/section&gt;</span><br><span class="line">section 元素的使用禁忌如下：</span><br><span class="line">.不要将section元素用作设置样式的页面容器，那是div的工作；</span><br><span class="line">.如果article元素或者aside元素或者nav元素更符合使用条件，不要使用section元素；</span><br><span class="line">.不要为没有标题的内容区块使用section元素；</span><br><span class="line"></span><br><span class="line">3.空元素/自闭合元素</span><br><span class="line">  比如&lt;img&gt; &lt;input&gt;</span><br><span class="line">4.属性与布尔属性</span><br><span class="line">  属性：元素的附加限定。用于控制这个元素的行为。</span><br><span class="line">  布尔属性：用布尔值来代表“是否”允许元素做什么事</span><br><span class="line"> eg.输入框   使用 disabled 属性来禁止在输入框里输入</span><br><span class="line">          	&lt;input type=&quot;text&quot; disabled /&gt;</span><br><span class="line">          	下面这个输入框不包含 disabled 属性，所以用户可以向其中输入</span><br><span class="line">        	&lt;input type=&quot;text&quot; /&gt;</span><br><span class="line"></span><br><span class="line">6.特殊字符的引用     https://zh.wikipedia.org/wiki/XML%E4%B8%8EHTML%E5%AD%97%E7%AC%A6%E5%AE%9E%E4%BD%93%E5%BC%95%E7%94%A8%E5%88%97%E8%A1%A8</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">12.无/有序列表        &lt;ul&gt;   &lt;li&gt;&lt;/li&gt; &lt;li&gt;&lt;/li&gt;   &lt;/ul&gt;</span><br><span class="line">                    &lt;ol&gt;   &lt;li&gt;&lt;/li&gt; &lt;li&gt;&lt;/li&gt;   &lt;/ol&gt;</span><br><span class="line"></span><br><span class="line">13.全局属性</span><br><span class="line">13.1id</span><br><span class="line">        id 属性用于标识特定的 HTML 元素。 每个 id 属性的值必须不同于整个页面的所有其他 id 值。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">表单相关</span><br><span class="line">14.表单（接下来的东西都与表单有关）             &lt;form action=&quot;/页面地址&quot; required&gt;&lt;/form&gt;</span><br><span class="line">   # form表单元素，用来收集来自用户的信息</span><br><span class="line">   # action属性，就是我需要把这表单信息提交到后台，action相当于指明哪个接口。例如，&lt;form action=&quot;http://localhost:30/form-submit&quot;&gt;&lt;/form&gt; 告诉浏览器应该将表单数据发送到路径/submit-url</span><br><span class="line">   # required属性，用于防止用户不输入信息也能提交。</span><br><span class="line">    不过现在form的action用的比较少了，了解一下action属性的用途就行</span><br><span class="line">    一般我们实际开发很少用action去发送请求，而是收集表单数据，用fetch之类去发送给后端（js）</span><br><span class="line"></span><br><span class="line">15.可点击的按钮      &lt;button&gt;&lt;/button&gt;</span><br><span class="line">单击没有任何属性的表单按钮的默认行为，会将表单提交到表单的 action 属性中指定的位置。</span><br><span class="line">【一般来说是一个form里面有一个type为submit的按钮。这个按钮的作用就是把form表单的数据进行提交。</span><br><span class="line">即使你在文本输入下方添加了按钮，它们也会在页面上彼此相邻。 这是因为 input 和 button 元素都是内联元素，它们不会出现在新的行上。</span><br><span class="line">你添加的按钮将默认提交表单。 然而，依赖默认行为可能造成混乱。 type=“submit” 添加到 button 以明确它是一个提交按钮。】</span><br><span class="line"></span><br><span class="line">16.单选按钮值  radio</span><br><span class="line">radio是input标签中，type属性的一种值。比如&lt;input type=&quot;radio&quot;&gt;</span><br><span class="line">重点：想要实现几个单选按钮互斥（如男女），就要把两个单选按钮所在的index加上相同的name属性.</span><br><span class="line">          &lt;label&gt;&lt;input id=&quot;indoor&quot; type=&quot;radio&quot; name=&quot;indoor-outdoor&quot;&gt; Indoor&lt;/label&gt;</span><br><span class="line">          &lt;label&gt;&lt;input id=&quot;outdoor&quot; type=&quot;radio&quot; name=&quot;indoor-outdoor&quot;&gt; Outdoor&lt;/label&gt;</span><br><span class="line"></span><br><span class="line">17.给某一块增加实线框用的块级标签     &lt;fieldset&gt;&lt;/fieldset&gt;</span><br><span class="line">      相当于表单分块，会形成一个实线框框。不分块就会默认分出超级多的块，乱的要死。 fieldset 元素是块级元素，这意味着它们出现在新的一行上。</span><br><span class="line">17.1 fieldset 元素中内容的标题      &lt;legend&gt;文字提示&lt;/legend&gt;</span><br><span class="line">      会在fieldset形成的实现框之上，显示文字。一般用于提示用户应该输入什么样的数据。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">图片相关：img figure figcaption</span><br><span class="line">8.图片标签                     &lt;img src=&quot;地址&quot; alt=&quot;代替地址所显示的文本&quot;&gt;</span><br><span class="line">    所有的 img 元素都应该有一个 alt 属性。 alt 属性的文本（值）有两个作用，</span><br><span class="line">    第一个作用是让屏幕阅读器可以知晓图片的内容，这会对网页的可访问性有很大提升；另一个作用是当图片无法加载时，页面需要显示的替代文本。</span><br><span class="line">9.独立的内容                 &lt;figure&gt;&lt;/figure&gt;</span><br><span class="line">图像，并允许你将图像与标题相关联。</span><br><span class="line">10.图像标题                  &lt;figcaption&gt;&lt;/&gt;figcaption&gt;</span><br><span class="line">用于描述 figure 元素中包含的图像,比如某张图的标题叫“图1”。</span><br><span class="line"> &lt;figure&gt;</span><br><span class="line">          &lt;img src=&quot;链接&quot; alt=&quot;文字&quot;&gt;</span><br><span class="line">          &lt;figcaption&gt;Cats love lasagna.&lt;/figcaption&gt;</span><br><span class="line"> &lt;/figure&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">输入相关</span><br><span class="line">5.输入框     &lt;input&gt;</span><br><span class="line">    最复杂的标签，以下为常用属性</span><br><span class="line">    #type=“text”                  待输入数据类型为text文字</span><br><span class="line">    </span><br><span class="line">    #type=“radio”                 单选项</span><br><span class="line">            1.使文本与radio绑定的方法</span><br><span class="line">            &lt;label&gt;&lt;input type=&quot;radio&quot;&gt;Indoor&lt;/label&gt;表示有一个单选项Indoor</span><br><span class="line">            </span><br><span class="line">    #type=&quot;checkbox&quot;       复选框</span><br><span class="line">            使文本与checkbox绑定的方法</span><br><span class="line">            1.id与for      &lt;input id=&quot;loving&quot; type=&quot;checkbox&quot;&gt;  </span><br><span class="line">            			   &lt;label for=&quot;loving&quot;&gt;Loving&lt;/label&gt;</span><br><span class="line">            			   </span><br><span class="line">    #&lt;label&gt;&lt;/label&gt;     包裹含有radio/checkbox属性的input元素。</span><br><span class="line">                         【一句input一对儿label。】</span><br><span class="line">                         用于将 input 元素与其近邻的文本进行绑定，达到点击文本也能单选的效果。</span><br><span class="line">                         </span><br><span class="line">    #checked属性         使复选框或单选按钮默认被选中</span><br><span class="line"></span><br><span class="line">    #name               name是给后端人员搜索用的，id是给前端人员写代码用的。</span><br><span class="line">                        【input这一类属于原生的控件，</span><br><span class="line">                        name属性的主要作用就是用来在发送的时候作为url拼接，</span><br><span class="line">                        拼接成查询条件，可以理解成：后端需要什么查询条件，前端的传对应的name】</span><br><span class="line">                        主要是用于用户提交时，将自动拼接给程序员看</span><br><span class="line">                        （注：多个input有同一个name会使他们互斥）</span><br><span class="line">                        </span><br><span class="line">    #placeholder         占位符（提示用户该输入什么）</span><br><span class="line">    </span><br><span class="line">    #value               默认值（如果用户不输入，就提交默认值）</span><br><span class="line"></span><br><span class="line">    注：&lt;input type=&quot;radio&quot;&gt;Indoor表示有一个单选项Indoor</span><br><span class="line">    注：&lt;input type=&quot;checkbox&quot;&gt; Loving请确保元素和文本之间有一个空格。</span><br><span class="line">    教程：https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/input#attr-disabled</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">6.文字相关</span><br><span class="line">	分割线：&lt;hr&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>code</category>
        <category>note</category>
      </categories>
      <tags>
        <tag>HTML</tag>
      </tags>
  </entry>
  <entry>
    <title>HTML学习笔记-2基础标签</title>
    <url>/2023/03/28/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/HTML/Q1-HTML-Note2/</url>
    <content><![CDATA[<h1>HTML学习笔记-2基础标签</h1>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0.定义预格式化的文本         &lt;pre&gt;&lt;/pre&gt;    比如以下内容中，空格空行都会保留</span><br><span class="line">1.空格与段内换行            &amp;nbsp;&lt;br/&gt;</span><br><span class="line"> 无论你在 HTML 元素的内容中使用多少空格（包括一个或多个空白字符或换行），</span><br><span class="line"> 当渲染这些代码的时候，HTML 解释器会将连续出现的空白字符减少为一个单独的空格符。</span><br><span class="line">2.行内组合                &lt;span&gt;&lt;/span&gt;</span><br><span class="line">3.水平线                  &lt;hr/&gt;</span><br><span class="line">4.段                     &lt;p&gt;&lt;/p&gt;</span><br><span class="line">5.强调      &lt;strong&gt;&lt;/strong&gt;</span><br><span class="line">6.斜体      &lt;em&gt;&lt;/em&gt;</span><br><span class="line">7.n级标题                 &lt;h1&gt;一级标题只能有一个&lt;/h1&gt;</span><br><span class="line">8.标识页面的主要部分  &lt;main&gt;&lt;/main&gt;</span><br><span class="line">    HTML5 有些元素能够指明不同的内容区域。</span><br><span class="line">     这些元素能让你的 HTML 易于阅读，并有助于搜索引擎优化（SEO）和无障碍访问。</span><br><span class="line">9.表示预定义格式文本		&lt;pre&gt;&lt;/pre&gt;</span><br><span class="line">--&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;pre&gt;</span><br><span class="line"></span><br><span class="line">    &lt;p&gt;1.空格与换行</span><br><span class="line">        这里将会有三个空格&amp;nbsp;&amp;nbsp;&amp;nbsp;然后换行</span><br><span class="line">        &lt;br/&gt;</span><br><span class="line">        换行结束</span><br><span class="line">    &lt;/p&gt;</span><br><span class="line">    &lt;p&gt;2.行内组合</span><br><span class="line">        这里的&lt;span&gt;标签用于标记，被标记的文字将可以通过css进行格式化的美化&lt;/span&gt;</span><br><span class="line">    &lt;/p&gt;</span><br><span class="line"></span><br><span class="line">    &lt;p&gt;3.hr水平线</span><br><span class="line">        以下是水平线</span><br><span class="line">      &lt;hr/&gt;</span><br><span class="line">      水平线结束</span><br><span class="line">    &lt;/p&gt;</span><br><span class="line">&lt;/pre&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>code</category>
        <category>note</category>
      </categories>
      <tags>
        <tag>HTML</tag>
      </tags>
  </entry>
  <entry>
    <title>HTML学习笔记-4head</title>
    <url>/2023/03/28/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/HTML/Q1-HTML-Note4/</url>
    <content><![CDATA[<h1 id="HTML学习笔记-4head"><a href="#HTML学习笔记-4head" class="headerlink" title="HTML学习笔记-4head"></a>HTML学习笔记-4head</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;!--</span><br><span class="line"></span><br><span class="line">&lt;meta &gt;:</span><br><span class="line">    name 指定了 meta 元素的类型；说明该元素包含了什么类型的信息。</span><br><span class="line">    content 指定了实际的元数据内容【就是搜索网页时，标题下面的一连串简述】。</span><br><span class="line"></span><br><span class="line">    &lt; meta name=&quot;author&quot; content=&quot;Chris Mills&quot; /&gt;</span><br><span class="line">    &lt;meta name=&quot;description&quot; content=&quot;The MDN Web &quot; /&gt;</span><br><span class="line"></span><br><span class="line">     比如搜索MDN Web Docs会显示</span><br><span class="line">     标题：MDN Web Docs</span><br><span class="line">     链接：https://developer.mozilla.org/zh</span><br><span class="line">     简述：The MDN Web</span><br><span class="line"></span><br><span class="line">&lt;link&gt;:</span><br><span class="line">    &lt;link&gt; 用来添加CSS。link元素经常位于文档的头部，</span><br><span class="line">    rel=&quot;stylesheet&quot; 表明这是文档的样式表（固定不变）</span><br><span class="line">    href 包含了样式表文件的路径</span><br><span class="line"></span><br><span class="line">    图标类型</span><br><span class="line">     含有高分辨率 Retina 显示屏的第三代 iPad：</span><br><span class="line">       &lt;link</span><br><span class="line">        rel=&quot;apple-touch-icon-precomposed&quot;</span><br><span class="line">        sizes=&quot;144x144&quot;</span><br><span class="line">        href=&quot;https://developer.mozilla.org/static/img/favicon144.png&quot; /&gt;</span><br><span class="line">这些注释解释了每个图标的用途——这些元素涵盖的东西提供一个高分辨率图标，这些高分辨率图标当网站保存到 iPad 的主屏幕时使用。</span><br><span class="line"></span><br><span class="line">不用担心现在实现所有这些类型的图标——这是一个相当先进的功能，不要求你有这方面的知识来通过课程的进展。</span><br><span class="line">这里的主要目的是让你提前了解有这一样东西，以防当你浏览其他网站的源代码时不理解源代码的含义。</span><br><span class="line"></span><br><span class="line">&lt;script&gt; ：</span><br><span class="line">&lt;script&gt; 用来添加JavaScript来让王爷具有交互功能。</span><br><span class="line">script元素也应当放在文档的头部，并包含 src 属性来指向需要加载的 JavaScript 文件路径，</span><br><span class="line">同时最好加上 defer 以告诉浏览器在解析完成 HTML 后再加载 JavaScript。</span><br><span class="line">这样可以确保在加载脚本之前浏览器已经解析了所有的 HTML 内容。</span><br><span class="line">这样你就不会因为 JavaScript 试图访问页面上不存在的 HTML 元素而产生错误。</span><br><span class="line">实际上有很多方法来处理在你的页面上加载 JavaScript，但对于现代浏览器来说，这是最可靠的方法（对于其他方法，请阅读脚本加载策略）。</span><br><span class="line">&lt;script src=&quot;my-js-file.js&quot; defer&gt;&lt;/script&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">--&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&lt;html lang=&quot;zh-CN&quot;&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">  &lt;meta charset=&quot;UTF-8&quot;&gt;</span><br><span class="line">  &lt;title&gt;Title&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line"></span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>code</category>
        <category>note</category>
      </categories>
      <tags>
        <tag>HTML</tag>
      </tags>
  </entry>
  <entry>
    <title>HTML学习笔记-6实践</title>
    <url>/2023/03/28/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/HTML/Q1-HTML-Note6/</url>
    <content><![CDATA[<h1>HTML学习笔记-6实践</h1>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang=&quot;en&quot;&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">  &lt;meta charset=&quot;UTF-8&quot;&gt;</span><br><span class="line">  &lt;title&gt;CatPhotoApp&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line"></span><br><span class="line">&lt;main&gt;</span><br><span class="line">  &lt;section&gt;&lt;!--[[[[[[[[[]]]]]]]]]]--&gt;</span><br><span class="line">    &lt;h1&gt;CatPhotoApp&lt;/h1&gt;</span><br><span class="line">    &lt;h2&gt;Cat Photos&lt;/h2&gt;</span><br><span class="line">    &lt;p&gt;</span><br><span class="line">      See more &lt;a href=&quot;../img/cat1.jpg&quot;&gt;cat photos&lt;/a&gt; in our gallery&lt;br&gt;</span><br><span class="line">      &lt;img src=&quot;https://cdn.freecodecamp.org/curriculum/cat-photo-app/relaxing-cat.jpg&quot; alt=&quot;A text.&quot;&gt;</span><br><span class="line">      &lt;!--[[[[[[[[[[[[alt是备注]]]]]]]]]]]--&gt;</span><br><span class="line">    &lt;/p&gt;</span><br><span class="line">  &lt;/section&gt;</span><br><span class="line"></span><br><span class="line">  &lt;section&gt;</span><br><span class="line">    &lt;h2&gt;Cat Lists&lt;/h2&gt;</span><br><span class="line">    &lt;h3&gt;Things cats love:&lt;/h3&gt;</span><br><span class="line">    &lt;ul&gt;</span><br><span class="line">      &lt;li&gt;cat nip&lt;/li&gt;</span><br><span class="line">      &lt;li&gt;laser pointers&lt;/li&gt;</span><br><span class="line">      &lt;li&gt;lasagna&lt;/li&gt;</span><br><span class="line">    &lt;/ul&gt;</span><br><span class="line">    &lt;figure&gt;&lt;!--[[[[[[[[[图像标题]]]]]]]]]]]]]]--&gt;</span><br><span class="line">      &lt;img src=&quot;https://cdn.freecodecamp.org/curriculum/cat-photo-app/lasagna.jpg&quot; alt=&quot;A slice of lasagna on a plate.&quot;&gt;</span><br><span class="line">      &lt;figcaption&gt;&lt;!--[[[[[[[[[]]]]]]]]]]]]]--&gt;</span><br><span class="line">        Cats</span><br><span class="line">        &lt;em&gt;love&lt;/em&gt;</span><br><span class="line">        lasagna.</span><br><span class="line">      &lt;/figcaption&gt;</span><br><span class="line">    &lt;/figure&gt;</span><br><span class="line">  &lt;/section&gt;</span><br><span class="line"></span><br><span class="line">  &lt;section&gt;</span><br><span class="line">    &lt;h2&gt;Top 3 things cats hate:&lt;/h2&gt;</span><br><span class="line">    &lt;ol&gt;</span><br><span class="line">      &lt;li&gt;flea treatment&lt;/li&gt;</span><br><span class="line">      &lt;li&gt;thunder&lt;/li&gt;</span><br><span class="line">      &lt;li&gt;other cats&lt;/li&gt;</span><br><span class="line">    &lt;/ol&gt;</span><br><span class="line">    &lt;figure&gt;</span><br><span class="line">      &lt;img src=&quot;https://cdn.freecodecamp.org/curriculum/cat-photo-app/cats.jpg&quot; alt=&quot;Five cats looking around a field.&quot;&gt;</span><br><span class="line">      &lt;figcaption&gt;</span><br><span class="line">        Cats &lt;strong&gt;hate&lt;/strong&gt; other cats.</span><br><span class="line">      &lt;/figcaption&gt;</span><br><span class="line">    &lt;/figure&gt;</span><br><span class="line">  &lt;/section&gt;</span><br><span class="line"></span><br><span class="line">  &lt;section&gt;</span><br><span class="line">    &lt;h2&gt;Cat form&lt;/h2&gt;</span><br><span class="line">    &lt;fieldset&gt;&lt;!--给form增加实线框--&gt;</span><br><span class="line">      &lt;legend&gt;Is your cat an indoor or outdoor cat?&lt;/legend&gt;&lt;!--给块增加标题--&gt;</span><br><span class="line">      &lt;form&gt;</span><br><span class="line">        &lt;label&gt;</span><br><span class="line">          &lt;!--[[[[[[[[[[label用于将 input 元素与其近邻的文本进行绑定]]]]]]]]]--&gt;</span><br><span class="line">          &lt;input name=&quot;door&quot; id=&quot;indoor&quot; value=&quot;indoor&quot; type=&quot;radio&quot; checked&gt;indoor</span><br><span class="line">          &lt;!--用checked给本块（legend）设置默认选项--&gt;</span><br><span class="line">        &lt;/label&gt;</span><br><span class="line">        &lt;label&gt;</span><br><span class="line">          &lt;input name=&quot;door&quot; id=&quot;outdoor&quot; value=&quot;outdoor&quot; type=&quot;radio&quot;&gt;out door</span><br><span class="line">        &lt;/label&gt;</span><br><span class="line">      &lt;/form&gt;</span><br><span class="line">    &lt;/fieldset&gt;</span><br><span class="line">    &lt;fieldset&gt;</span><br><span class="line">      &lt;legend&gt;What&#x27;s your cat&#x27;s personality?&lt;/legend&gt;</span><br><span class="line">      &lt;!--id应与选项相同，是具有唯一性的，不能当成name用--&gt;</span><br><span class="line">      &lt;!--label是必须加的,for 对应的是input的id，label和input直接看成元组就行--&gt;</span><br><span class="line">      &lt;label for=&quot;loving&quot;&gt;&lt;/label&gt;&lt;input type=&quot;checkbox&quot; value=&quot;personality&quot; id=&quot;loving&quot; checked&gt; Loving</span><br><span class="line">      &lt;label for=&quot;lazy&quot;&gt;&lt;/label&gt;&lt;input type=&quot;checkbox&quot; value=&quot;personality&quot; id=&quot;lazy&quot;&gt; lazy</span><br><span class="line">      &lt;label for=&quot;energetic&quot;&gt;&lt;/label&gt;&lt;input type=&quot;checkbox&quot; value=&quot;personality&quot; id=&quot;energetic&quot;&gt; energetic</span><br><span class="line">    &lt;/fieldset&gt;</span><br><span class="line">    &lt;input type=&quot;text&quot;  placeholder=&quot;cat photo URL&quot;&gt;</span><br><span class="line">    &lt;button type=&quot;submit&quot;&gt;Submit&lt;/button&gt;</span><br><span class="line">  &lt;/section&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&lt;/main&gt;</span><br><span class="line">&lt;footer&gt;</span><br><span class="line">  No Copyright - &lt;a href=&quot;https://www.freecodecamp.org&quot;&gt;freeCodeCamp.org&lt;/a&gt;</span><br><span class="line">&lt;/footer&gt;</span><br><span class="line"></span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>code</category>
        <category>note</category>
      </categories>
      <tags>
        <tag>HTML</tag>
      </tags>
  </entry>
  <entry>
    <title>HTML学习笔记-5体系补充</title>
    <url>/2023/03/28/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/HTML/Q1-HTML-Note5/</url>
    <content><![CDATA[<h1 id="HTML学习笔记-5体系补充"><a href="#HTML学习笔记-5体系补充" class="headerlink" title="HTML学习笔记-5体系补充"></a>HTML学习笔记-5体系补充</h1><p>前文关于内容的错误理解以本文的“整体分类”为主。</p>
<p>整体分类：<a href="https://developer.mozilla.org/zh-CN/docs/Web/HTML/Content_categories">url</a></p>
<p>主要分成几类:</p>
<p>​	内容类（比如文字&#x2F;图片&#x2F;视频&#x2F;画布）</p>
<p>​	表单相关（比如下拉菜单，文本输入框）</p>
<p>​	结构(比如div span)</p>
<p>了解块级元素和行内元素</p>
<p>块级元素就是自成一行，比如div p h1 table ul ol</p>
<p>行内元素和块级元素不一样，不会自成一行，可以多个排列成一行, 比如:img span button input</p>
<p>补充一些常用的HTML标签</p>
<p>input 输入元素的几种种类 <a href="https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/input"></a><br>textarea 文本区元素 <a href="https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/textarea"></a><br>select 下拉菜单 <a href="https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/select"></a><br>table 表格 <a href="https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/table"></a><br>video 视频 <a href="https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/video"></a></p>
<p>补充和css有关的HTML元素</p>
<ol>
<li><p>div元素: 主要用于设计布局</p>
</li>
<li><p>article元素: 方便搜索的元素,属于父级元素。</p>
</li>
<li></li>
</ol>
<ul>
<li><h4 id="易错点归档："><a href="#易错点归档：" class="headerlink" title="易错点归档："></a>易错点归档：</h4><ol>
<li><h5 id="链接相关：url、href、src"><a href="#链接相关：url、href、src" class="headerlink" title="链接相关：url、href、src"></a>链接相关：url、href、src</h5><p>a：href</p>
<p>link：href</p>
<p>script：src</p>
<p>img：src</p>
<h6 id="作用结果不同"><a href="#作用结果不同" class="headerlink" title="作用结果不同"></a>作用结果不同</h6><p>（1）href 用于在当前文档和引用资源之间确立联系；</p>
<p>（2）src 用于替换当前内容；</p>
</li>
<li><h5 id="附加：link和-import的区别"><a href="#附加：link和-import的区别" class="headerlink" title="附加：link和@import的区别"></a>附加：link和@import的区别</h5><p>（1）link是XHTML标签，除了能够加载CSS，还可以定义RSS等其他事务；而@import属于CSS范畴，只可以加载CSS。</p>
<p>（2）link引用CSS时，在页面载入时同时加载；@import需要页面完全载入以后再加载。</p>
<p>（3）link是XHTML标签，无兼容问题；@import则是在CSS2.1提出的，低版本的浏览器不支持。</p>
<p>（4）link支持使用Javascript控制DOM改变样式；而@import不支持。</p>
<h5 id="3-为什么js用script标签的src引入，而css用link标签的href引入"><a href="#3-为什么js用script标签的src引入，而css用link标签的href引入" class="headerlink" title="3.为什么js用script标签的src引入，而css用link标签的href引入"></a>3.为什么js用script标签的src引入，而css用link标签的href引入</h5><p>外部共享的JavaScript文件，通过 <code>&lt;script src=&quot;...&quot;&gt;&lt;/script&gt;</code>来引入，共享的样式文件不是通过 <code>&lt;style src=&quot;&quot;&gt;&lt;/style&gt;</code> 的形式引入，而是通过 <code>&lt;link rel=&quot;stylesheet&quot; href=&quot;...&quot;&gt;</code>形式引入。</p>
<p>w3c最初的设计中<script>标签也没有src属性，使用 <code>&lt;link rel=&quot;...&quot; href=&quot;...&quot;&gt;</code> 来引入当前文档外部的资源，如：父文档，翻译，或者层叠样式表等。<code>&lt;link rel=&quot;&quot; href=&quot;&quot; meidia=&quot;&quot;&gt;</code> 元素规定了当前文档和外部资源之间的关系，它常用来引入外部的样式表，我们可以通过rel属性设置为stylesheet来使用。后来为<code>&lt;script&gt;</code>添加了src属性。</p>
<p><strong><code>href</code>是引用和页面关联，是在当前元素和引用资源之间建立联系，<code>src</code>表示引用资源，表示替换当前元素，用在img，script，iframe上，src是页面内容不可缺少的一部分。</strong></p>
<script src="js.js"></script>当浏览器解析到这一句的时候会暂停其他资源的下载和处理，直至将该资源加载，编译，执行完毕，图片和框架等元素也是如此，类似于该元素所指向的资源嵌套如当前标签内，这也是为什么要把放在底部而不是头部。

<link href="common.css" rel="stylesheet"/>当浏览器解析到这一句的时候会识别该文档为css文件，会下载并且不会停止对当前文档的处理，这也是为什么建议使用link方式来加载css而不是使用@import。</li>
</ol>
</li>
</ul>
]]></content>
      <categories>
        <category>code</category>
        <category>note</category>
      </categories>
      <tags>
        <tag>HTML</tag>
      </tags>
  </entry>
  <entry>
    <title>前端英文列表</title>
    <url>/2023/03/29/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%85%B6%E5%AE%83/Q0-Word/</url>
    <content><![CDATA[<p>margin：外边距</p>
<p>border：框架</p>
<p>padding：内边距</p>
<p>br：Barter rabbet  </p>
<p>en： &#x2F;ˈbär-tər    ræbɪt&#x2F;  换行</p>
<p>span：行内组合, 被用来组合文档中的行内元素, 没有固定的格式表现。 </p>
<p>跨越</p>
<p>pre: 预定义格式文本,空白符照常显示，不格式化。</p>
<p>先前的</p>
<p>fieldset：给某一块增加实线框</p>
<p>领域设置</p>
<p>legend：fieldset中的标题</p>
<p>传奇</p>
<p>section：</p>
<p>章节</p>
<p>article：语义化</p>
<p>条款、文章</p>
<p>disabled：放input里表示禁止输入</p>
<p>radio：单选框</p>
<p>老式收音机按钮，按下一个其它弹起。</p>
<p>figure：可以和图像关联起来的独立内容</p>
<p>图</p>
<p>placeholder</p>
<p>flex布局</p>
<p>row：行    </p>
<p>column：柱子</p>
<h1 id="html"><a href="#html" class="headerlink" title="html"></a>html</h1><ol>
<li><p>HTML - 超文本标记语言</p>
</li>
<li><p>Head - 文档头部</p>
</li>
<li><p>Body - 文档主体</p>
</li>
<li><p>H1-H6 - 标题（从大到小）</p>
</li>
<li><p>Div - 无语义块级元素</p>
</li>
<li><h4 id="Span-无语义行内元素"><a href="#Span-无语义行内元素" class="headerlink" title="Span - 无语义行内元素"></a>Span - 无语义行内元素</h4></li>
<li><p>Img - 图片</p>
</li>
<li><p>Src - 图片链接地址</p>
</li>
<li><h5 id="Alt-替代文本"><a href="#Alt-替代文本" class="headerlink" title="Alt - 替代文本"></a>Alt - 替代文本</h5></li>
<li><p>A - 链接</p>
</li>
<li><p>Href - 链接地址</p>
</li>
<li><h5 id="Target-打开方式"><a href="#Target-打开方式" class="headerlink" title="Target - 打开方式"></a>Target - 打开方式</h5></li>
<li><p>Title - 标题</p>
</li>
<li><p>Style - 样式</p>
</li>
<li><p>Class - 类名</p>
</li>
<li><p>ID - 元素 ID</p>
</li>
<li><p>Table - 表格</p>
</li>
<li><p>Tr - 行</p>
</li>
<li><p>Th - 表头单元格</p>
</li>
<li><p>Td - 数据单元格</p>
</li>
<li><p>Colspan - 列合并</p>
</li>
<li><p>Rowspan - 行合并</p>
</li>
<li><p>Form - 表单</p>
</li>
<li><p>Input - 输入框</p>
</li>
<li><p>Type - 输入类型</p>
</li>
<li><p>Name - 名称</p>
</li>
<li><p>Value - 值</p>
</li>
<li><p>Checked - 是否勾选</p>
</li>
<li><h5 id="Radio-单选框"><a href="#Radio-单选框" class="headerlink" title="Radio - 单选框"></a>Radio - 单选框</h5></li>
<li><h5 id="Checkbox-多选框"><a href="#Checkbox-多选框" class="headerlink" title="Checkbox - 多选框"></a>Checkbox - 多选框</h5></li>
<li><p>Select - 下拉框</p>
</li>
<li><p>Option - 选项</p>
</li>
<li><h5 id="Disabled-禁用"><a href="#Disabled-禁用" class="headerlink" title="Disabled - 禁用"></a>Disabled - 禁用</h5></li>
<li><p>Readonly - 只读</p>
</li>
<li><p>Button - 按钮</p>
</li>
<li><p>Submit - 提交按钮</p>
</li>
<li><p>Reset - 重置按钮</p>
</li>
<li><h5 id="Label-文本标签"><a href="#Label-文本标签" class="headerlink" title="Label - 文本标签"></a>Label - 文本标签</h5></li>
<li><p>Textarea - 文本域</p>
</li>
<li><h5 id="Rows-行数"><a href="#Rows-行数" class="headerlink" title="Rows - 行数"></a>Rows - 行数</h5></li>
<li><h5 id="Cols-列数"><a href="#Cols-列数" class="headerlink" title="Cols - 列数"></a>Cols - 列数</h5></li>
<li><p>Placeholder - 提示语</p>
</li>
<li><p>Required - 是否必填</p>
</li>
<li><p>Maxlength - 最大长度</p>
</li>
<li><p>Minlength - 最小长度</p>
</li>
<li><p>Pattern - 格式匹配</p>
</li>
<li><p>Email - 邮箱类型</p>
</li>
<li><p>Tel - 电话类型</p>
</li>
<li><p>Password - 密码类型</p>
</li>
<li><p>Number - 数字类型</p>
</li>
<li><p>Date - 日期类型</p>
</li>
<li><p>Time - 时间类型</p>
</li>
<li><p>Range - 范围类型</p>
</li>
<li><p>Color - 颜色类型</p>
</li>
<li><p>Search - 搜索类型</p>
</li>
<li><p>Datetime - 日期时间类型</p>
</li>
<li><p>Datetime-local - 本地日期时间类型</p>
</li>
<li><p>Week - 星期类型</p>
</li>
<li><p>Month - 月份类型</p>
</li>
<li><h5 id="Fieldset-表单元素组"><a href="#Fieldset-表单元素组" class="headerlink" title="Fieldset - 表单元素组"></a>Fieldset - 表单元素组</h5></li>
<li><h5 id="Legend-表单元素组标题"><a href="#Legend-表单元素组标题" class="headerlink" title="Legend - 表单元素组标题"></a>Legend - 表单元素组标题</h5></li>
<li><h5 id="Label-表单控件标签"><a href="#Label-表单控件标签" class="headerlink" title="Label - 表单控件标签"></a>Label - 表单控件标签</h5></li>
<li><p>Optgroup - 选项组</p>
</li>
<li><p>Command - 命令</p>
</li>
<li><p>Menu - 上下文菜单</p>
</li>
<li><p>Footer - 底部</p>
</li>
<li><p>Header - 页眉</p>
</li>
<li><p>Video - 视频</p>
</li>
<li><p>Audio - 音频</p>
</li>
<li><p>Source - 媒体资源</p>
</li>
<li><p>Track - 字幕轨道</p>
</li>
<li><p>Canvas - 画布</p>
</li>
<li><p>SVG - 矢量图</p>
</li>
<li><p>Path - 路径</p>
</li>
<li><p>Rect - 矩形</p>
</li>
<li><p>Circle - 圆形</p>
</li>
<li><p>Ellipse - 椭圆</p>
</li>
<li><p>Line - 直线</p>
</li>
<li><p>Polygon - 多边形</p>
</li>
<li><p>Polyline - 折线</p>
</li>
<li><p>Text - 文本</p>
</li>
<li><p>Tspan - 文本段落</p>
</li>
<li><p>Gradient - 渐变</p>
</li>
<li><p>Stop - 渐变停止点</p>
</li>
<li><p>Clippath - 剪裁路径</p>
</li>
<li><p>Mask - 遮罩</p>
</li>
<li><p>Filter - 滤镜</p>
</li>
<li><p>FeGaussianBlur - 高斯模糊滤镜</p>
</li>
<li><p>FeBlend - 混合滤镜</p>
</li>
<li><p>FeColorMatrix - 颜色矩阵滤镜</p>
</li>
<li><p>FeOffset - 偏移滤镜</p>
</li>
<li><p>FeMerge - 合并滤镜</p>
</li>
<li><p>FeComponentTransfer - 分量转换滤镜</p>
</li>
<li><p>FeTurbulence - 纹理滤镜</p>
</li>
<li><p>FeDisplacementMap - 位移映射滤镜</p>
</li>
<li><p>FeConvolveMatrix - 卷积矩阵滤镜</p>
</li>
<li><p>FeSpecularLighting - 镜面反射滤镜</p>
</li>
<li><p>FeDiffuseLighting - 漫反射滤镜</p>
</li>
<li><p>ForeignObject - 外部对象</p>
</li>
<li><p>Embed - 多媒体（已弃用）</p>
</li>
<li><p>Iframe - 内嵌框架</p>
</li>
<li><p>Source - 多媒体资源</p>
</li>
<li><p>Object - 对象</p>
</li>
<li><h5 id="Param-参数"><a href="#Param-参数" class="headerlink" title="Param - 参数"></a>Param - 参数</h5></li>
<li><p>Style - 样式</p>
</li>
<li><p>Script - 脚本</p>
</li>
<li><h5 id="Src-脚本链接地址"><a href="#Src-脚本链接地址" class="headerlink" title="Src - 脚本链接地址"></a>Src - 脚本链接地址</h5></li>
<li><h5 id="Type-脚本类型"><a href="#Type-脚本类型" class="headerlink" title="Type - 脚本类型"></a>Type - 脚本类型</h5></li>
<li><h5 id="Async-异步加载"><a href="#Async-异步加载" class="headerlink" title="Async - 异步加载"></a>Async - 异步加载</h5></li>
<li><p>Defer - 延迟加载</p>
</li>
<li><p>Charset - 字符集</p>
</li>
<li><p>Comment - 注释</p>
</li>
<li><p>Doctype - 文档类型</p>
</li>
<li><p>Html - 页面根元素</p>
</li>
<li><p>Lang - 语言</p>
</li>
<li><p>Meta - 页面元数据</p>
</li>
<li><p>Charset - 字符集</p>
</li>
<li><p>Viewport - 视口</p>
</li>
<li><p>Content - 属性值</p>
</li>
<li><p>Http-equiv - HTTP 头部</p>
</li>
<li><p>Refresh - 定时刷新</p>
</li>
<li><p>Link - 文档关联</p>
</li>
<li><p>Rel - 关联类型</p>
</li>
<li><p>Hreflang - 关联语言</p>
</li>
<li><p>Sizes - 图标尺寸</p>
</li>
<li><p>Media - 媒体查询条件</p>
</li>
<li><p>Icon - 页面图标</p>
</li>
<li><p>Base - 基础 URL</p>
</li>
<li><p>Target - 目标窗口</p>
</li>
<li><p>Download - 下载链接</p>
</li>
<li><p>Charset - 字符集</p>
</li>
<li><p>Manifest - 应用程序清单</p>
</li>
<li><p>Contenteditable - 可编辑性</p>
</li>
<li><p>Spellcheck - 拼写检查</p>
</li>
<li><p>Translate - 翻译</p>
</li>
<li><p>Accesskey - 快捷键</p>
</li>
<li><p>AutoFocus - 自动聚焦</p>
</li>
<li><p>Enterkeyhint - 回车键提示</p>
</li>
<li><p>Formaction - 自定义提交地址</p>
</li>
<li><p>Formenctype - 自定义编码类型</p>
</li>
<li><p>Formmethod - 自定义提交方法</p>
</li>
<li><p>Formnovalidate - 自定义表单验证</p>
</li>
<li><p>Formtarget - 自定义打开方式</p>
</li>
<li><p>Hidden - 隐藏元素</p>
</li>
<li><p>Ismap - 图像地图</p>
</li>
<li><p>Longdesc - 图像说明文本</p>
</li>
<li><p>Usemap - 链接到图像地图</p>
</li>
<li><p>Noresize - 禁止调整窗口大小</p>
</li>
<li><p>Noshade - 禁止阴影</p>
</li>
<li><p>Wrap - 文本换行方式</p>
<h1 id="css"><a href="#css" class="headerlink" title="css"></a>css</h1></li>
<li><p>selector - 选择器</p>
</li>
<li><p>property - 属性</p>
</li>
<li><p>value - 值</p>
</li>
<li><p>class - 类</p>
</li>
<li><p>id - ID</p>
</li>
<li><p>element - 元素</p>
</li>
<li><p>width - 宽度</p>
</li>
<li><p>height - 高度</p>
</li>
<li><h5 id="margin-边距"><a href="#margin-边距" class="headerlink" title="margin - 边距"></a>margin - 边距</h5></li>
<li><h5 id="padding-内边距"><a href="#padding-内边距" class="headerlink" title="padding - 内边距"></a>padding - 内边距</h5></li>
<li><h5 id="border-边框"><a href="#border-边框" class="headerlink" title="border - 边框"></a>border - 边框</h5></li>
<li><p>background - 背景</p>
</li>
<li><p>color - 颜色</p>
</li>
<li><p>font - 字体</p>
</li>
<li><p>text - 文本</p>
</li>
<li><h5 id="display-显示"><a href="#display-显示" class="headerlink" title="display - 显示"></a>display - 显示</h5></li>
<li><p>position - 定位</p>
</li>
<li><p>float - 浮动</p>
</li>
<li><h5 id="clear-清除浮动"><a href="#clear-清除浮动" class="headerlink" title="clear - 清除浮动"></a>clear - 清除浮动</h5></li>
<li><p>overflow - 溢出</p>
</li>
<li><p>z-index - 层级</p>
</li>
<li><p>cursor - 鼠标指针</p>
</li>
<li><p>transition - 过渡</p>
</li>
<li><p>animation - 动画</p>
</li>
<li><h5 id="flexbox-弹性盒子布局"><a href="#flexbox-弹性盒子布局" class="headerlink" title="flexbox - 弹性盒子布局"></a>flexbox - 弹性盒子布局</h5></li>
<li><h5 id="grid-网格布局"><a href="#grid-网格布局" class="headerlink" title="grid - 网格布局"></a>grid - 网格布局</h5></li>
<li><p>box-shadow - 盒子阴影</p>
</li>
<li><p>text-shadow - 文本阴影</p>
</li>
<li><p>opacity - 不透明度</p>
</li>
<li><p>transform - 变换</p>
</li>
<li><h5 id="filter-滤镜"><a href="#filter-滤镜" class="headerlink" title="filter - 滤镜"></a>filter - 滤镜</h5></li>
<li><p>gradient - 渐变</p>
</li>
<li><p>media query - 媒体查询</p>
</li>
<li><p>box model - 盒子模型</p>
</li>
<li><p>inline - 行内</p>
</li>
<li><p>block - 块级</p>
</li>
<li><p>inline-block - 行内块级</p>
</li>
<li><p>font-size - 字体大小</p>
</li>
<li><p>line-height - 行高</p>
</li>
<li><h5 id="text-align-文本对齐"><a href="#text-align-文本对齐" class="headerlink" title="text-align - 文本对齐"></a>text-align - 文本对齐</h5></li>
<li><h5 id="vertical-align-垂直对齐"><a href="#vertical-align-垂直对齐" class="headerlink" title="vertical-align - 垂直对齐"></a>vertical-align - 垂直对齐</h5></li>
<li><p>list-style - 列表样式</p>
</li>
<li><h5 id="border-radius-边框圆角"><a href="#border-radius-边框圆角" class="headerlink" title="border-radius - 边框圆角"></a>border-radius - 边框圆角</h5></li>
<li><p>outline - 外边框</p>
</li>
<li><p>word-wrap - 换行</p>
</li>
<li><p>text-overflow - 文本溢出</p>
</li>
<li><h5 id="white-space-空格处理"><a href="#white-space-空格处理" class="headerlink" title="white-space - 空格处理"></a>white-space - 空格处理</h5></li>
<li><p>letter-spacing - 字符间距</p>
</li>
<li><p>word-spacing - 单词间距</p>
</li>
<li><p>box-sizing - 盒子尺寸</p>
</li>
<li><p>top - 上方距离</p>
</li>
<li><p>right - 右侧距离</p>
</li>
<li><p>bottom - 下方距离</p>
</li>
<li><p>left - 左侧距离</p>
</li>
<li><p>visibility - 显示状态</p>
</li>
<li><p>table - 表格</p>
</li>
<li><p>table-cell - 单元格</p>
</li>
<li><p>table-row - 表格行</p>
</li>
<li><p>text-decoration - 文本装饰</p>
</li>
<li><p>user-select - 用户选择</p>
</li>
<li><p>pointer-events - 指针事件</p>
</li>
<li><p>font-weight - 字体粗细</p>
</li>
<li><p>font-style - 字体样式</p>
</li>
<li><p>text-transform - 文本转换</p>
</li>
<li><p>background-size - 背景尺寸</p>
</li>
<li><p>background-position - 背景位置</p>
</li>
<li><p>background-repeat - 背景重复</p>
</li>
<li><h5 id="line-break-自动换行"><a href="#line-break-自动换行" class="headerlink" title="line-break - 自动换行"></a>line-break - 自动换行</h5></li>
<li><h5 id="justify-content-主轴对齐方式"><a href="#justify-content-主轴对齐方式" class="headerlink" title="justify-content - 主轴对齐方式"></a>justify-content - 主轴对齐方式</h5></li>
<li><h5 id="align-items-侧轴对齐方式"><a href="#align-items-侧轴对齐方式" class="headerlink" title="align-items - 侧轴对齐方式"></a>align-items - 侧轴对齐方式</h5></li>
<li><h5 id="align-self-元素自身在侧轴方向上的对齐方式"><a href="#align-self-元素自身在侧轴方向上的对齐方式" class="headerlink" title="align-self - 元素自身在侧轴方向上的对齐方式"></a>align-self - 元素自身在侧轴方向上的对齐方式</h5></li>
<li><h5 id="flex-direction-主轴方向"><a href="#flex-direction-主轴方向" class="headerlink" title="flex-direction - 主轴方向"></a>flex-direction - 主轴方向</h5></li>
<li><h5 id="flex-wrap-换行方式"><a href="#flex-wrap-换行方式" class="headerlink" title="flex-wrap - 换行方式"></a>flex-wrap - 换行方式</h5></li>
<li><h5 id="flex-grow-扩张比例"><a href="#flex-grow-扩张比例" class="headerlink" title="flex-grow - 扩张比例"></a>flex-grow - 扩张比例</h5></li>
<li><h5 id="flex-shrink-缩小比例"><a href="#flex-shrink-缩小比例" class="headerlink" title="flex-shrink - 缩小比例"></a>flex-shrink - 缩小比例</h5></li>
<li><p>flex-basis - 基准大小</p>
</li>
<li><h5 id="grid-template-columns-网格列定义"><a href="#grid-template-columns-网格列定义" class="headerlink" title="grid-template-columns - 网格列定义"></a>grid-template-columns - 网格列定义</h5></li>
<li><h5 id="grid-template-rows-网格行定义"><a href="#grid-template-rows-网格行定义" class="headerlink" title="grid-template-rows - 网格行定义"></a>grid-template-rows - 网格行定义</h5></li>
<li><h5 id="grid-gap-网格间距"><a href="#grid-gap-网格间距" class="headerlink" title="grid-gap - 网格间距"></a>grid-gap - 网格间距</h5></li>
<li><h5 id="grid-column-start-开始列"><a href="#grid-column-start-开始列" class="headerlink" title="grid-column-start - 开始列"></a>grid-column-start - 开始列</h5></li>
<li><h5 id="grid-column-end-结束列"><a href="#grid-column-end-结束列" class="headerlink" title="grid-column-end - 结束列"></a>grid-column-end - 结束列</h5></li>
<li><h5 id="grid-row-start-开始行"><a href="#grid-row-start-开始行" class="headerlink" title="grid-row-start - 开始行"></a>grid-row-start - 开始行</h5></li>
<li><h5 id="grid-row-end-结束行"><a href="#grid-row-end-结束行" class="headerlink" title="grid-row-end - 结束行"></a>grid-row-end - 结束行</h5></li>
<li><h5 id="justify-items-项目在网格交叉区域内对齐方式"><a href="#justify-items-项目在网格交叉区域内对齐方式" class="headerlink" title="justify-items - 项目在网格交叉区域内对齐方式"></a>justify-items - 项目在网格交叉区域内对齐方式</h5></li>
<li><h5 id="grid-template-areas-网格区域定义"><a href="#grid-template-areas-网格区域定义" class="headerlink" title="grid-template-areas - 网格区域定义"></a>grid-template-areas - 网格区域定义</h5></li>
<li><p>gap - 网格间距</p>
</li>
<li><p>counter-reset - 计数器重置</p>
</li>
<li><p>counter-increment - 计数器递增</p>
</li>
<li><p>content - 内容</p>
</li>
<li><p>attr() - 获取元素属性值</p>
</li>
<li><p>calc() - 计算值</p>
</li>
<li><h5 id="hover-鼠标悬停伪类"><a href="#hover-鼠标悬停伪类" class="headerlink" title=":hover - 鼠标悬停伪类"></a>:hover - 鼠标悬停伪类</h5></li>
<li><h5 id="active-鼠标点击伪类"><a href="#active-鼠标点击伪类" class="headerlink" title=":active - 鼠标点击伪类"></a>:active - 鼠标点击伪类</h5></li>
<li><p>:focus - 获取焦点伪类</p>
</li>
<li><h5 id="nth-child-n-选择特定位置的元素"><a href="#nth-child-n-选择特定位置的元素" class="headerlink" title=":nth-child(n) - 选择特定位置的元素"></a>:nth-child(n) - 选择特定位置的元素</h5></li>
<li><p>::before - 在元素前插入内容</p>
</li>
<li><p>::after - 在元素后插入内容</p>
</li>
<li><p>::first-letter - 对文本的第一个字母进行特殊处理</p>
</li>
<li><p>::first-line - 对文本的第一行进行特殊处理</p>
</li>
<li><p>@media - 媒体查询</p>
<h1 id="Javascript"><a href="#Javascript" class="headerlink" title="Javascript"></a>Javascript</h1></li>
<li><p>alert - 弹出警告框</p>
</li>
<li><p>anchor - 创建锚元素</p>
</li>
<li><p>append - 添加元素</p>
</li>
<li><p>apply - 调用函数</p>
</li>
<li><p>argument - 参数</p>
</li>
<li><p>array - 数组</p>
</li>
<li><p>assign - 对象赋值</p>
</li>
<li><p>async - 异步</p>
</li>
<li><p>await - 等待异步执行结束</p>
</li>
<li><p>bind - 绑定函数到对象上</p>
</li>
<li><p>boolean - 布尔数据类型</p>
</li>
<li><p>break - 跳出循环</p>
</li>
<li><p>buffer - 缓冲区</p>
</li>
<li><p>callback - 回调函数</p>
</li>
<li><p>catch - 捕获异常</p>
</li>
<li><p>charAt - 字符串方法，返回指定位置字符</p>
</li>
<li><p>chartCode - 字符串方法，返回指定字符编码</p>
</li>
<li><p>class - 类</p>
</li>
<li><p>clear - 清除控制台</p>
</li>
<li><p>clone - 克隆对象</p>
</li>
<li><p>close - 关闭窗口</p>
</li>
<li><p>console - 控制台对象</p>
</li>
<li><p>const - 常量</p>
</li>
<li><p>constructor - 构造函数</p>
</li>
<li><p>continue - 跳过本轮循环</p>
</li>
<li><p>cookie - cookie</p>
</li>
<li><p>createElement - 创建元素</p>
</li>
<li><p>createTextNode - 创建文本节点</p>
</li>
<li><p>crypto - 加密相关</p>
</li>
<li><p>CSS - 层叠样式表</p>
</li>
<li><p>date - 日期对象</p>
</li>
<li><p>debugger - 断点调试</p>
</li>
<li><p>decodeURI - 解码 URI</p>
</li>
<li><p>decodeURIComponent - 解码 URI 组件</p>
</li>
<li><p>default - 默认值</p>
</li>
<li><p>delete - 删除属性</p>
</li>
<li><p>do - 循环结构</p>
</li>
<li><p>document - 文档对象模型</p>
</li>
<li><p>DOM - 文档对象模型</p>
</li>
<li><p>double - 双精度浮点数数据类型</p>
</li>
<li><p>else - if 语句中的分支</p>
</li>
<li><p>empty - 空值</p>
</li>
<li><p>encodeURI - 编码 URI</p>
</li>
<li><p>encodeURIComponent - 编码 URI 组件</p>
</li>
<li><p>error - 错误信息</p>
</li>
<li><p>escape - 转义字符串</p>
</li>
<li><p>eval - 计算字符串表达式</p>
</li>
<li><p>event - 事件</p>
</li>
<li><p>false - 布尔值，表示假</p>
</li>
<li><p>fetch - 发送网络请求</p>
</li>
<li><p>filter - 数组过滤器</p>
</li>
<li><p>find - 查找数组元素</p>
</li>
<li><p>flat - 扁平化数组</p>
</li>
<li><p>float - 单精度浮点数数据类型</p>
</li>
<li><p>floor - 取整函数</p>
</li>
<li><p>forEach - 数组迭代器</p>
</li>
<li><p>for…in - 对象属性遍历</p>
</li>
<li><p>for…of - 遍历可迭代对象</p>
</li>
<li><p>function - 函数</p>
</li>
<li><p>get - 获取对象属性</p>
</li>
<li><p>global - 全局对象</p>
</li>
<li><p>hash - URL 哈希值</p>
</li>
<li><p>history - 浏览器访问历史记录</p>
</li>
<li><p>HTML - 超文本标记语言</p>
</li>
<li><p>http - 超文本传输协议</p>
</li>
<li><p>https - 安全超文本传输协议</p>
</li>
<li><p>if - 条件语句</p>
</li>
<li><p>import - 导入其他模块</p>
</li>
<li><p>in - 属性是否存在</p>
</li>
<li><p>includes - 判断元素是否在数组中</p>
</li>
<li><p>index - 在字符串中的位置</p>
</li>
<li><p>indexOf - 在数组中的位置</p>
</li>
<li><p>Infinity - 无穷大</p>
</li>
<li><p>innerHTML - 获取或设置元素的 HTML 内容</p>
</li>
<li><p>instanceOf - 判断对象类型</p>
</li>
<li><p>isFinite - 判断是否为有限数</p>
</li>
<li><p>isNaN - 判断是否为 NaN</p>
</li>
<li><p>join - 连接数组元素</p>
</li>
<li><p>JSON - JavaScript 对象表示法</p>
</li>
<li><p>key - 对象键名</p>
</li>
<li><p>label - 表单标签</p>
</li>
<li><p>length - 字符串或数组长度</p>
</li>
<li><p>let - 块级作用域变量</p>
</li>
<li><p>link - 创建链接元素</p>
</li>
<li><p>load - 页面加载事件</p>
</li>
<li><p>location - URL 相关信息</p>
</li>
<li><p>log - 控制台输出</p>
</li>
<li><p>map - 数组映射</p>
</li>
<li><p>match - 字符串匹配</p>
</li>
<li><p>Math - 数学计算对象</p>
</li>
<li><p>max - 最大值</p>
</li>
<li><p>message - 消息传递</p>
</li>
<li><p>min - 最小值</p>
</li>
<li><p>module - 模块化</p>
</li>
<li><p>moveBy - 移动窗口</p>
</li>
<li><p>navigator - 浏览器信息</p>
</li>
<li><p>new - 创建实例对象</p>
</li>
<li><p>null - 空对象</p>
</li>
<li><p>number - 数字数据类型</p>
</li>
<li><p>object - 对象数据类型</p>
</li>
<li><p>of - 创建数组</p>
</li>
<li><p>on - 绑定事件</p>
</li>
<li><p>open - 打开新窗口</p>
</li>
<li><p>operator - 运算符</p>
</li>
<li><p>optional - 可选链</p>
</li>
<li><p>or - 或运算</p>
</li>
<li><p>outerHTML - 获取或设置元素的 HTML 包含外部标签</p>
</li>
<li><p>output - 输出</p>
</li>
<li><p>package - 包</p>
</li>
<li><p>parseFloat - 字符串转换为浮点数</p>
</li>
<li><p>parseInt - 字符串转换为整数</p>
</li>
<li><p>parent - 父节点</p>
</li>
<li><p>parse - 解析 JSON</p>
</li>
<li><p>pass - 传递参数</p>
</li>
<li><p>pop - 删除数组末尾元素</p>
</li>
<li><p>preventDefault - 阻止默认事件</p>
</li>
<li><p>print - 打印内容</p>
</li>
<li><p>prompt - 提示用户输入</p>
</li>
<li><p>prototype - 实例原型对象</p>
</li>
<li><p>push - 向数组末尾添加元素</p>
</li>
<li><p>querySelector - 返回第一个匹配的元素</p>
</li>
<li><p>random - 随机数</p>
</li>
<li><p>range - 数值范围</p>
</li>
<li><p>reduce - 数组归并操作</p>
</li>
<li><p>RegExp - 正则表达式</p>
</li>
<li><p>reload - 重新加载页面</p>
</li>
<li><p>replace - 替换文本</p>
</li>
<li><p>return - 返回函数值</p>
</li>
<li><p>reverse - 反转数组</p>
</li>
<li><p>screen - 屏幕信息</p>
</li>
<li><p>script - JavaScript 脚本</p>
</li>
<li><p>scroll - 滚动</p>
</li>
<li><p>scrollBy - 滚动指定像素</p>
</li>
<li><p>scrollTo - 滚动到指定位置</p>
</li>
<li><p>search - URL 查询参数</p>
</li>
<li><p>select - 选择表单元素</p>
</li>
<li><p>set - 设置对象属性</p>
</li>
<li><p>setInterval - 定时操作，按指定间隔重复执行</p>
</li>
<li><p>setTimeout - 定时操作，延迟执行一次</p>
</li>
<li><p>shift - 删除数组首个元素</p>
</li>
<li><p>slice - 截取数组片段</p>
</li>
<li><p>sort - 数组排序</p>
</li>
<li><p>source - 源代码</p>
</li>
<li><p>splice - 插入或删除元素</p>
</li>
<li><p>split - 字符串分割成数组</p>
</li>
<li><p>static - 静态属性与方法</p>
</li>
<li><p>strict - 严格模式</p>
</li>
<li><p>string - 字符串数据类型</p>
</li>
<li><p>style - 行内样式</p>
</li>
<li><p>switch - 多分支语句</p>
</li>
</ol>
]]></content>
      <categories>
        <category>code</category>
        <category>note</category>
      </categories>
      <tags>
        <tag>HTML</tag>
      </tags>
  </entry>
  <entry>
    <title></title>
    <url>/2023/04/15/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/JS/VSCode%E4%BB%A3%E7%A0%81/%E5%AF%B9%E8%B1%A1%E5%B5%8C%E5%A5%97/</url>
    <content><![CDATA[<!DOCTYPE html>
<html lang="zh-CN">
  <head>
    <meta charset="UTF-8" />
    <title></title>
  </head>
  <body></body>
</html>
]]></content>
  </entry>
  <entry>
    <title></title>
    <url>/2023/04/14/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/JS/VSCode%E4%BB%A3%E7%A0%81/%E8%AE%BF%E9%97%AE%E5%87%BD%E6%95%B0%E5%86%85%E5%B5%8C%E5%A5%97%E7%9A%84%E5%AF%B9%E8%B1%A1/</url>
    <content><![CDATA[<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <title>1.访问函数内嵌套的对象</title>
  </head>
  <body>
    <script>
      /*函数将会检查通讯录中是否存在一个 firstName 与传入的 name 相同的联系人。 如果存在，那么还需要检查对应的联系人中是否存在 prop 属性。
      如果它们都存在，函数返回 prop 属性对应的值。
      如果 name 不对应于任何联系人，然后返回字符串 No such contact。
      如果 prop 属性在匹配 name 的联系人里不存在，返回 No such property。 */

      const contacts = [
        {
          firstName: 'Akira',
          lastName: 'Laine',
          number: '0543236543',
          likes: ['Pizza', 'Coding', 'Brownie Points'],
        },
        {
          firstName: 'Harry',
          lastName: 'Potter',
          number: '0994372684',
          likes: ['Hogwarts', 'Magic', 'Hagrid'],
        },
        {
          firstName: 'Sherlock',
          lastName: 'Holmes',
          number: '0487345643',
          likes: ['Intriguing Cases', 'Violin'],
        },
        {
          firstName: 'Kristian',
          lastName: 'Vos',
          number: 'unknown',
          likes: ['JavaScript', 'Gaming', 'Foxes'],
        },
      ];

      // 1.[{1}{2}{3}{4}]结构,forin的结果并不是取[]内的几个{}，而是数数。
      // for (let sq in contacts) {
      //   console.log(sq); //0 1 2 3
      // }
      // 2.for in 在js中只能用来遍历对象的属性,py里是for i in range(10);
      //   for (let i in contacts.length) {
      //     console.log('2222');
      //   }
      function lookUpProfile(name, prop) {
        for (let i = 0; i < contacts.length; ++i) {
          console.log(contacts[i]);
          if (contacts[i].firstName === name) {
            console.log('name findable');
            for (let j in contacts[1]) {
              if (j === prop) {
                console.log(contacts[i][prop]);
                return contacts[i][prop];
              }
            }
            return 'No such property';
          }
        }
        return 'No such contact';
      }
      lookUpProfile('Harry', 'likes');
    </script>
  </body>
</html>
]]></content>
  </entry>
  <entry>
    <title>JS学习笔记-4.1JS基础（base mooc）</title>
    <url>/2023/04/07/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/JS/Q4-JS-1%E5%9F%BA%E7%A1%80%EF%BC%88mooc%EF%BC%89/</url>
    <content><![CDATA[<h1 id="4-1JS基础（mooc）"><a href="#4-1JS基础（mooc）" class="headerlink" title="4.1JS基础（mooc）"></a>4.1JS基础（mooc）</h1><h2 id="大纲"><a href="#大纲" class="headerlink" title="大纲"></a>大纲</h2><ul>
<li><input checked="" disabled="" type="checkbox"> 1.了解js的数据类型:</li>
</ul>
<p>​		基础数据类型：number string boolean undefined null<br>​		引用类型:object(对象) array(数组)</p>
<ul>
<li><p><input checked="" disabled="" type="checkbox"> 
2.string（字符串）</p>
</li>
<li><p><input checked="" disabled="" type="checkbox"> 
​		获取长度 (length属性)</p>
</li>
<li><p><input checked="" disabled="" type="checkbox"> 
​		字符串的拼接(使用加号)</p>
</li>
<li><p><input checked="" disabled="" type="checkbox"> 
​		字符串的访问 (string[0],或者<strong>charAt方法</strong>)</p>
</li>
<li><p><input checked="" disabled="" type="checkbox"> 
​		换行符号(\n)</p>
</li>
<li><p><input checked="" disabled="" type="checkbox"> 
​		转义(&quot;hello&quot;)</p>
</li>
<li><p><input checked="" disabled="" type="checkbox"> 
​		string的方法: <a href="https://www.w3school.com.cn/js/js_string_methods.asp">https://www.w3school.com.cn/js/js_string_methods.asp</a></p>
</li>
<li><p><input checked="" disabled="" type="checkbox"> 
3.object （对象）</p>
</li>
<li><p><input checked="" disabled="" type="checkbox"> 
​		定义一组键值对</p>
</li>
<li><p><input checked="" disabled="" type="checkbox"> 
​		object的构造方式 (var a &#x3D; {b:1} 或者 var a &#x3D; new Object({b:1}))</p>
<p>​			推荐使用前者，后者了解即可</p>
</li>
<li><p><input checked="" disabled="" type="checkbox"> 
​		对象的赋值 (a.b &#x3D; xx)</p>
</li>
<li><p><input checked="" disabled="" type="checkbox"> 
​		访问对象的所有属性（Object.keys）</p>
</li>
<li><p><input checked="" disabled="" type="checkbox"> 
​		删除对象的键值对 (delete )</p>
</li>
<li><p><input checked="" disabled="" type="checkbox"> 
​		检查属性（键） 是否存在 (in)</p>
</li>
<li><p><input checked="" disabled="" type="checkbox"> 
​		遍历 (for …in)</p>
</li>
<li><p><input checked="" disabled="" type="checkbox"> 
​		对象的访问 (object.a 访问object的a属性)</p>
</li>
<li><p><input checked="" disabled="" type="checkbox"> 
​		了解对象的引用</p>
<p>​			var a &#x3D; {b:1}  var c &#x3D; a</p>
<p>​			a.b &#x3D; 2 </p>
<p>​			console.log(c.b) &#x2F;&#x2F; 打印c.b&#x3D;1</p>
<p>​			&#x2F;&#x2F; 从引用的角度去思考，为什么对象c发生了变化。可以用展开运算符…来定义一个新的对象</p>
</li>
<li><p><input checked="" disabled="" type="checkbox"> 
​		object的方法 <a href="https://www.w3school.com.cn/js/js_object_methods.asp">https://www.w3school.com.cn/js/js_object_methods.asp</a></p>
</li>
<li><p><input checked="" disabled="" type="checkbox"> 
​		this关键字(重要)</p>
</li>
</ul>
<p>4.function 函数<br>        函数的声明<br>            function fn() {} &#x2F;&#x2F; function 声明<br>            var fn &#x3D; function() {} &#x2F;&#x2F; 变量声明<br>            var fn &#x3D; new Function() {} &#x2F;&#x2F; 使用Function构造，了解就好，很少使用<br>        函数的参数<br>            function fn(text){ &#x2F;&#x2F; 变量text是形式参数<br>                return text &#x2F;&#x2F; return  关键词将返回指定的值<br>            }<br>        函数的调用<br>            fn() &#x2F;&#x2F; 调用fn函数<br>            fn(1,2) &#x2F;&#x2F; 传入实际参数<br>            call方法 <a href="https://www.w3school.com.cn/js/js_function_call.asp">https://www.w3school.com.cn/js/js_function_call.asp</a><br>            apply方法 <a href="https://www.w3school.com.cn/js/js_function_apply.asp">https://www.w3school.com.cn/js/js_function_apply.asp</a></p>
<p>​		重复声明函数，会覆盖原有的定义<br>​			function fn() {<br>​				console.log(1)<br>​			}	<br>​			function fn() {<br>​				console.log(2)<br>​			}<br>​		递归<br>​			反复调用自身<br>​			了解递归的定义和实现思路，<br>​				 计算斐波那契数列 的函数如何实现</p>
<ul>
<li><p><input disabled="" type="checkbox"> 
​		了解函数的作用域</p>
</li>
<li><p><input disabled="" type="checkbox"> 
​			函数内部可以读取到外部定义的变量</p>
</li>
<li><p><input disabled="" type="checkbox"> 
​			函数内部定义的变量，无法被外部读取</p>
<p>​			var a &#x3D; 5</p>
<p>​			function fn() {</p>
<p>​				var b &#x3D; 10</p>
<p>​				console.log(b)</p>
<p>​				console.log(a)</p>
<p>​			}</p>
<p>​			console.log(b)</p>
</li>
<li><p><input disabled="" type="checkbox"> 
​		arguments对象，可以获取参数</p>
<p>​			&#x2F;&#x2F; 可以等看过数组再回头看这个</p>
<p>​			var add &#x3D; function (a,b) {</p>
<p>​				console.log(arguments[0]) </p>
<p>​			}</p>
</li>
<li><p><input disabled="" type="checkbox"> 
​		闭包(后续再理解)</p>
<p>​			理解一下定义，后续再了解深入的原因</p>
<p>​			<a href="https://www.w3school.com.cn/js/js_function_closures.asp">https://www.w3school.com.cn/js/js_function_closures.asp</a></p>
</li>
</ul>
<p>​		5.数组(array)</p>
<ul>
<li><p><input checked="" disabled="" type="checkbox"> 
​		数组的定义</p>
</li>
<li><p><input disabled="" type="checkbox"> 
​		声明数组</p>
<p>​			var arr &#x3D; [11,22,33]</p>
<p>​			var arr &#x3D; new Array([11,22,33])</p>
</li>
<li><p><input checked="" disabled="" type="checkbox"> 
​		数组的访问</p>
</li>
<li><p><input checked="" disabled="" type="checkbox"> 
​		数组的长度</p>
<p>​			arr.length (length属性)</p>
</li>
<li><p><input checked="" disabled="" type="checkbox"> 
​		通过索引访问，从0开始</p>
<p>​			arr[0] &#x2F;&#x2F; 第一个元素</p>
<p>​			arr[arr.length-1] &#x2F;&#x2F; 最后一个元素</p>
</li>
<li><p><input checked="" disabled="" type="checkbox"> 
​		循环</p>
<p>​			for</p>
<p>​			for in </p>
</li>
<li><p><input disabled="" type="checkbox"> 
​		数组的方法:</p>
<p>​			<a href="https://www.w3school.com.cn/js/js_array_methods.asp">https://www.w3school.com.cn/js/js_array_methods.asp</a></p>
<p>​			<a href="https://www.w3school.com.cn/js/js_array_sort.asp">https://www.w3school.com.cn/js/js_array_sort.asp</a></p>
<p>​			<a href="https://www.w3school.com.cn/js/js_array_iteration.asp">https://www.w3school.com.cn/js/js_array_iteration.asp</a></p>
</li>
</ul>
<h2 id="1-分类"><a href="#1-分类" class="headerlink" title="1.分类"></a>1.分类</h2><p>​		1.ECMAJS：基础语法</p>
<p>​		2.DOM：文档对象模型，可以访问某个元素</p>
<p>​		3.BOM：浏览器对象模型，可以对浏览器操作</p>
<h2 id="2-基础语法"><a href="#2-基础语法" class="headerlink" title="2.基础语法"></a>2.基础语法</h2><p>​	作为属性引用：console.log();    document.write();</p>
<p>​	外部引用1：head里写<code>&lt;script src=&quot;js文件名称.js&quot;&gt;不允许出现任何js代码&lt;/script&gt;</code></p>
<p>​	内部引用：《script》需要出现js代码《&#x2F;script》</p>
<p>​	多文件引用:<code>&lt;script src=&quot;/js/script1.js&quot;&gt;&lt;/script&gt; </code><br>​			   		 <code>&lt;script src=&quot;/js/script2.js&quot;&gt;&lt;/script&gt;</code></p>
<p>​	注释：&#x2F;&#x2F; 			 &#x2F;**&#x2F;</p>
<p>​	易错点：大小写敏感</p>
<h2 id="3-变量与作用域"><a href="#3-变量与作用域" class="headerlink" title="3.变量与作用域"></a>3.变量与作用域</h2><p>变量：</p>
<p>​		局部变量：   var 变量名&#x3D;   ；</p>
<p>​						  或者    var 变量名； 变量名&#x3D;   ；</p>
<p>​		全局变量：  变量名&#x3D;   ； </p>
<p>​		多个变量：  var 变量名1&#x3D;值1,变量名2,变量名3,变量名4&#x3D;值2；</p>
<p>​		变量名命名规范：和c语言唯一的区别是可以以字母数字下划线及＄组成。</p>
<p>作用域：</p>
<p>​		JavaScript 使用大括号，将多个相关的语句组合在一起，称为“区块”（block），单并不构成单独的作用域。</p>
<p>​		对于<code>var</code>命令来说，JavaScript 的区块不构成单独的作用域（scope）。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  var a = 1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">a // 1</span><br></pre></td></tr></table></figure>



<h2 id="4-数据类型"><a href="#4-数据类型" class="headerlink" title="4.数据类型"></a>4.数据类型</h2><h4 id="1-原始类型"><a href="#1-原始类型" class="headerlink" title="1.原始类型"></a>1.原始类型</h4><p>​				<a href="https://wangdoc.com/javascript/types/general#typeof-%E8%BF%90%E7%AE%97%E7%AC%A6">数据类型概述 - JavaScript 教程 - 网道 (wangdoc.com)</a>（非常详细且有用，不要只看自己的笔记）</p>
<h5 id="1-分类-1"><a href="#1-分类-1" class="headerlink" title="1.分类"></a>1.分类</h5><p>​				1.unmber数字类型</p>
<p>​						整数：4字节32位</p>
<p>​						小数（浮点数）：8字节64位</p>
<p>​				2.string字符串                         </p>
<p>​						方法: <a href="https://www.w3school.com.cn/js/js_string_methods.asp">https://www.w3school.com.cn/js/js_string_methods.asp</a></p>
<p>​						转义:斜杠(\ “hello \ “)</p>
<p>​						方法：</p>
<p>​								charAt() - 返回指定索引位置的字符<br>​								<strong>charCodeAt() - 返回指定索引位置字符的 Unicode 编码</strong><br>​								<strong>concat() - 连接两个字符串</strong><br>​								endsWith() - 检查字符串是否以指定的字符结束<br>​								<strong>includes() - 检查字符串是否包含指定的字符</strong><br>​								indexOf() - 检索字符首次出现的索引位置<br>​								lastIndexOf() - 从后向前检索字符最后一次出现的索引位置<br>​								<strong>localeCompare() - 根据本地排序规则比较两个字符串</strong><br>​								<strong>match() - 找到一个或多个正则表达式的匹配</strong><br>​								<strong>replace() - 替换与正则表达式匹配的子串</strong><br>​								<strong>search() - 检索与正则表达式相匹配的值</strong><br>​								<strong>slice() - 提取字符串的片断,并返回新的字符串</strong><br>​								<strong>split() - 把字符串分割为字符串数组</strong><br>​								startsWith() - 检查字符串是否以指定的字符开始<br>​								substring() - 提取字符串中两个指定的索引位置之间的字符<br>​								toLowerCase() - 转换字符串为小写<br>​								toUpperCase() - 转换字符串为大写<br>​								trim() - 移除字符串首尾空白</p>
<p>例如:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">js</span><br><span class="line">let str = &quot;Hello World!&quot;;</span><br><span class="line"></span><br><span class="line">str.charAt(0);     // H</span><br><span class="line">str.concat(&quot;Claude&quot;); // Hello World!Claude</span><br><span class="line">str.endsWith(&quot;d!&quot;);  // true</span><br><span class="line">str.includes(&quot;o&quot;);   // true </span><br><span class="line">str.indexOf(&quot;o&quot;);    // 4</span><br><span class="line">str.lastIndexOf(&quot;o&quot;); // 7 </span><br><span class="line">str.match(/o/g);     // [&quot;o&quot;, &quot;o&quot;, &quot;o&quot;]</span><br><span class="line">str.replace(&quot;o&quot;, &quot;_&quot;); // Hell_ W_rld!</span><br><span class="line">str.slice(0, 5);     // Hello</span><br><span class="line">str.split(&quot; &quot;);      // [&quot;Hello&quot;, &quot;World!&quot;]</span><br><span class="line">str.startsWith(&quot;He&quot;); // true</span><br><span class="line">str.substring(0, 5);  // Hello </span><br><span class="line">str.toUpperCase();   // HELLO WORLD!</span><br></pre></td></tr></table></figure>

<p>​				3.boolean布尔</p>
<p>​				4.null空</p>
<p>​				5.undefined未定义		声明变量未赋值，访问对象不存在</p>
<p>​					</p>
<h5 id="2-数据转换"><a href="#2-数据转换" class="headerlink" title="2.数据转换"></a>2.数据转换</h5><p>​				取类型并赋值：typeof（）</p>
<p>​										   作用：判断变量是否未定义的同时，避免抛出错误。</p>
<p>​												  	<img src="../其它/markdown-img\Q4-JS-1基础.assets\image-20230408212824971.png" alt="image-20230408212824971" style="zoom:50%;" /></p>
<p>​				判断是否为数字类型：isNaN</p>
<p>​				强制转换字符串：变量.toString（）</p>
<p>​				强制转换整数（小数点后的全部舍掉）：parseInt（数据）；</p>
<p>​				强制转换小数：parseFloat（数据）；</p>
<p>​										易错点：如果数据里包含非数字型数据，则会输出转换好的数据，并停止转换异常数据。</p>
<p>​										例子：var  i &#x3D; parseFloat（13.2你好442）；将会输出13.2。</p>
<h4 id="2-引用类型"><a href="#2-引用类型" class="headerlink" title="2.引用类型"></a>2.引用类型</h4><h2 id="5-运算符"><a href="#5-运算符" class="headerlink" title="5.运算符"></a>5.运算符</h2><h4 id="1-算数运算符"><a href="#1-算数运算符" class="headerlink" title="1.算数运算符"></a>1.算数运算符</h4><h4 id="2-关系运算符"><a href="#2-关系运算符" class="headerlink" title="2.关系运算符"></a>2.关系运算符</h4><p>​				<img src="../其它/markdown-img\Q4-JS-1基础.assets\image-20230408111058932.png" alt="image-20230408111058932" style="zoom: 33%;" /></p>
<p>​					</p>
<p>​					&#x3D;&#x3D;与&#x3D;&#x3D;&#x3D;的区别：&#x3D;&#x3D;会使两侧进行类型转换，并比较。&#x3D;&#x3D;&#x3D;会严格比较类型和数据。</p>
<h4 id="3-逻辑运算符"><a href="#3-逻辑运算符" class="headerlink" title="3.逻辑运算符"></a>3.逻辑运算符</h4><p>​					<img src="../其它/markdown-img\Q4-JS-1基础.assets\image-20230408111154450.png" alt="image-20230408111154450" style="zoom: 50%;" /></p>
<h4 id="4-条件-x2F-三目运算符"><a href="#4-条件-x2F-三目运算符" class="headerlink" title="4.条件&#x2F;三目运算符"></a>4.条件&#x2F;三目运算符</h4><p>​					普通：</p>
<p>​					<img src="../其它/markdown-img\Q4-JS-1基础.assets\image-20230408111436303.png" alt="image-20230408111436303" style="zoom:33%;" /></p>
<p>​					嵌套：</p>
<p>​					<img src="../其它/markdown-img\Q4-JS-1基础.assets\image-20230408111514675.png" alt="image-20230408111514675" style="zoom:33%;" /></p>
<h2 id="6-标签（label）"><a href="#6-标签（label）" class="headerlink" title="6.标签（label）"></a>6.标签（label）</h2><p>JavaScript 语言允许，语句的前面有标签（label），相当于定位符，用于跳转到程序的任意位置，标签的格式如下。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">label:</span><br><span class="line">  语句</span><br></pre></td></tr></table></figure>

<p>标签可以是任意的标识符，但不能是保留字，语句部分可以是任意语句。</p>
<p>标签通常与<code>break</code>语句和<code>continue</code>语句配合使用，跳出特定的循环。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">top:</span><br><span class="line">  for (var i = 0; i &lt; 3; i++)&#123;</span><br><span class="line">    for (var j = 0; j &lt; 3; j++)&#123;</span><br><span class="line">      if (i === 1 &amp;&amp; j === 1) break top;</span><br><span class="line">      console.log(&#x27;i=&#x27; + i + &#x27;, j=&#x27; + j);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">// i=0, j=0</span><br><span class="line">// i=0, j=1</span><br><span class="line">// i=0, j=2</span><br><span class="line">// i=1, j=0</span><br></pre></td></tr></table></figure>

<p>上面代码为一个双重循环区块，<code>break</code>命令后面加上了<code>top</code>标签（注意，<code>top</code>不用加引号），满足条件时，直接跳出双层循环。如果<code>break</code>语句后面不使用标签，则只能跳出内层循环，进入下一次的外层循环。</p>
<p>标签也可以用于跳出代码块。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">foo: &#123;</span><br><span class="line">  console.log(1);</span><br><span class="line">  break foo;</span><br><span class="line">  console.log(&#x27;本行不会输出&#x27;);</span><br><span class="line">&#125;</span><br><span class="line">console.log(2);</span><br><span class="line">// 1</span><br><span class="line">// 2</span><br></pre></td></tr></table></figure>

<p>上面代码执行到<code>break foo</code>，就会跳出区块。</p>
<p><code>continue</code>语句也可以与标签配合使用。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">top:</span><br><span class="line">  for (var i = 0; i &lt; 3; i++)&#123;</span><br><span class="line">    for (var j = 0; j &lt; 3; j++)&#123;</span><br><span class="line">      if (i === 1 &amp;&amp; j === 1) continue top;</span><br><span class="line">      console.log(&#x27;i=&#x27; + i + &#x27;, j=&#x27; + j);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">// i=0, j=0</span><br><span class="line">// i=0, j=1</span><br><span class="line">// i=0, j=2</span><br><span class="line">// i=1, j=0</span><br><span class="line">// i=2, j=0</span><br><span class="line">// i=2, j=1</span><br><span class="line">// i=2, j=2</span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>continue</code>命令后面有一个标签名，满足条件时，会跳过当前循环，直接进入下一轮外层循环。如果<code>continue</code>语句后面不使用标签，则只能进入下一轮的内层循环。</p>
<h2 id="7-分支语句"><a href="#7-分支语句" class="headerlink" title="7.分支语句"></a>7.分支语句</h2><p>1.if else</p>
<p>2.switch-case：优先用于等值判断</p>
<p>​						  <img src="./markdown-img\Q4-JS-1基础.assets\image-20230408111942096.png" alt="image-20230408111942096" style="zoom:33%;" /></p>
<p>​				1.break</p>
<p>​				2.<strong>continue用于立即终止本轮循环，返回循环结构的头部，开始下一轮循环。</strong></p>
<p>​						<img src="../其它/markdown-img\Q4-JS-1基础.assets\image-20230408205506290.png" alt="image-20230408205506290" style="zoom: 50%;" /></p>
<p>7.循环</p>
<p>1.while</p>
<p>2.do while：先执行再判断</p>
<p>​							<img src="../其它/markdown-img\Q4-JS-1基础.assets\image-20230408112304642.png" alt="image-20230408112304642" style="zoom:33%;" /></p>
<p>3.for</p>
<p>for in循环会遍历对象上所有可枚举的属性，包括从原型链继承下来的属性。 例如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">const obj = &#123; a: 1, b: 2, c: 3 &#125;;</span><br><span class="line">for (let prop in obj) &#123;</span><br><span class="line">  console.log(prop);</span><br><span class="line">&#125;</span><br><span class="line">// 输出 a, b, c</span><br></pre></td></tr></table></figure>

<p>for of是ES6中新增的遍历数据结构的循环方式，它可以遍历所有具有迭代器的数据结构（例如数组、Set、Map等）。for of循环不能直接迭代对象，因为对象不是可迭代的数据结构。 例如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">const arr = [1, 2, 3];</span><br><span class="line">for (let value of arr) &#123;</span><br><span class="line">  console.log(value);</span><br><span class="line">&#125;</span><br><span class="line">// 输出 1, 2, 3</span><br></pre></td></tr></table></figure>

<h2 id="8-数组——类型为object，而不是数组类型"><a href="#8-数组——类型为object，而不是数组类型" class="headerlink" title="8.数组——类型为object，而不是数组类型"></a>8.数组——类型为object，而不是数组类型</h2><h3 id="1-索引数组"><a href="#1-索引数组" class="headerlink" title="1.索引数组"></a>1.索引数组</h3><h5 id="1-动态数组"><a href="#1-动态数组" class="headerlink" title="1.动态数组"></a>1.动态数组</h5><p>​											var arr&#x3D;new Array（“add”，“okm”，“fnwk”）；</p>
<h5 id="2-静态数组（在JS里，这也是动态数组）"><a href="#2-静态数组（在JS里，这也是动态数组）" class="headerlink" title="2.静态数组（在JS里，这也是动态数组）"></a>2.静态数组（在JS里，这也是动态数组）</h5><p>​											var arr&#x3D;【15，1，3】；</p>
<h5 id="3-最好的方法"><a href="#3-最好的方法" class="headerlink" title="3.最好的方法"></a>3.最好的方法</h5><p>​											先声明空数组，再通过arr[index]访问并赋值。</p>
<h5 id="4-arr-length没有括号"><a href="#4-arr-length没有括号" class="headerlink" title="4.arr.length	没有括号"></a>4.arr.length	没有括号</h5><p>​											console.log（arr.length）</p>
<h5 id="5-访问倒数第n个数据"><a href="#5-访问倒数第n个数据" class="headerlink" title="5.访问倒数第n个数据"></a>5.访问倒数第n个数据</h5><p>​											倒数第一个：arr[length-1]</p>
<p>​											<strong>倒数第n个：arr[length-n]</strong></p>
<h3 id="2-关联数组-hash数组（只希望快速查找时使用）"><a href="#2-关联数组-hash数组（只希望快速查找时使用）" class="headerlink" title="2.关联数组   hash数组（只希望快速查找时使用）"></a>2.关联数组   hash数组（只希望快速查找时使用）</h3><h5 id="1-区别"><a href="#1-区别" class="headerlink" title="1.区别"></a>1.区别</h5><p>​											1.可以自定义下标名称。</p>
<p>​											2.查找快，o（1）.</p>
<p>​											3.查找不用遍历，也无法遍历。</p>
<h5 id="2-创建方式"><a href="#2-创建方式" class="headerlink" title="2.创建方式"></a>2.创建方式</h5><p>​											1.创建空数组</p>
<p>​											2.以自定义字符串为下标，给数组赋值</p>
<p>​												<img src="../其它/markdown-img\Q4-JS-1基础.assets\image-20230408132738093.png" alt="image-20230408132738093" style="zoom: 25%;" /></p>
<h5 id="3-易错点"><a href="#3-易错点" class="headerlink" title="3.易错点"></a>3.易错点</h5><p>​											不能用for循环，不能遍历，和存储位置无关</p>
<p>​											<img src="../其它/markdown-img\Q4-JS-1基础.assets\image-20230408133014313.png" alt="image-20230408133014313" style="zoom: 33%;" /></p>
<h3 id="3-数组API"><a href="#3-数组API" class="headerlink" title="3.数组API"></a>3.数组API</h3><h5 id="1-String-arr-；数组转字符串"><a href="#1-String-arr-；数组转字符串" class="headerlink" title="1.String(arr)；数组转字符串"></a>1.String(arr)；<strong>数组转字符串</strong></h5><p>​											概念：转化成字符串，并用逗号隔开。</p>
<p>​											作用：打印出arr，判断一下数据有没有被更改过。</p>
<h5 id="2-arr-join-“连接符”-；拼接数组元素"><a href="#2-arr-join-“连接符”-；拼接数组元素" class="headerlink" title="2.arr.join(“连接符”)；拼接数组元素"></a>2.arr.join(“连接符”)；<strong>拼接数组元素</strong></h5><p>​									概念：将array中每个部分，用”连接符“连接成字符串</p>
<p>​												<img src="../其它/markdown-img\Q4-JS-1基础.assets\image-20230408135220827.png" alt="image-20230408135220827" style="zoom:25%;" /></p>
<p>​									作用1：判断数组为空。</p>
<p>​									作用2：字符串连接，将数组转化为html内容。<strong>（动态页面）</strong></p>
<p>​												方法1：”&lt;开始1&gt;&lt;开始2&gt;”+arr.join(“&lt;&#x2F;结束2&gt;&lt;开始2&gt;”)+”&lt;&#x2F;结束2&gt;&lt;&#x2F;结束1&gt;“</p>
<p>​												方法2：”&lt;开始标签1&gt;”+arr.join(“&lt;&#x2F;结束标签1&gt;&lt;开始标签1&gt;”)+”&lt;&#x2F;结束标签1&gt;“</p>
<p>​												看不懂后面有说明。</p>
<h5 id="3-concat-拼接"><a href="#3-concat-拼接" class="headerlink" title="3.concat()拼接"></a>3.concat()拼接</h5><p>​								1.概念：引用并拼接多个数组（不改变原数组值），返回结果值。（表面是复制数组值并拼接，本质还是引用）</p>
<h5 id="4-arr-slice-index1，index2-查数组元素"><a href="#4-arr-slice-index1，index2-查数组元素" class="headerlink" title="4.arr.slice(index1，index2)查数组元素"></a>4.arr.slice(index1，index2)<strong>查数组元素</strong></h5><p>​								1.概念：</p>
<p>​												1.选取一个范围的：选取arr[index1]~arr[index2]的值。</p>
<p>​												2.选取到尾部的：arr.slice(index1)省略第二个值。</p>
<p>​												3.复制数组：arr.slice(0,arr.length)&#x3D;&#x3D;&#x3D;arr.slice();</p>
<p>​								2.例子：<img src="../其它/markdown-img\Q4-JS-1基础.assets\image-20230408151232135.png" alt="image-20230408151232135" style="zoom:33%;" /></p>
<p>​								3.重点：下标可以用负数</p>
<h3 id="4-arr-splice增删改数组元素"><a href="#4-arr-splice增删改数组元素" class="headerlink" title="4.arr.splice增删改数组元素"></a>4.arr.splice<strong>增删改数组元素</strong></h3><p>​								注：是改变数组本身，而不是引用。<strong>删除和插入的元素个数不必一致，数组下标会自动后移。</strong></p>
<h5 id="1-增"><a href="#1-增" class="headerlink" title="1.增"></a>1.增</h5><p>​								1.arr.splice(start,<strong>0</strong>,var1,var2….varn);</p>
<h5 id="2-删"><a href="#2-删" class="headerlink" title="2.删"></a>2.删</h5><p>​								1.arr.splice(start,n);</p>
<p>​										删除从start开始的（含start）n个元素，<strong>返回值为被删除数据组成的临时数组</strong>。</p>
<h5 id="3-改"><a href="#3-改" class="headerlink" title="3.改"></a>3.改</h5><p>​								1.arr.splice(start,n,<strong>var1,var2….varn</strong>);</p>
<p>​										删除从start开始的（含start）n个元素，并用n种var填充。</p>
<p>​								2.arr.splice(start,n,<strong>…arr2</strong>);</p>
<p>​										删除从start开始的（含start）n个元素，并用数组的所有值填充。<strong>易错点：…必须有</strong></p>
<p>​								3.例<img src="../其它/markdown-img\Q4-JS-1基础.assets\image-20230408155222560.png" alt="image-20230408155222560" style="zoom: 50%;" /></p>
<h4 id="5-颠倒arr-reverse"><a href="#5-颠倒arr-reverse" class="headerlink" title="5.颠倒arr.reverse();"></a>5.颠倒arr.reverse();</h4><p>​							只颠倒，不排序。</p>
<h4 id="6-排序arr-sort"><a href="#6-排序arr-sort" class="headerlink" title="6.排序arr.sort();"></a>6.排序arr.sort();</h4><p>​							缺点：默认将所有类型转成字符串，再从小到大排序。</p>
<p>​							解决方法：重构比较函数。</p>
<blockquote>
<p>arr.join()说明</p>
<p>​			arr.join()<code>方法取出的是数组</code>arr<code>中的每个元素，将它们用</code>&lt;&#x2F;结束标签&gt;&lt;开始标签&gt;&#96; 连接起来形成一个新的字符串。</p>
<p>​			&lt;开始标签1&gt;<code>和</code>&lt;&#x2F;结束标签1&gt;<code>是代码里本来就有的标签，分别表示HTML元素的开始标签和结束标签；而</code>&lt;开始标签2&gt;<code>和</code>&lt;&#x2F;结束标签2&gt;&#96;是你添加进去的标签。</p>
<p>​			<code>arr.join()</code>方法取出的是数组<code>arr</code>中的每个元素，可以是任何类型的值，例如字符串或数字。将它们用<code>&lt;/结束标签2&gt;&lt;开始标签2&gt;</code>连接起来形成一个新的字符串。这里的<code>&lt;/结束标签2&gt;&lt;开始标签2&gt;</code>是你添加的标签内容。</p>
<p>以下是一个例子：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">let arr = [&#x27;apple&#x27;, &#x27;banana&#x27;, &#x27;orange&#x27;];</span><br><span class="line">let result = &#x27;&lt;ul&gt;&lt;li&gt;&#x27; + arr.join(&#x27;&lt;/li&gt;&lt;li&gt;&#x27;) + &#x27;&lt;/li&gt;&lt;/ul&gt;&#x27;;</span><br><span class="line">console.log(result);</span><br></pre></td></tr></table></figure>

<p>​			在这个例子中，<code>&lt;开始标签1&gt;</code>是<code>&lt;ul&gt;</code>，<code>&lt;/结束标签1&gt;</code>是<code>&lt;/ul&gt;</code>，<code>&lt;开始标签2&gt;</code>是<code>&lt;li&gt;</code>，<code>&lt;/结束标签2&gt;</code>是<code>&lt;/li&gt;</code>。<code>arr.join(&#39;&lt;/li&gt;&lt;li&gt;&#39;)</code>取出的数组值是<code>&#39;apple&#39;</code>、<code>&#39;banana&#39;</code>和<code>&#39;orange&#39;</code>，它们将被用<code>&lt;/li&gt;&lt;li&gt;</code>连接起来形成一个新的字符串<code>&#39;apple&lt;/li&gt;&lt;li&gt;banana&lt;/li&gt;&lt;li&gt;orange&#39;</code>，最后生成的完整HTML元素如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;ul&gt;</span><br><span class="line">  &lt;li&gt;apple&lt;/li&gt;</span><br><span class="line">  &lt;li&gt;banana&lt;/li&gt;</span><br><span class="line">  &lt;li&gt;orange&lt;/li&gt;</span><br><span class="line">&lt;/ul&gt;</span><br></pre></td></tr></table></figure>

<p>​			该HTML元素包含了多个子元素，子元素的内容从数组<code>arr</code>中取出，并且用<code>&lt;li&gt;</code>和<code>&lt;/li&gt;</code>标签包裹起来，每个子元素之间用<code>&lt;/li&gt;&lt;li&gt;</code>连接，而这些子元素整体则用<code>&lt;ul&gt;</code>和<code>&lt;/ul&gt;</code>标签包裹。</p>
</blockquote>
<p>​							</p>
<h2 id="9-函数"><a href="#9-函数" class="headerlink" title="9.函数"></a>9.函数</h2><p>1.输出：console.log();</p>
]]></content>
      <categories>
        <category>code</category>
        <category>note</category>
      </categories>
      <tags>
        <tag>JS</tag>
      </tags>
  </entry>
  <entry>
    <title>JS学习笔记-4.2JS标准库（base mooc）</title>
    <url>/2023/04/08/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/JS/Q4-JS-2%E6%A0%87%E5%87%86%E5%BA%93%EF%BC%88mooc%EF%BC%89/</url>
    <content><![CDATA[<h1 id="3-2JS标准库（mooc）"><a href="#3-2JS标准库（mooc）" class="headerlink" title="3.2JS标准库（mooc）"></a>3.2JS标准库（mooc）</h1><h2 id="1-Object对象"><a href="#1-Object对象" class="headerlink" title="1.Object对象"></a>1.Object对象</h2><p><a href="https://wangdoc.com/javascript/stdlib/object">Object 对象 - JavaScript 教程 - 网道 (wangdoc.com)</a></p>
<ol>
<li>Object() 是用来创建一个新的对象的构造函数；</li>
<li>Object.keys() 和 Object.getOwnPropertyNames() 是用来获取对象属性名的方法；</li>
<li>Object.prototype.toString() 是判断数据类型的重要方法；</li>
<li>Object.prototype.hasOwnProperty() 可以用来判断一个对象是否包含指定的属性。</li>
</ol>
<p>需要注意的是，Object.keys()和Object.getOwnPropertyNames()这两个方法虽然类似，但是在获取对象属性名时有一些不同的地方。</p>
<h2 id="2-属性描述对象"><a href="#2-属性描述对象" class="headerlink" title="2.属性描述对象"></a>2.属性描述对象</h2><p><a href="https://wangdoc.com/javascript/stdlib/attributes">属性描述对象 - JavaScript 教程 - 网道 (wangdoc.com)</a></p>
<ol>
<li><p>Object.getOwnPropertyDescriptor() 获取对象属性的描述符，并返回一个包含属性信息的对象；</p>
<p>通常在需要了解或控制属性的特性（例如是否可枚举、可写、可配置）时使用。</p>
</li>
<li><p>Object.getOwnPropertyNames() 返回一个由一个对象自己拥有的属性名称组成的数组，不包括继承的属性名称；</p>
<p>通常用于遍历对象的属性。</p>
</li>
<li><p>Object.defineProperty() 给对象添加新属性或者修改已存在属性并返回修改后的对象；</p>
<p>通常在需要控制属性的一些特性时使用。</p>
</li>
<li><p>Object.defineProperties() 批量添加属性或修改已存在属性并返回修改后的对象；</p>
<p>通常用于一次性操作多个属性。</p>
</li>
<li><p>Object.prototype.propertyIsEnumerable() 判断对象的某个属性是否可枚举，返回一个布尔值；</p>
<p>通常用于判断对象的属性是否可以通过 for…in 循环枚举出来。</p>
</li>
<li><p>value等元属性 属性描述符对象中的 value、get 和 set 分别表示属性的值、getter 函数和 setter 函数；</p>
<p>通常用于控制属性的访问和赋值行为。</p>
</li>
<li><p>Object.preventExtensions() 禁止一个对象添加新属性并返回原对象；</p>
<p>通常在需要冻结一个对象时使用。</p>
</li>
<li><p>Object.isExtensible() 判断一个对象是否可扩展，返回一个布尔值；</p>
<p>通常用于判断对象是否可以添加新属性。</p>
</li>
<li><p>Object.seal() 让一个对象不可扩展并将其所有属性的 configurable 特性设置为 false；</p>
<p>通常用于保护对象，防止意外修改其属性。</p>
</li>
<li><p>Object.isSealed() 判断一个对象是否被封闭，返回一个布尔值；</p>
<p>通常用于判断对象是否可以添加或删除属性。</p>
</li>
<li><p>Object.freeze() 冻结一个对象并将其所有属性的 writable、configurable 特性都设置为 false；</p>
<p>通常用于保护对象，防止任何修改。</p>
</li>
<li><p>Object.isFrozen() 判断一个对象是否被冻结，返回一个布尔值；</p>
<p>通常用于判断对象是否可以被修改。</p>
</li>
</ol>
<p>这些方法在前端和 Node.js 开发中经常用得到。例如在 React 中，通过 Object.freeze() 冻结组件的 props 和 state 属性，防止意外修改；在 Vue.js 中，则通过 Object.defineProperty() 和 Object.defineProperties() 来实现双向绑定等功能。这些方法使用方便灵活，但需要注意不同方法的使用场景和属性特性，以避免出现意外错误。</p>
<ol>
<li>Object.getOwnPropertyDescriptor() - 获取一个对象上指定属性的描述符</li>
</ol>
<p>该方法用于获取一个对象上指定属性的描述符。返回一个包含获取的描述符属性的对象。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123; <span class="attr">name</span>: <span class="string">&#x27;Tom&#x27;</span>, <span class="attr">age</span>: <span class="number">20</span> &#125;</span><br><span class="line"><span class="keyword">const</span> descriptor = <span class="title class_">Object</span>.<span class="title function_">getOwnPropertyDescriptor</span>(obj, <span class="string">&#x27;name&#x27;</span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(descriptor)</span><br><span class="line"><span class="comment">// 输出: &#123; value: &#x27;Tom&#x27;, writable: true, enumerable: true, configurable: true &#125;</span></span><br></pre></td></tr></table></figure>

<ol>
<li>Object.getOwnPropertyNames() - 获取一个对象的所有属性名（包括不可遍历的属性名）</li>
</ol>
<p>该方法用于获取一个对象的所有属性名，返回一个数组，包括不可遍历的属性名。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123; <span class="attr">name</span>: <span class="string">&#x27;Tom&#x27;</span>, <span class="attr">age</span>: <span class="number">20</span> &#125;</span><br><span class="line"><span class="keyword">const</span> propertyNames = <span class="title class_">Object</span>.<span class="title function_">getOwnPropertyNames</span>(obj)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(propertyNames)</span><br><span class="line"><span class="comment">// 输出: [&quot;name&quot;, &quot;age&quot;]</span></span><br></pre></td></tr></table></figure>

<ol>
<li>Object.defineProperty() - 给一个对象定义一个新属性</li>
</ol>
<p>该方法用于给一个对象定义一个新属性。接收三个参数：对象obj、定义的属性名和属性描述符descriptor。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;&#125;</span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">defineProperty</span>(obj, <span class="string">&#x27;name&#x27;</span>, &#123;</span><br><span class="line">  <span class="attr">value</span>: <span class="string">&#x27;Tom&#x27;</span>,</span><br><span class="line">  <span class="attr">writable</span>: <span class="literal">true</span>,</span><br><span class="line">  <span class="attr">enumerable</span>: <span class="literal">false</span>,</span><br><span class="line">  <span class="attr">configurable</span>: <span class="literal">true</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj.<span class="property">name</span>) <span class="comment">// 输出: Tom</span></span><br></pre></td></tr></table></figure>

<ol>
<li>Object.defineProperties() - 给对象定义多个属性</li>
</ol>
<p>该方法用于给一个对象定义多个属性。接收两个参数：对象obj和一个包含属性名及对应属性描述符的对象。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;&#125;</span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">defineProperties</span>(obj, &#123;</span><br><span class="line">  <span class="attr">name</span>: &#123;</span><br><span class="line">    <span class="attr">value</span>: <span class="string">&#x27;Tom&#x27;</span>,</span><br><span class="line">    <span class="attr">writable</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="attr">enumerable</span>: <span class="literal">false</span>,</span><br><span class="line">    <span class="attr">configurable</span>: <span class="literal">true</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">age</span>: &#123;</span><br><span class="line">    <span class="attr">value</span>: <span class="number">20</span>,</span><br><span class="line">    <span class="attr">writable</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="attr">enumerable</span>: <span class="literal">false</span>,</span><br><span class="line">    <span class="attr">configurable</span>: <span class="literal">true</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj)</span><br><span class="line"><span class="comment">// 输出: &#123; name: &quot;Tom&quot;, age: 20 &#125;</span></span><br></pre></td></tr></table></figure>

<ol>
<li>Object.prototype.propertyIsEnumerable() - 判断一个属性是否可枚举</li>
</ol>
<p>该方法用于判断一个对象上的属性是否可以被枚举。返回一个布尔值。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123; <span class="attr">name</span>: <span class="string">&#x27;Tom&#x27;</span>, <span class="attr">age</span>: <span class="number">20</span> &#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj.<span class="title function_">propertyIsEnumerable</span>(<span class="string">&#x27;name&#x27;</span>)) <span class="comment">// 输出: true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj.<span class="title function_">propertyIsEnumerable</span>(<span class="string">&#x27;toString&#x27;</span>)) <span class="comment">// 输出: false</span></span><br></pre></td></tr></table></figure>

<ol>
<li>value等元属性 - 改变属性的描述符</li>
</ol>
<p>描述符包括（value，writable，enumerable，configurable），是属性对象的一组元属性。可以使用Object.defineProperty()或Object.defineProperties()方法更改元属性描述符。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;&#125;</span><br><span class="line"><span class="keyword">const</span> descriptor = &#123;</span><br><span class="line">  <span class="attr">value</span>: <span class="string">&#x27;Tom&#x27;</span>,</span><br><span class="line">  <span class="attr">writable</span>: <span class="literal">false</span>,</span><br><span class="line">  <span class="attr">enumerable</span>: <span class="literal">true</span>,</span><br><span class="line">  <span class="attr">configurable</span>: <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">defineProperty</span>(obj, <span class="string">&#x27;name&#x27;</span>, descriptor)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj.<span class="property">name</span>) <span class="comment">// 输出: Tom</span></span><br><span class="line">descriptor.<span class="property">value</span> = <span class="string">&#x27;Jerry&#x27;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj.<span class="property">name</span>) <span class="comment">// 输出: Tom，由于writable为false，所以值没有被改变</span></span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">freeze</span>(descriptor)</span><br><span class="line">descriptor.<span class="property">value</span> = <span class="string">&#x27;Jerry&#x27;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj.<span class="property">name</span>) <span class="comment">// 输出: Tom，由于value被冻结，所以值没有被改变</span></span><br></pre></td></tr></table></figure>

<ol>
<li>Object.preventExtensions() - 防止向一个对象添加新属性</li>
</ol>
<p>该方法用于防止向一个对象添加新属性。返回修改后的对象。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123; <span class="attr">name</span>: <span class="string">&#x27;Tom&#x27;</span>, <span class="attr">age</span>: <span class="number">20</span> &#125;</span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">preventExtensions</span>(obj)</span><br><span class="line">obj.<span class="property">gender</span> = <span class="string">&#x27;male&#x27;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj.<span class="property">gender</span>) <span class="comment">// 输出: undefined，由于已经预防拓展，gender属性没有被添加</span></span><br></pre></td></tr></table></figure>

<ol>
<li>Object.isExtensible() - 判断一个对象是否可以拓展</li>
</ol>
<p>该方法用于判断一个对象是否可以拓展。返回一个布尔值。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123; <span class="attr">name</span>: <span class="string">&#x27;Tom&#x27;</span>, <span class="attr">age</span>: <span class="number">20</span> &#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Object</span>.<span class="title function_">isExtensible</span>(obj)) <span class="comment">// 输出: true</span></span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">preventExtensions</span>(obj)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Object</span>.<span class="title function_">isExtensible</span>(obj)) <span class="comment">// 输出: false</span></span><br></pre></td></tr></table></figure>

<ol>
<li>Object.seal() - 密封一个对象，防止添加和删除属性</li>
</ol>
<p>该方法用于密封一个对象，即防止向一个对象添加和删除属性。返回修改后的对象。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123; <span class="attr">name</span>: <span class="string">&#x27;Tom&#x27;</span>, <span class="attr">age</span>: <span class="number">20</span> &#125;</span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">seal</span>(obj)</span><br><span class="line">obj.<span class="property">gender</span> = <span class="string">&#x27;male&#x27;</span></span><br><span class="line"><span class="keyword">delete</span> obj.<span class="property">age</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj)</span><br><span class="line"><span class="comment">// 输出: &#123; name: &quot;Tom&quot;, age: 20 &#125;，由于已经被封闭，gender属性没有被添加，age属性没有被删除</span></span><br></pre></td></tr></table></figure>

<ol>
<li>Object.isSealed() - 判断一个对象是否被密封</li>
</ol>
<p>该方法用于判断一个对象是否被密封。返回一个布尔值。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123; <span class="attr">name</span>: <span class="string">&#x27;Tom&#x27;</span>, <span class="attr">age</span>: <span class="number">20</span> &#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Object</span>.<span class="title function_">isSealed</span>(obj)) <span class="comment">// 输出: false</span></span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">seal</span>(obj)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Object</span>.<span class="title function_">isSealed</span>(obj)) <span class="comment">// 输出: true</span></span><br></pre></td></tr></table></figure>

<ol>
<li>Object.freeze() - 冻结一个对象，防止添加、删除和更改属性</li>
</ol>
<p>该方法用于冻结一个对象，即防止向一个对象添加、删除、更改属性。返回修改后的对象。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123; <span class="attr">name</span>: <span class="string">&#x27;Tom&#x27;</span>, <span class="attr">age</span>: <span class="number">20</span> &#125;</span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">freeze</span>(obj)</span><br><span class="line">obj.<span class="property">gender</span> = <span class="string">&#x27;male&#x27;</span></span><br><span class="line"><span class="keyword">delete</span> obj.<span class="property">age</span></span><br><span class="line">obj.<span class="property">name</span> = <span class="string">&#x27;Jerry&#x27;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj)</span><br><span class="line"><span class="comment">// 输出: &#123; name: &quot;Tom&quot;, age: 20 &#125;，由于已经被冻结，gender属性没有被添加，age属性没有被删除，name属性没有被更改</span></span><br></pre></td></tr></table></figure>

<ol>
<li>Object.isFrozen() - 判断一个对象是否被冻结</li>
</ol>
<p>该方法用于判断一个对象是否被冻结。返回一个布尔值。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123; <span class="attr">name</span>: <span class="string">&#x27;Tom&#x27;</span>, <span class="attr">age</span>: <span class="number">20</span> &#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Object</span>.<span class="title function_">isFrozen</span>(obj)) <span class="comment">// 输出: false</span></span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">freeze</span>(obj)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Object</span>.<span class="title function_">isFrozen</span>(obj)) <span class="comment">// 输出: true</span></span><br></pre></td></tr></table></figure>

<p>需要注意的是，Object.freeze()不仅会把属性的writable特性设置为false，还会把configurable特性设置为false，因此不能再通过Object.defineProperty()方法修改或删除现有属性。</p>
<h2 id="3-Array数组对象"><a href="#3-Array数组对象" class="headerlink" title="3.Array数组对象"></a>3.Array数组对象</h2><ol>
<li><p>构造函数 通过构造函数创建对象实例，由于 JS 中函数也是对象，因此也可以</p>
<p>为函数添加属性或方法。</p>
</li>
<li><p>静态方法 直接通过类（构造函数）调用的方法，而非实例方法，</p>
<p>用于对类进行操作或返回特定信息。</p>
</li>
<li><p>Array.isArray() 静态方法，判断传入的参数是否为数组，返回一个布尔值；</p>
<p>通常用于数组类型的检查。</p>
</li>
<li><p>实例方法 通过实例对象调用的方法，</p>
<p>一般用于操作实例的属性或方法。</p>
</li>
<li><p>valueOf()，toString() 均为实例方法，用于将一个对象转换成字符串或原始值；</p>
<p>通常在需要将对象转换为不同类型的数据时使用。</p>
</li>
<li><p>push()，pop() 向数组末尾添加一个或多个元素，或从数组末尾弹出一个元素；</p>
<p>通常用于对数组进行增删操作。</p>
</li>
<li><p>shift()，unshift() 向数组开头添加一个或多个元素，或从数组开头删除一个元素；</p>
<p>通常用于对数组进行增删操作。</p>
</li>
<li><p>join() 将数组转换为字符串，用指定的分隔符分隔各元素；</p>
<p>通常用于将数组内容连接为一串字符串。</p>
</li>
<li><p>concat() 将两个或多个数组合并为一个新数组；</p>
<p>通常用于将多个数组进行合并。</p>
</li>
<li><p>reverse() 将数组中的元素顺序反转；</p>
<p>通常用于对数组进行倒序排列。</p>
</li>
<li><p>slice() 返回一个数组的一部分浅拷贝，不改变原数组；</p>
<p>通常用于对数组进行截取或复制。</p>
</li>
<li><p>splice() 向数组中添加或删除元素，并返回被删除元素的数组；</p>
<p>通常用于对数组进行增删操作。</p>
</li>
<li><p>sort() 对数组进行升序或降序排列；</p>
<p>通常用于对数组进行排序。</p>
</li>
<li><p>map() 将数组中的每个元素通过函数映射为一个新的元素，并返回新数组；</p>
<p>通常用于对元素进行转换或提取。</p>
</li>
<li><p>forEach() 对数组中的每个元素执行指定的操作，不改变原数组；</p>
<p>通常用于对数组进行遍历或执行某个操作。</p>
</li>
<li><p>filter() 筛选数组中符合条件的元素并返回一个新数组；</p>
<p>通常用于对数组进行筛选或过滤。</p>
</li>
<li><p>some()，every() 均对数组中的所有元素进行指定的操作，并返回一个布尔值表示是否符合条件；</p>
<p>通常用于对数组进行条件判断。</p>
</li>
<li><p>reduce()，reduceRight() 通过对数组中的元素执行函数来将其转化为一个值并返回；</p>
<p>通常用于对数组进行聚合、求和、平均等操作。</p>
</li>
<li><p>indexOf()，lastIndexOf() 返回指定元素在数组中第一次出现的位置或最后一次出现的位置，如果未找到则返回 -1；</p>
<p>通常用于查询元素在数组中的位置。</p>
</li>
<li><p>链式使用 将以上方法进行链式调用，可简化代码且易于阅读；</p>
<p>通常用于多个数组操作进行合并，提高代码的可读性。</p>
</li>
<li><p>.length返回数组的长度</p>
</li>
</ol>
<p>在前端和 Node.js 开发中，数组的使用频率非常高。例如在 Vue.js 中，通过数组的相关方法来动态修改组件的值，从而实现数据的响应式更新。这些方法使用方便灵活，但需要注意不同方法的使用场景和不同方法之间的区别，以避免出现错误或代码可读性较差的情况。</p>
]]></content>
      <categories>
        <category>code</category>
        <category>note</category>
      </categories>
      <tags>
        <tag>JS</tag>
      </tags>
  </entry>
  <entry>
    <title>JS学习笔记-4.3脚本加载（base图灵）</title>
    <url>/2023/04/09/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/JS/Q4-JS-3%E8%84%9A%E6%9C%AC%E5%8A%A0%E8%BD%BD%E5%9F%BA%E7%A1%80%EF%BC%88%E5%9B%BE%E7%81%B5%EF%BC%89/</url>
    <content><![CDATA[<h1 id="4-3脚本的加载时机"><a href="#4-3脚本的加载时机" class="headerlink" title="4.3脚本的加载时机"></a>4.3脚本的加载时机</h1><h2 id="4-3-1script标签"><a href="#4-3-1script标签" class="headerlink" title="4.3.1script标签"></a>4.3.1script标签</h2><h3 id="1-属性"><a href="#1-属性" class="headerlink" title="1.属性"></a>1.属性</h3><p>​	1.crossorigin：可选。</p>
<p>​		配置相关请求的CORS（跨源资源共享）设置。默认不使用CORS。	</p>
<ul>
<li>​				crossorigin&#x3D;  “anonymous”配置文件请求不必设置凭据标志。</li>
<li>​				crossorigin&#x3D;”use-credentials”设置凭据 标志，意味着出站请求会包含凭据。</li>
</ul>
<p>​	2.integrity：可选。</p>
<p>​			允许比对加密签名以验证子资源完整性。用于确保中介网没有恶意篡改。</p>
<p>​	3.async：异步执行脚本, 可选。</p>
<p>​			表示立即开始下载脚本文件，但不会阻止其他资源的下载（如图片、CSS 等），也不会等待页面完全加载完毕</p>
<p>​			与<code>defer</code>不同的是，标记为<code>async</code>的脚本<strong>并不保证能按照它们出现的次序执行</strong>。</p>
<p>​			因此，该属性常用于不需要等待页面加载完毕就可以立即执行的脚本。</p>
<p>​	4.defer：可选。</p>
<p>​			表示<strong>外部脚本</strong>可以延迟到文档完全被解析和显示之后再执行。</p>
<p>​			因此，该属性常用于，我们想要延迟脚本的执行的情况。</p>
<p>5.举例</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">3.async实例</span><br><span class="line">    &lt;h1&gt;async 示例&lt;/h1&gt;</span><br><span class="line">    &lt;script src=&quot;./example.js&quot; async&gt;&lt;/script&gt;</span><br><span class="line">    &lt;p&gt;此段文字不受脚本影响，可瞬间加载。&lt;/p&gt;</span><br><span class="line"></span><br><span class="line">由于 async 属性的作用，浏览器会立即下载该 JavaScript 文件，并在下载完成后会立即执行其中的代码。同时，页面内容也会立即显示出来，而不必等待 JavaScript 文件的下载和执行。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">4.defer实例</span><br><span class="line">    &lt;h1&gt;defer 示例&lt;/h1&gt;</span><br><span class="line">    &lt;script src=&quot;./example.js&quot; defer&gt;&lt;/script&gt;</span><br><span class="line">    &lt;p&gt;此段文字受脚本影响，需要等待脚本完成执行后才能完全加载。&lt;/p&gt;</span><br><span class="line"></span><br><span class="line">由于 defer 属性的作用，浏览器会延迟 JavaScript 文件的执行，直到页面完全加载完毕并且 JavaScript 文件下载完成后才会执行其中的代码。在执行完脚本后，页面内容也会完全显示出来。需要注意的是，如果有多个带有 defer 属性的脚本文件，它们会按照它们在文档中出现的顺序依次执行。</span><br><span class="line"></span><br><span class="line">综上所述，async 和 defer 属性可以用来控制 JavaScript 文件的下载和执行时间，从而优化页面加载速度和用户体验。</span><br></pre></td></tr></table></figure>

<h2 id="4-3-2动态加载脚本（未细看）"><a href="#4-3-2动态加载脚本（未细看）" class="headerlink" title="4.3.2动态加载脚本（未细看）"></a>4.3.2动态加载脚本（未细看）</h2><h3 id="1-本质"><a href="#1-本质" class="headerlink" title="1.本质"></a>1.本质</h3><p>因为JavaScript可以使用DOM API，所以通过向DOM中动态添加<code>script</code>元素同样可以加载指定的脚本。只要创建一个<code>script</code>元素并将其添加到DOM即可。</p>
<h3 id="2-实例"><a href="#2-实例" class="headerlink" title="2.实例"></a>2.实例</h3><p>JavaScript 代码可以通过创建 script 元素并将其添加到 DOM 中的方式来加载脚本。以下是一个示例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">javascript复制代码// 创建一个 script 元素</span><br><span class="line">let script = document.createElement(&#x27;script&#x27;);</span><br><span class="line">// 设置该 script 元素要加载的 JavaScript 脚本文件路径</span><br><span class="line">script.src = &#x27;gibberish.js&#x27;;</span><br><span class="line">// 将创建的 script 元素添加到 head 元素中</span><br><span class="line">document.head.appendChild(script);</span><br></pre></td></tr></table></figure>

<p>这段代码首先使用 <code>document.createElement()</code> 方法创建一个 <code>script</code> 元素，然后将要加载的 JavaScript 文件路径设置为 <code>script.src</code> 属性的值，并将创建的 <code>script</code> 元素添加到了 <code>head</code> 元素中。</p>
<p>需要注意的是，默认情况下以这种方式创建的 <code>script</code> 元素都是以异步方式加载的，相当于添加了 <code>async</code> 属性。这意味着，当执行到上述代码时，浏览器会立即开始下载指定的 JavaScript 文件，但不会阻止其他资源（如图片、CSS 等）的下载，也不会等待页面内容完全加载完毕。</p>
<p>如果要统一动态脚本的加载行为，可以明确设置为同步加载。在上述示例代码中，只需要为创建的 <code>script</code> 元素设置 <code>async</code> 属性的值为 <code>false</code> 即可：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">javascript复制代码// 创建一个 script 元素</span><br><span class="line">let script = document.createElement(&#x27;script&#x27;);</span><br><span class="line">// 设置该 script 元素要加载的 JavaScript 脚本文件路径</span><br><span class="line">script.src = &#x27;gibberish.js&#x27;;</span><br><span class="line">// 明确设置该 script 元素以同步方式加载</span><br><span class="line">script.async = false;</span><br><span class="line">// 将创建的 script 元素添加到 head 元素中</span><br><span class="line">document.head.appendChild(script);</span><br></pre></td></tr></table></figure>

<p>需要注意的是，以这种方式获取的资源对浏览器预加载器是不可见的，这意味着它们在资源获取队列中的优先级比较低。如果想要让预加载器知道这些动态请求的文件存在，可以在文档头部显式声明它们：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">html复制代码&lt;!-- 显式声明要预加载的 JavaScript 文件 --&gt;</span><br><span class="line">&lt;link rel=&quot;preload&quot; href=&quot;gibberish.js&quot;&gt;</span><br></pre></td></tr></table></figure>

<p>在上述示例代码中，使用 <code>rel</code> 属性值为 <code>preload</code> 来声明该文件是要预加载的，<code>href</code> 属性指定要加载的文件路径。</p>
<p>总之，通过动态创建 <code>script</code> 标签并将其添加到 DOM 中的方式来加载 JavaScript 脚本，可以灵活地控制 JavaScript 的加载时间，提高页面性能。但需要注意的是，如果使用异步加载，可能会影响页面其他资源的下载和渲染，而如果使用同步加载，则可能会影响页面的加载速度。因此，需要根据具体情况进行权衡和选择。</p>
<h2 id="4-3-3弱类型进行转换"><a href="#4-3-3弱类型进行转换" class="headerlink" title="4.3.3弱类型进行转换"></a>4.3.3弱类型进行转换</h2><p>​		JS是弱类型，想要类型转换不用强制类型转换</p>
<p>​		var  a&#x3D;“asdf”；</p>
<p>​		a&#x3D;100；&#x2F;&#x2F;a由string类型转换为number类型。</p>
<h2 id="4-3-4小结"><a href="#4-3-4小结" class="headerlink" title="4.3.4小结"></a>4.3.4小结</h2><p>JavaScript是通过<code>&lt;script&gt;</code>元素插入到HTML页面中的。这个元素可用于把JavaScript代码嵌入到HTML页面中，跟其他标记混合在一起，也可用于引入保存在外部文件中的JavaScript。本章的重点可以总结如下。</p>
<ul>
<li>要包含外部JavaScript文件，必须将<code>src</code>属性设置为要包含文件的URL。文件可以跟网页在同一台服务器上，也可以位于完全不同的域。</li>
<li>所有<code>&lt;script&gt;</code>元素会依照它们在网页中出现的次序被解释。在不使用<code>defer</code>和<code>async</code>属性的情况下，包含在<code>&lt;script&gt;</code>元素中的代码必须严格按次序解释。</li>
<li>对不推迟执行的脚本，浏览器必须解释完位于<code>&lt;script&gt;</code>元素中的代码，然后才能继续渲染页面的剩余部分。为此，通常应该把<code>&lt;script&gt;</code>元素放到页面末尾，介于主内容之后及<code>&lt;/body&gt;</code>标签之前。</li>
<li>可以使用<code>defer</code>属性把脚本推迟到文档渲染完毕后再执行。推迟的脚本原则上按照它们被列出的次序执行。</li>
<li>可以使用<code>async</code>属性表示脚本不需要等待其他脚本，同时也不阻塞文档渲染，即异步加载。异步脚本不能保证按照它们在页面中出现的次序执行。</li>
<li>通过使用<code>&lt;noscript&gt;</code>元素，可以指定在浏览器不支持脚本时显示的内容。如果浏览器支持并启用脚本，则<code>&lt;noscript&gt;</code>元素中的任何内容都不会被渲染。</li>
</ul>
]]></content>
      <categories>
        <category>code</category>
        <category>note</category>
      </categories>
      <tags>
        <tag>JS</tag>
      </tags>
  </entry>
  <entry>
    <title>JS学习笔记-4.5语法基础（base阮一峰/gpt ）</title>
    <url>/2023/04/11/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/JS/Q4-JS-5%E8%AF%AD%E6%B3%95%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<h1 id="4-5语法基础"><a href="#4-5语法基础" class="headerlink" title="4.5语法基础"></a>4.5语法基础</h1><h2 id="4-5-1数据类型转换"><a href="#4-5-1数据类型转换" class="headerlink" title="4.5.1数据类型转换"></a>4.5.1数据类型转换</h2><h2 id="4-5-2错误处理机制"><a href="#4-5-2错误处理机制" class="headerlink" title="4.5.2错误处理机制"></a>4.5.2错误处理机制</h2><h3 id="1-抛出异常"><a href="#1-抛出异常" class="headerlink" title="1.抛出异常"></a>1.抛出异常</h3><p>在 JavaScript 中,throw 语句用于抛出一个异常并停止运行。</p>
<p>1.函数参数校验</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function divide(x, y) &#123;</span><br><span class="line">  // 如果 y 为 0,抛出异常</span><br><span class="line">  if (y === 0) &#123; </span><br><span class="line">    throw &#x27;除数不能为 0&#x27;; </span><br><span class="line">  &#125;</span><br><span class="line">  // 否则进行除法运算</span><br><span class="line">  return x / y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>2.范围或类型校验</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function getMonthName(month) &#123;</span><br><span class="line">  // 如果 month 超出 1-12 的范围,抛出异常</span><br><span class="line">  if (month &lt; 1 || month &gt; 12) &#123;</span><br><span class="line">    throw &#x27;月份参数不在范围内&#x27;; </span><br><span class="line">  &#125;</span><br><span class="line">  // 否则返回月份名称</span><br><span class="line">  return [&#x27;January&#x27;, &#x27;February&#x27;, &#x27;March&#x27;, &#x27;April&#x27;, &#x27;May&#x27;, &#x27;June&#x27;, </span><br><span class="line">          &#x27;July&#x27;, &#x27;August&#x27;, &#x27;September&#x27;, &#x27;October&#x27;, &#x27;November&#x27;, &#x27;December&#x27;][month-1];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>3.自定义错误</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 定义自己的错误类型</span><br><span class="line">function CustomError(message) &#123;</span><br><span class="line">  this.message = message; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 之后可以抛出这个错误</span><br><span class="line">function doSomething() &#123;</span><br><span class="line">  // 如果出现错误情况,抛出自定义错误</span><br><span class="line">  if (someCondition) &#123;</span><br><span class="line">    throw new CustomError(&#x27;something went wrong!&#x27;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<p>4.终止程序执行</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 如果出现非常严重的错误,终止程序执行</span><br><span class="line">if (someSeriousError) &#123;</span><br><span class="line">  throw &#x27;程序遇到严重错误,终止执行&#x27;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="1-小结"><a href="#1-小结" class="headerlink" title="1.小结"></a>1.小结</h3><p>​	  1. 参数校验和输入验证</p>
<ol start="2">
<li>自定义错误和异常</li>
<li>严重错误情况下终止程序执行它使我们的程序在出现异常情况时可以抛出错误并准确地响应,而不是默默地失败,这是编写健壮程序的关键。</li>
</ol>
<h3 id="2尝试执行"><a href="#2尝试执行" class="headerlink" title="2尝试执行"></a>2尝试执行</h3><p>对于前端 JS 来说,try&#x2F;catch&#x2F;finally 更常用于:</p>
<ol>
<li><h4 id="捕获异常和错误处理。"><a href="#捕获异常和错误处理。" class="headerlink" title="捕获异常和错误处理。"></a>捕获异常和错误处理。</h4><p>这也是最主要和常见的用法。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//异常处理</span><br><span class="line">try &#123;</span><br><span class="line">  somethingRisky();  // 可能抛出异常的代码</span><br><span class="line">&#125; catch (e) &#123;</span><br><span class="line">  handleError(e);   // 处理异常</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><h4 id="执行环境资源管理。"><a href="#执行环境资源管理。" class="headerlink" title="执行环境资源管理。"></a>执行环境资源管理。</h4><p>比如 DOM 元素创建后,无论是否使用成功,最后都remove DOM 元素。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//dom元素（资源）管理</span><br><span class="line">let elem;</span><br><span class="line">try &#123;</span><br><span class="line">  elem = createElement();// 使用 elem</span><br><span class="line">&#125; catch (e) &#123;</span><br><span class="line">  handleError(e);</span><br><span class="line">&#125; finally &#123;</span><br><span class="line">  removeElement(elem);  // 移除 DOM 元素</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//或普通资源管理</span><br><span class="line">let resource;</span><br><span class="line">try &#123;</span><br><span class="line">  resource = acquireResource();  // 获取资源</span><br><span class="line">  // 使用资源</span><br><span class="line">&#125; finally &#123;</span><br><span class="line">  releaseResource(resource);   // 释放资源</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><h4 id="定时器和监听管理。"><a href="#定时器和监听管理。" class="headerlink" title="定时器和监听管理。"></a>定时器和监听管理。</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//定时器和事件监听器管理 </span><br><span class="line">let timer;</span><br><span class="line">try &#123;</span><br><span class="line">  timer = setTimeout(() =&gt; &#123; /* ... */ &#125;, 1000);</span><br><span class="line">  // 延时1秒后执行</span><br><span class="line">&#125; finally &#123;</span><br><span class="line">  clearTimeout(timer);   // 清除定时器</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><h4 id="互斥"><a href="#互斥" class="headerlink" title="互斥"></a>互斥</h4><p>在前端 JS 中,try&#x2F;catch&#x2F;finally 用于资源互斥的情况并不太常见。这是因为:</p>
<ol>
<li>前端 JS 大多运行在单线程环境中,不会出现复杂的互斥资源争用情况。</li>
<li>前端 JS 中较少打开文件、数据库连接等低级资源操作,所以较少资源管理和释放的需求。</li>
<li>前端 JS 的执行环境大多提供了垃圾回收机制,可以自动管理和回收资源,减少了手动资源管理的需要。</li>
</ol>
</li>
</ol>
<h3 id="5-2-2小结"><a href="#5-2-2小结" class="headerlink" title="5.2.2小结"></a>5.2.2小结</h3><p><strong>捕获异常会了就行。资源处理学了dom就会了。</strong>前端用不上自己写互斥，有自动回收（todo：看看自动回收机制，有哪里需要手动回收的地方）。</p>
<p>无论定时器是否执行成功,最后都会清除定时器,防止定时器泄露。所以总的来说,尽管 try&#x2F;catch&#x2F;finally 也可用于资源互斥,但在前端 JS 中,更主要的是用于异常捕获、资源和执行环境管理。而复杂的低级资源互斥则较少出现。<br>无论 try 块中是否发生异常,finally 块中的代码都一定会执行,主要用于资源清理。catch 块用于捕获 try 块中的异常,并进行处理。</p>
<h2 id="4-5-3编程风格"><a href="#4-5-3编程风格" class="headerlink" title="4.5.3编程风格"></a>4.5.3编程风格</h2>]]></content>
      <categories>
        <category>code</category>
        <category>note</category>
      </categories>
      <tags>
        <tag>JS</tag>
      </tags>
  </entry>
  <entry>
    <title>JS学习笔记-4.4语言基础（base图灵）</title>
    <url>/2023/04/10/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/JS/Q4-JS-4%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%EF%BC%88%E5%9B%BE%E7%81%B5%EF%BC%89/</url>
    <content><![CDATA[<h1 id="4-4语言基础"><a href="#4-4语言基础" class="headerlink" title="4.4语言基础"></a>4.4语言基础</h1><h2 id="4-4-1标识符"><a href="#4-4-1标识符" class="headerlink" title="4.4.1标识符"></a>4.4.1标识符</h2><p>所谓<strong>标识符</strong>，就是变量、函数、属性或函数参数的名称。标识符可以由一或多个下列字符组成：</p>
<ul>
<li>开头：字母、下划线或美元符$；</li>
<li>剩下：字母数字下划线美元符。</li>
</ul>
<h2 id="4-4-2三种声明变量的方法"><a href="#4-4-2三种声明变量的方法" class="headerlink" title="4.4.2三种声明变量的方法"></a>4.4.2三种声明变量的方法</h2><h3 id="1-var"><a href="#1-var" class="headerlink" title="1.var"></a>1.var</h3><p>​		1.基本知识</p>
<p>​					<strong>var作用域</strong>：函数的局部变量。</p>
<p>​					<strong>var的冗余声明</strong>：允许，所以很有可能在冗余声明后造成脏数据问题。</p>
<p>​					<strong>var的全局变量声明</strong>：想让let在函数里也能变成全局变量，就干脆不声明变量，直接用。比如在函数里直接写age&#x3D;30；</p>
<p>​		2.声明提升</p>
<p>​					var声明在后面也行，ECMAScript会自动把它提升到第一行。</p>
<h3 id="2-let"><a href="#2-let" class="headerlink" title="2.let"></a>2.let</h3><p>​		1.基本知识</p>
<p>​					<strong>let作用域</strong>：块级的局部变量。（块级就是for之类的也算）</p>
<p>​					<strong>let的冗余声明</strong>：不允许。就是不能在同一个块内let  a；let a；</p>
<p>​					<strong>let的全局变量声明</strong>：let写在全局里可以在页面生命周期内使用，但永远也不可能变成全局变量，它的类型只会是undefined。</p>
<p>​		2.声明提升</p>
<p>​					let不会声明提升，声明必须写在第一行。</p>
<p>​		3.用处</p>
<p>​					写在for循环里。</p>
<h3 id="3-const"><a href="#3-const" class="headerlink" title="3.const"></a><strong>3.const</strong></h3><p>​		1.基本知识</p>
<p>​					<strong>const重点</strong>：常量必须给初始值，且不能更改。</p>
<p>​					<strong>const作用域</strong>：和let一样</p>
<p>​					<strong>const的冗余声明</strong>：和let一样</p>
<p>​					<strong>let的全局变量声明</strong>：和let一样	</p>
<ol start="2">
<li>易错点<br>const 定义的变量不能被重新赋值,但是如果是对象或数组,其内部的属性是可以被修改的。<br>const 只保证变量名的指针是固定的,指向的对象或数组的内部状态是可以被修改的。</li>
</ol>
<h2 id="4-4-3小结"><a href="#4-4-3小结" class="headerlink" title="4.4.3小结"></a>4.4.3小结</h2><ol>
<li><h3 id="不使用var"><a href="#不使用var" class="headerlink" title="不使用var"></a>不使用var</h3><p>有了<code>let</code>和<code>const</code>，大多数开发者会发现自己不再需要<code>var</code>了。限制自己只使用<code>let</code>和<code>const</code>有助于提升代码质量，因为变量有了明确的作用域、声明位置，以及不变的值。</p>
</li>
<li><h3 id="const优先，let次之"><a href="#const优先，let次之" class="headerlink" title="const优先，let次之"></a>const优先，let次之</h3><p>使用<code>const</code>声明可以让浏览器运行时强制保持变量不变，也可以让静态代码分析工具提前发现不合法的赋值操作。因此，很多开发者认为应该优先使用<code>const</code>来声明变量，只在提前知道未来会有修改时，再使用<code>let</code>。这样可以让开发者更有信心地推断某些变量的值永远不会变，同时也能迅速发现因意外赋值导致的非预期行为。</p>
</li>
<li><h3 id="const有易错点"><a href="#const有易错点" class="headerlink" title="const有易错点"></a>const有易错点</h3><p>const 定义的变量不能被重新赋值,但是如果是对象或数组,其内部的属性是可以被修改的。<br>const 只保证变量名的指针是固定的,指向的对象或数组的内部状态是可以被修改的。</p>
</li>
</ol>
<p>在使用<code>var</code>的时候，最常见的问题就是对迭代变量的奇特声明和修改：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">for (var i = 0; i &lt; 5; ++i) &#123;</span><br><span class="line">    setTimeout(() =&gt; console.log(i), 0)</span><br><span class="line">&#125;</span><br><span class="line">// 你可能以为会输出0、1、2、3、4</span><br><span class="line">// 实际上会输出5、5、5、5、5</span><br></pre></td></tr></table></figure>

<p>之所以会这样，是因为在退出循环时，迭代变量保存的是导致循环退出的值：5。在之后执行超时逻辑时，所有的<code>i</code>都是同一个变量，因而输出的都是同一个最终值。</p>
<p>而在使用<code>let</code>声明迭代变量时，<strong>JavaScript引擎在后台会为每个迭代循环声明一个新的迭代变量</strong>。每个<code>setTimeout</code>引用的都是不同的变量实例，所以<code>console.log</code>输出的是我们期望的值，也就是循环执行过程中每个迭代变量的值。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">for (let i = 0; i &lt; 5; ++i) &#123;</span><br><span class="line">    setTimeout(() =&gt; console.log(i), 0)</span><br><span class="line">&#125;</span><br><span class="line">// 会输出0、1、2、3、4</span><br></pre></td></tr></table></figure>

<p>这种每次迭代声明一个独立变量实例的行为适用于所有风格的<code>for</code>循环，包括<code>for-in</code>和<code>for-of</code>循环。4.3.2标识符.</p>
<h2 id="易错点："><a href="#易错点：" class="headerlink" title="易错点："></a>易错点：</h2><p>null：空指针</p>
<p>NULL未声明的变量</p>
<h2 id="4-4-4各种符号"><a href="#4-4-4各种符号" class="headerlink" title="4.4.4各种符号"></a>4.4.4各种符号</h2><h3 id="4-4-4-1字符串连接的两种方法"><a href="#4-4-4-1字符串连接的两种方法" class="headerlink" title="4.4.4.1字符串连接的两种方法"></a>4.4.4.1字符串连接的两种方法</h3><h5 id="1"><a href="#1" class="headerlink" title="1.+"></a>1.+</h5><p>​		“adf”+“asd”</p>
<h5 id="2-x3D"><a href="#2-x3D" class="headerlink" title="2.+&#x3D;"></a>2.+&#x3D;</h5><p>​		let a&#x3D;“dfe”</p>
<p>​		let b&#x3D;“jin”</p>
<p>​		b+&#x3D;a</p>
<h3 id="4-4-4-2字符串长度"><a href="#4-4-4-2字符串长度" class="headerlink" title="4.4.4.2字符串长度"></a>4.4.4.2字符串长度</h3><h5 id="1-String-length（只能用于字符串）"><a href="#1-String-length（只能用于字符串）" class="headerlink" title="1.String.length（只能用于字符串）"></a>1.String.length（只能用于字符串）</h5><p>​		(123).length不成立</p>
<p>​		“123”.length</p>
<h3 id="4-4-4-3字符串也能当成数组用"><a href="#4-4-4-3字符串也能当成数组用" class="headerlink" title="4.4.4.3字符串也能当成数组用"></a>4.4.4.3字符串也能当成数组用</h3><h5 id="1-string-0"><a href="#1-string-0" class="headerlink" title="1.string[0]"></a>1.string[0]</h5><p>​				let string&#x3D;“asd”</p>
<p>​				string[0]</p>
<p>​				》’a’</p>
<h5 id="2-string-1"><a href="#2-string-1" class="headerlink" title="2.string[-1]"></a>2.string[-1]</h5><h5 id="3-string-n"><a href="#3-string-n" class="headerlink" title="3.string[-n]"></a>3.string[-n]</h5><h2 id="4-4-4小结"><a href="#4-4-4小结" class="headerlink" title="4.4.4小结"></a>4.4.4小结</h2><p>-*&#x2F;号，会使原始类型隐式转换成number类型</p>
<p>也就是说加减乘除里只有加号需要注意两端变量的类型（只有加号重载了）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1 - &#x27;2&#x27; // -1</span><br><span class="line">1 * &#x27;2&#x27; // 2</span><br><span class="line">1 / &#x27;2&#x27; // 0.5</span><br></pre></td></tr></table></figure>

<h2 id="4-4-5数组"><a href="#4-4-5数组" class="headerlink" title="4.4.5数组"></a>4.4.5数组</h2><h5 id="1-多维数组"><a href="#1-多维数组" class="headerlink" title="1.多维数组"></a>1.多维数组</h5><p>​		1.声明</p>
<p>​				const arr &#x3D; [</p>
<p>​				  [1, 2, 3],<br>​				  [4, 5, 6],<br>​				  [7, 8, 9],<br>​				  [[10, 11, 12], 13, 14]<br>​				];</p>
<p>​				const ourPets &#x3D; [  &#x2F;&#x2F;数组嵌套object嵌套数组</p>
<p>​			  {<br>​			    animalType: “cat”,<br>​			    names: [<br>​			      “Meowzer”,<br>​			      “Fluffy”,<br>​			      “Kit-Cat”<br>​			    ]<br>​			  },<br>​			  {<br>                animalType: “dog”,<br>                names: [<br>​     			 “Spot”,<br>                  “Bowser”,<br>                  “Frankie”<br>​			    ]<br>​			  }<br>​			];</p>
<p>​		2.访问</p>
<p>​				<strong>const subarray &#x3D; arr[3];</strong><br>​				<strong>const nestedSubarray &#x3D; arr【3]【0];</strong><br>​				<strong>const element &#x3D; arr【3]【0]【1];</strong></p>
<p>​				<strong>ourPets[0].names[1];</strong><br>​				<strong>ourPets[1].names[0];</strong></p>
<p>​		3.操作</p>
<p>​					3.1push尾插</p>
<p>​								arr.push([“a”,”b”]);</p>
<p>​					3.2pop尾删（作返回值）</p>
<p>​								arr.pop();</p>
<p>​					3.3shift头删（作返回值）</p>
<p>​								arr.shift();</p>
<p>​					3.4unshift头插</p>
<p>​								arr.unshift();</p>
<h2 id="4-4-5小结"><a href="#4-4-5小结" class="headerlink" title="4.4.5小结"></a>4.4.5小结</h2><p>无</p>
<h2 id="4-4-6函数"><a href="#4-4-6函数" class="headerlink" title="4.4.6函数"></a>4.4.6函数</h2><h1 id="1-函数也可返回undefined（说明了什么？什么时候会返回这种？用于写错代码了的时候不会报错所以不用写异常处理了是么？）"><a href="#1-函数也可返回undefined（说明了什么？什么时候会返回这种？用于写错代码了的时候不会报错所以不用写异常处理了是么？）" class="headerlink" title="1.函数也可返回undefined（说明了什么？什么时候会返回这种？用于写错代码了的时候不会报错所以不用写异常处理了是么？）"></a>1.函数也可返回undefined（说明了什么？什么时候会返回这种？用于写错代码了的时候不会报错所以不用写异常处理了是么？）</h1><h2 id="4-4-7运算符"><a href="#4-4-7运算符" class="headerlink" title="4.4.7运算符"></a>4.4.7运算符</h2><p>1.等于</p>
<p>​		&#x3D;&#x3D;</p>
<p>​		&#x3D;&#x3D;&#x3D;</p>
<p>2.不等于</p>
<p>​		!&#x3D;</p>
<p>​		!&#x3D;&#x3D;</p>
<p>3.与或非</p>
<p>​		&amp;&amp;   ||  ！</p>
<p>4.大于小于</p>
<p>​		&gt;&lt;</p>
<p>​		注：如果是原始类型比较，那就会隐式转换成number类型</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">5 &gt; &#x27;4&#x27; // true</span><br><span class="line">// 等同于 5 &gt; Number(&#x27;4&#x27;)</span><br><span class="line">// 即 5 &gt; 4</span><br></pre></td></tr></table></figure>

<h2 id="4-4-7小结"><a href="#4-4-7小结" class="headerlink" title="4.4.7小结"></a>4.4.7小结</h2><p>&lt;&gt;号，会使原始类型隐式转换成number类型</p>
<h2 id="4-4-8对象（键值对）"><a href="#4-4-8对象（键值对）" class="headerlink" title="4.4.8对象（键值对）"></a>4.4.8对象（键值对）</h2><h6 id="1-创建对象"><a href="#1-创建对象" class="headerlink" title="1.创建对象"></a>1.创建对象</h6><p>​		法一：字面量（花括号里放固定的值）</p>
<p>​				可以使用数字作为属性。 </p>
<p>​				可以省略单字字符串属性中的引号。</p>
<p>​				有非字符串属性的话，JavaScript 会自动将它们转为字符串。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> cat = &#123;</span><br><span class="line">  <span class="string">&quot;name&quot;</span>: <span class="string">&quot;Whiskers&quot;</span>,</span><br><span class="line">  <span class="string">&quot;legs&quot;</span>: <span class="number">4</span>,</span><br><span class="line">  <span class="string">&quot;tails&quot;</span>: <span class="number">1</span>,</span><br><span class="line">  <span class="string">&quot;enemies&quot;</span>: [<span class="string">&quot;Water&quot;</span>, <span class="string">&quot;Dogs&quot;</span>]</span><br><span class="line">  <span class="attr">make</span>: <span class="string">&quot;Ford&quot;</span>,</span><br><span class="line">  <span class="number">5</span>: <span class="string">&quot;five&quot;</span>,</span><br><span class="line">  <span class="string">&quot;model&quot;</span>: <span class="string">&quot;focus&quot;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>​		法二：new</p>
<p>​					var  a&#x3D;new Object（）；</p>
<p>​					a.age&#x3D;”15”;</p>
<p>​					a.name&#x3D;”xcy”;</p>
<p>​					a.sayHello&#x3D;function(){				&#x2F;&#x2F;sayHello方法，里面是个匿名函数（不传参的函数）</p>
<p>​							return “hello!!!!!!!”;</p>
<p>​					}</p>
<p>​					console.log(a.age);</p>
<p>​					</p>
<p>​		法三：构造函数(封装函数，和new一起用，相当于用于继承）</p>
<p>​					&#x2F;&#x2F;一定要用this，不然生成的多个子对象会被最后一个的值覆盖</p>
<p>​					function    Father（uname,uage）{</p>
<p>​									this.name&#x3D;uname;</p>
<p>​									this.age&#x3D;uage;</p>
<p>​									this.sayHello&#x3D;function(strHi){</p>
<p>​												return strHi;</p>
<p>​									}</p>
<p>​					}</p>
<p>​					&#x2F;&#x2F;实例化</p>
<p>​					var son&#x3D;new Father(“xcy”,”15”);</p>
<p>​					son.sayHello(“Hello!!”);</p>
<p>​					son.sayHello(“Hi~”);</p>
<h6 id="2-增加对象的新属性"><a href="#2-增加对象的新属性" class="headerlink" title="2.增加对象的新属性"></a>2.增加对象的新属性</h6><p>1.点</p>
<p>​				ourDog.bark &#x3D; “bow-wow”;</p>
<p>2.中括号</p>
<p>​				ourDog[“bark”] &#x3D; “bow-wow”;</p>
<h6 id="3-删除对象的属性"><a href="#3-删除对象的属性" class="headerlink" title="3.删除对象的属性"></a>3.删除对象的属性</h6><p>1.delete</p>
<p>​				const ourDog &#x3D; {<br>                  “name”: “Camper”,<br>​				  “legs”: 4,<br>​				  “tails”: 1,<br>​				  “friends”: [“everything!”],<br>​				  “bark”: “bow-wow”<br>​				};</p>
<p>​				delete ourDog.bark;</p>
<h6 id="4-改属性"><a href="#4-改属性" class="headerlink" title="4.改属性"></a>4.改属性</h6><p>1.点</p>
<p>​				ourDog.name &#x3D; “Happy Camper”; </p>
<p>2.中括号</p>
<p>​				 ourDog[“name”] &#x3D; “Happy Camper”;</p>
<h6 id="5-查属性"><a href="#5-查属性" class="headerlink" title="5.查属性 . []"></a>5.查属性 . []</h6><p>​		2.1用.访问属性（属性名没有空格）</p>
<p>​				const myObj &#x3D; {<br>​				  prop1: “val1”,<br>​				  prop2: “val2”<br>​				};</p>
<p>​				const prop1val &#x3D; myObj.prop1;<br>​				const prop2val &#x3D; myObj.prop2;</p>
<p>​		2.2用[]访问属性（属性名有空格）</p>
<p>​				如果属性名中包含空格，就必须使用方括号表示法来获取它的属性值。</p>
<p>​				如果属性名中包含空格，就必须使用引号（单引号或双引号）将它们包裹起来。</p>
<p>​				const myObj &#x3D; {<br>                  “Space Name”: “Kirk”,<br>​				  “More Space”: “Spock”,<br>​				  “NoSpace”: “USS Enterprise”<br>​				};</p>
<p>​				myObj[“Space Name”];<br>​				myObj[‘More Space’];<br>​				myObj[“NoSpace”];</p>
<p>​		2.3用变量访问</p>
<p>​				1.基础</p>
<p>​					const dogs &#x3D; {<br>​					  Fido: “Mutt”,<br>​					  Hunter: “Doberman”,<br>​					  Snoopie: “Beagle”<br>​					};</p>
<p>​					const myDog &#x3D; “Hunter”;<br>​					const myBreed &#x3D; dogs[myDog];<br>​					console.log(myBreed);</p>
<p>​				2.复合</p>
<p><img src="../markdown-img/Q4-JS-4语言基础（图灵）.assets\image-20230414163952811.png" alt="image-20230414163952811" style="zoom:33%;" /><img src="../markdown-img/Q4-JS-4语言基础（图灵）.assets\image-20230414174937591.png" alt="image-20230414174937591" style="zoom:50%;" /></p>
<p><img src="../markdown-img/Q4-JS-4语言基础（图灵）.assets\image-20230414164428406.png" alt="image-20230414164428406" style="zoom:50%;" /><img src="../markdown-img/Q4-JS-4语言基础（图灵）.assets\image-20230414173434503.png" alt="image-20230414173434503" style="zoom:50%;" /></p>
<p>​								</p>
<h6 id="6-查嵌套对象的属性"><a href="#6-查嵌套对象的属性" class="headerlink" title="6.查嵌套对象的属性"></a>6.查嵌套对象的属性</h6><p>​		const ourStorage &#x3D; </p>
<p>​		{<br>​		  “desk”: </p>
<p>​			  {<br>​		   		 “drawer”: “stapler”<br>​		  	},<br>​		  “cabinet”: </p>
<p>​			{<br>           	 “top drawer”:</p>
<p>​						 {<br>                              “folder1”: “a file”,<br>                              “folder2”: <strong>“secrets”</strong><br>                        },<br>                “bottom drawer”: “soda”<br>              }<br>​		};</p>
<p>​		<strong>ourStorage.cabinet[“top drawer”].folder2;</strong></p>
<h6 id="7-复杂对象举例（JS的糅杂数据结构）"><a href="#7-复杂对象举例（JS的糅杂数据结构）" class="headerlink" title="7.复杂对象举例（JS的糅杂数据结构）"></a>7.复杂对象举例（JS的糅杂数据结构）</h6><p>const ourMusic &#x3D; [<br>  {<br>    “artist”: “Daft Punk”,<br>    “title”: “Homework”,<br>    “release_year”: 1997,<br>    “formats”: [<br>      “CD”,<br>      “Cassette”,<br>      “LP”<br>    ],<br>    “gold”: true<br>  }<br>];</p>
<p><strong>提示：</strong>数组中有多个 JSON 对象的时候，对象与对象之间要用逗号隔开。</p>
<h6 id="8-判断对象是否有指定属性"><a href="#8-判断对象是否有指定属性" class="headerlink" title="8.判断对象是否有指定属性"></a>8.判断对象是否有指定属性</h6><p>1.方法</p>
<p>​		.hasOwnProperty(propname)</p>
<p>2.举例</p>
<p>​		myObj.hasOwnProperty(“top”);<br>​		myObj.hasOwnProperty(“middle”);</p>
<h6 id="9-对象遍历for-in"><a href="#9-对象遍历for-in" class="headerlink" title="9.对象遍历for  in"></a>9.对象遍历for  in</h6><p>1.取属性名（而非整个属性）</p>
<p>​		for(var k in son){</p>
<p>​		console.log（k）;</p>
<p>​		}</p>
<p>2.取属性值(只能用【】不能用   .    )</p>
<p>​		console.log（k.name);</p>
<h3 id="4-4-8小结"><a href="#4-4-8小结" class="headerlink" title="4.4.8小结"></a>4.4.8小结</h3><p>1.对象之间赋值是引用的  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">let a = new Object();  </span><br><span class="line">let b = a;                //则b===a（地址完全一样）。</span><br></pre></td></tr></table></figure>



<h3 id="4-4-9其它"><a href="#4-4-9其它" class="headerlink" title="4.4.9其它"></a>4.4.9其它</h3><h4 id="1-随机数"><a href="#1-随机数" class="headerlink" title="1.随机数"></a>1.随机数</h4><p>​	1.随机小数[0,1)</p>
<p>​			let a&#x3D;Math.random();</p>
<p>​	2.向下取整</p>
<p>​			Math.floor(a) ；</p>
<p>​	3.生成某范围内的随机数</p>
<p>​			Math.floor(Math.random() * (myMax - myMin + 1) + myMin)；</p>
<h4 id="2-递归"><a href="#2-递归" class="headerlink" title="2.递归"></a>2.递归</h4><p>​	1.</p>
<p>​	2.</p>
<p>​	3.</p>
]]></content>
      <categories>
        <category>code</category>
        <category>note</category>
      </categories>
      <tags>
        <tag>JS</tag>
      </tags>
  </entry>
  <entry>
    <title>JS学习笔记-4.6标准库（base阮一峰/claude/MDN ）</title>
    <url>/2023/04/12/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/JS/Q4-JS-6%E6%A0%87%E5%87%86%E5%BA%93/</url>
    <content><![CDATA[<h1 id="4-6标准库"><a href="#4-6标准库" class="headerlink" title="4.6标准库"></a>4.6标准库</h1><h2 id="4-6-0基础知识"><a href="#4-6-0基础知识" class="headerlink" title="4.6.0基础知识"></a>4.6.0基础知识</h2><h3 id="1-C-和-JS-中的构造函数和析构函数的异同"><a href="#1-C-和-JS-中的构造函数和析构函数的异同" class="headerlink" title="1.C++ 和 JS 中的构造函数和析构函数的异同"></a>1.C++ 和 JS 中的构造函数和析构函数的异同</h3><p>C++ 和 JS 中的构造函数和析构函数有以下的异同:异同点一:初始化资源申请以及释放。它们都是用来初始化申请资源以及释放资源的。异同点二:以类名一样的方法命名。构造函数都是以类名命名的,析构函数都是以类名加上 ~ 符号命名的。</p>
<p>不同点一:调用时机不同。</p>
<p>C++: 构造函数在对象定义时或通过 new 关键字动态分配内存时调用;析构函数在对象释放时或 delete 关键字释放内存时调用。<br>JS:构造函数在通过 new 关键字调用时执行;没有析构函数的概念,JS 中由垃圾回收机制实现内存释放。</p>
<p>不同点二:继承的调用关系不同。</p>
<p>C++:在继承关系中,如果子类没有定义构造函数,会自动调用父类的构造函数;如果子类定义了构造函数,需要在子类构造函数中显式调用父类的构造函数;析构函数与构造函数相反,会先调用子类的析构函数,然后调用父类的析构函数。<br>JS:在继承关系中,如果子类没有定义构造函数,不会自动调用父类的构造函数;子类需要显示调用父类的构造函数;没有析构函数的概念。不同点三:重载与重写不同。</p>
<p>C++: 构造函数和析构函数都可以重载;子类可以重写父类的构造函数和析构函数。<br>JS:构造函数不能重载,但可以在子类中重写父类的构造函数;没有重写析构函数的概念。</p>
<p>总体来说,C++ 中的这两个概念更加丰富,而 JS 中针对对象初始化和释放的处理较为简单。</p>
<h3 id="2-什么是浅拷贝"><a href="#2-什么是浅拷贝" class="headerlink" title="2.什么是浅拷贝"></a>2.什么是浅拷贝</h3><p>就是愚蠢的拷贝，如果对象里嵌套了对象，那么就会把内部对象的引用给拷贝下来（引用类型的拷贝不会改变引用地址，也就是说拷贝下来的新引用还是旧的那个引用）。由于只是拷贝引用,所以如果引用所指向的对象发生变化,浅拷贝得到的对象也会发生变化。</p>
<h4 id="最直观的例子："><a href="#最直观的例子：" class="headerlink" title="最直观的例子："></a>最直观的例子：</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">let obj = &#123; a: 1, b: &#123; c: 2 &#125; &#125;;</span><br><span class="line">let copy = Object.assign(&#123;&#125;, obj);  // 浅拷贝</span><br><span class="line">obj.b.c = 3;</span><br><span class="line">obj.a = 4;</span><br><span class="line">console.log(copy.b.c);  // 3  发生变化</span><br><span class="line">console.log(copy.a);    //1   无变化</span><br></pre></td></tr></table></figure>

<h4 id="具体解释："><a href="#具体解释：" class="headerlink" title="具体解释："></a>具体解释：</h4><p>对上面这个例子,我们来分析浅拷贝后 copy 对象的结构:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">js</span><br><span class="line">obj = &#123;</span><br><span class="line">  a: 1,     // 基本类型,值 </span><br><span class="line">  b: &#123;      // 引用类型,地址1</span><br><span class="line">    c: 2 </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">copy = &#123;</span><br><span class="line">  a: 1,     // 基本类型,值 </span><br><span class="line">  b: &#123;      // 引用类型,地址1</span><br><span class="line">    c: 2 </span><br><span class="line">  &#125;  </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<p>然后当我们修改 obj 时:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">js</span><br><span class="line">obj.b.c = 3;  // 修改的是地址1指向的对象</span><br><span class="line">obj.a = 4;     // 修改的是值</span><br></pre></td></tr></table></figure>

<p>此时,obj 和 copy 的结构变为:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">js</span><br><span class="line">obj = &#123;</span><br><span class="line">  a: 4,      // 新的基本类型值 </span><br><span class="line">  b: &#123;       // 地址1</span><br><span class="line">    c: 3    </span><br><span class="line">  &#125;  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">copy = &#123;</span><br><span class="line">  a: 1,       // 原基本类型值</span><br><span class="line">  b: &#123;        // 地址1</span><br><span class="line">    c: 3     </span><br><span class="line">  &#125; </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<p>可以看到:- 当我们修改 obj 的引用类型成员 b 时,由于 copy 中的 b 也指向地址 1,所以 copy 的 b 也发生了变化。- 但是,当我们修改 obj 的基本类型成员 a 时,copy 中的 a 不发生变化,因为它有自己的独立值。所以结果是:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">js</span><br><span class="line">console.log(copy.b.c);  // 3  发生变化</span><br><span class="line">console.log(copy.a);    //1   无变化  </span><br></pre></td></tr></table></figure>

<p>这个过程很好地证明了浅拷贝的特征:- 对引用类型的成员,拷贝的是地址,变化会相互影响<br>- 对基本类型的成员,拷贝的是值,变化互不影响</p>
<h4 id="浅拷贝常见的实现方式有"><a href="#浅拷贝常见的实现方式有" class="headerlink" title="浅拷贝常见的实现方式有:"></a>浅拷贝常见的实现方式有:</h4><ol>
<li><h5 id="Object-assign-obj1-obj2-对象的浅拷贝"><a href="#Object-assign-obj1-obj2-对象的浅拷贝" class="headerlink" title="Object.assign(obj1, obj2)对象的浅拷贝:"></a>Object.assign(obj1, obj2)对象的浅拷贝:</h5></li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">let obj = &#123; a: 1, b: &#123; c: 2 &#125; &#125;;</span><br><span class="line">let copy = Object.assign(&#123;&#125;, obj);  // 浅拷贝</span><br><span class="line">obj.b.c = 3;</span><br><span class="line">console.log(copy.b.c);  // 3  发生变化</span><br></pre></td></tr></table></figure>

<ol start="2">
<li><h5 id="arr-slice-数组的浅拷贝"><a href="#arr-slice-数组的浅拷贝" class="headerlink" title="arr.slice()数组的浅拷贝:"></a>arr.slice()数组的浅拷贝:</h5></li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">let arr = [1, &#123; a: 2 &#125;]; </span><br><span class="line">let copy = arr.slice();   // 浅拷贝</span><br><span class="line">arr[1].a = 3;</span><br><span class="line">console.log(copy[1].a);   // 3  发生变化</span><br></pre></td></tr></table></figure>

<ol start="3">
<li><h5 id="…obj-…arr-展开语法进行浅拷贝"><a href="#…obj-…arr-展开语法进行浅拷贝" class="headerlink" title="{ …obj }  […arr]展开语法进行浅拷贝:"></a>{ …obj }  […arr]展开语法进行浅拷贝:</h5></li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">let obj = &#123; a: 1, b: &#123; c: 2 &#125; &#125;;</span><br><span class="line">let copy = &#123; ...obj &#125;;   // 浅拷贝</span><br><span class="line">obj.b.c = 3;</span><br><span class="line">console.log(copy.b.c);   // 3  发生变化</span><br></pre></td></tr></table></figure>

<p>所以,浅拷贝的主要用途是快速复制对象,但是由于它只复制引用,对于引用类型的成员来说,如果原对象发生变化,拷贝对象也会变化。如果要避免这种情况,可以使用深拷贝,深拷贝会完整复制一个新对象,两者之间不再有任何引用关系,变化互不影响。</p>
<h4 id="常见的深拷贝实现方式有"><a href="#常见的深拷贝实现方式有" class="headerlink" title="常见的深拷贝实现方式有:"></a>常见的深拷贝实现方式有:</h4><p>JSON.parse(JSON.stringify(obj))<br>lodash工具库的 _.cloneDeep() 方法<br>手动实现深度遍历对象并复制（及其简单的递归，就是一层层拨开嵌套对象，直到到达内部找到对象内的键值对，浅拷贝它）</p>
<p>所以,总结来说,浅拷贝和深拷贝的主要区别在于对引用类型的成员的处理方式,理解两者的区别可以更好地选择适合的拷贝方式。</p>
<h4 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h4><p>在工作中,如果要考虑兼容性,或需要灵活指定下标获取部分数组,arr.slice() 会更常用。</p>
<p>如果项目环境支持 ES6,并且需要获取数组的完整拷贝,展开语法 …arr 会更简洁,也是较常见的用法。</p>
<p>两者的底层实现原理都是浅拷贝,对于一维数组来说,效果是相同的。</p>
<p>但也要注意,如果数组包含复杂类型,那么对原数组的修改会影响拷贝得到的数组。</p>
<p>除此之外,也可以选择 lodash 等工具库提供的深拷贝方法,如 _.cloneDeep(),来完全避免两个数组之间的影响,这在某些场景下也比较常用。</p>
<h2 id="4-6-1Object"><a href="#4-6-1Object" class="headerlink" title="4.6.1Object"></a>4.6.1Object</h2><h3 id="1-常用方法"><a href="#1-常用方法" class="headerlink" title="1.常用方法"></a>1.常用方法</h3><p>在工作中,Object 对象属性和方法中常用的主要有:</p>
<ol>
<li><strong>Object.defineProperty() 和 Object.defineProperties()</strong>:用于在对象上定义属性或修改属性,常用于<em><strong>数据响应式</strong></em>。</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">let obj = &#123;&#125;;</span><br><span class="line">Object.defineProperty(obj, &quot;prop&quot;, &#123;</span><br><span class="line">  value: true,</span><br><span class="line">  writable: false,</span><br><span class="line">  enumerable: true </span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>Object.keys() 和 Object.values():用于获得对象的键名数组和键值数组。</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">let obj = &#123; a: 1, b: 2 &#125;;</span><br><span class="line">Object.keys(obj); // [&#x27;a&#x27;, &#x27;b&#x27;]</span><br><span class="line">Object.values(obj); // [1, 2]</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>Object.assign():用于对象合并，B合并到A里（是浅拷贝）。&#x2F;&#x2F;assign：分配、指派（任务）<br>                            不会去重，但是如果键值对的key是一样的，新的会把旧的覆盖，即旧的value消失</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">let target = &#123; a: 1 &#125;;</span><br><span class="line">let source = &#123; b: 2 &#125;;</span><br><span class="line">Object.assign(target, source);</span><br><span class="line">// target is now &#123;a: 1, b: 2&#125;</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>Object.freeze():用于冻结对象,使其不能被修改。</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">let obj = &#123; a: 1 &#125;;</span><br><span class="line">Object.freeze(obj);</span><br><span class="line">obj.a = 2; // 无效</span><br></pre></td></tr></table></figure>

<p>除此之外,对象的元属性(writable、enumerable 等)和存取器(getter、setter)也会使用,但是相对来说较少。控制对象状态的方法(Object.preventExtensions、Object.seal 等)用得比较少,一般只会在需要严格控制对象状态的场景下使用。所以,总的来说,在日常工作中 Object 对象的常用方面主要是属性的操作与管理,包括定义、获取和控制属性。</p>
<blockquote>
<p>注：数据响应式是一种设计模式,其核心思想是:当数据变化时,自动更新视图。在 JavaScript 中,定义响应式数据常用的手段就是 Object.defineProperty()。我们可以在定义对象属性时,指定 getter 和 setter 方法。当属性值发生变化时,getter 和 setter 就会自动调用,这样我们可以在 setter 中更新视图,达到数据响应式的效果。例如:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">let data = &#123;</span><br><span class="line">    name: &quot;John&quot;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Object.defineProperty(data, &quot;name&quot;, &#123;</span><br><span class="line">    get() &#123;</span><br><span class="line">        return this._name;</span><br><span class="line">    &#125;,</span><br><span class="line">    set(newValue) &#123;</span><br><span class="line">        this._name = newValue;</span><br><span class="line">        document.querySelector(&quot;#name&quot;).textContent = newValue;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">data.name = &quot;Jack&quot;; </span><br><span class="line">// 视图自动更新,页面上#name元素的文本变为&quot;Jack&quot;</span><br></pre></td></tr></table></figure>

<p>这里我们定义了 name 属性的 getter 和 setter。当对 name 进行重新赋值时,setter 会自动调用,更新视图中的文本内容。Vue.js 中的响应式就是建立在 Object.defineProperty() 之上的。它通过递归定义对象属性的 getter 和 setter,实现视图的响应更新。所以,我们说 Object.defineProperty() 常用于数据响应式,就是因为它提供了定义属性访问器(getter 和 setter)的能力,可以结合 getter 和 setter 达到响应式更新视图的目的。</p>
</blockquote>
<h3 id="2-Object-prototype（后几个不会用）"><a href="#2-Object-prototype（后几个不会用）" class="headerlink" title="2.Object.prototype（后几个不会用）"></a>2.Object.prototype（后几个不会用）</h3><p>在工作中,Object.prototype 最常用于:</p>
<ol>
<li>扩展内置对象。我们会在 Object.prototype 上添加方法,扩展 String、Array、Date 等内置对象的功能。例如:</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">String.prototype.reverse = function() &#123;</span><br><span class="line">  return this.split(&#x27;&#x27;).reverse().join(&#x27;&#x27;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x27;hello&#x27;.reverse() // olleh</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>实现继承和共享方法。我们会在 Object.prototype 上定义方法,让多个对象类型共享这些方法,实现继承。例如:</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Object.prototype.sayHi = function() &#123;</span><br><span class="line">  console.log(&#x27;Hi!&#x27;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let str = &#x27;Hello&#x27; </span><br><span class="line">let obj = &#123;name: &#x27;Jack&#x27;&#125;</span><br><span class="line"></span><br><span class="line">str.sayHi() // Hi!</span><br><span class="line">obj.sayHi() // Hi!</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>模拟类。在 JS 中我们会使用构造函数和原型来模拟类,Object.prototype 就是在这里发挥作用。例如:</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function Person(name) &#123;</span><br><span class="line">  this.name = name </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Person.prototype.sayName = function() &#123;</span><br><span class="line">  console.log(this.name); </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let jack = new Person(&#x27;Jack&#x27;);</span><br><span class="line">jack.sayName(); // Jack</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>实现 utility 方法。我们会在 Object.prototype 上实现一些通用的工具方法,供所有对象使用。例如:</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Object.prototype.isArray = function() &#123;</span><br><span class="line">  return Object.prototype.toString.call(this) === &#x27;[object Array]&#x27;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">[].isArray() // true </span><br><span class="line">&#123;&#125;.isArray() // false</span><br></pre></td></tr></table></figure>

<p>所以,总的来说,在工作中 Object.prototype 最常用于扩展内置对象、实现继承和共享方法、模拟类、以及实现通用工具方法。它让 JS 的框架和库设计变得简单高效,也使我们的代码更加优雅。</p>
<h2 id="4-6-1小结"><a href="#4-6-1小结" class="headerlink" title="4.6.1小结"></a>4.6.1小结</h2><p>Object有的函数能继承，有的不能。但不知道怎么主动让它继承，也不知道都哪些能继承。</p>
<h2 id="4-6-2Array类型"><a href="#4-6-2Array类型" class="headerlink" title="4.6.2Array类型"></a>4.6.2Array类型</h2><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array">Array - JavaScript | MDN (mozilla.org)</a></p>
<h3 id="1-构造函数（最好别用）"><a href="#1-构造函数（最好别用）" class="headerlink" title="1.构造函数（最好别用）"></a>1.构造函数（最好别用）</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// bad</span><br><span class="line">var arr = new Array(1, 2);</span><br><span class="line"></span><br><span class="line">// good</span><br><span class="line">var arr = [1, 2];</span><br></pre></td></tr></table></figure>

<h3 id="2-静态方法"><a href="#2-静态方法" class="headerlink" title="2.静态方法"></a>2.静态方法</h3><p>Array.isArray()</p>
<p>它可以弥补<code>typeof</code>运算符的不足。<code>typeof</code>运算符只能显示数组的类型是<code>Object</code>，而<code>Array.isArray</code>方法可以识别数组。</p>
<h3 id="3-实例属性"><a href="#3-实例属性" class="headerlink" title="3.实例属性"></a>3.实例属性</h3><p>length</p>
<h3 id="4-实例方法"><a href="#4-实例方法" class="headerlink" title="4.实例方法"></a>4.实例方法</h3><h4 id="valueOf-，toString"><a href="#valueOf-，toString" class="headerlink" title="valueOf()，toString()"></a>valueOf()，toString()</h4><h4 id="push-尾插，pop-尾删"><a href="#push-尾插，pop-尾删" class="headerlink" title="push()尾插，pop()尾删"></a>push()尾插，pop()尾删</h4><h4 id="shift-头删，unshift-头插"><a href="#shift-头删，unshift-头插" class="headerlink" title="shift()头删，unshift()头插"></a>shift()头删，unshift()头插</h4><p>​				1.shift()头删</p>
<p>​						shift()方法用于删除数组的第一个元素，并返回该元素。注意，该方法会改变原数组。</p>
<p>​						shift()方法可以遍历并清空一个数组。</p>
<p>​						push()和shift()结合使用，就构成了“先进先出”的队列结构（queue）。</p>
<p>​				2.unshift()头插</p>
<p>​						用于在数组的第一个位置添加元素，并返回新的数组的长度。注意，该方法会改变原数组。</p>
<p>​						可以接受多个参数，这些参数都会添加到目标数组头部。</p>
<h4 id="join-符号链接"><a href="#join-符号链接" class="headerlink" title="join()符号链接"></a>join()符号链接</h4><p>​				join()方法以指定参数作为分隔符，将所有数组成员连接并返回。如果不提供参数，默认用逗号分隔。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">通过call方法，这个方法也可以用于字符串或类似数组的对象。</span><br><span class="line"></span><br><span class="line">Array.prototype.join.call(&#x27;hello&#x27;, &#x27;-&#x27;)</span><br><span class="line">// &quot;h-e-l-l-o&quot;</span><br><span class="line"></span><br><span class="line">var obj = &#123; 0: &#x27;a&#x27;, 1: &#x27;b&#x27;, length: 2 &#125;;</span><br><span class="line">Array.prototype.join.call(obj, &#x27;-&#x27;)</span><br><span class="line">// &#x27;a-b&#x27;	</span><br></pre></td></tr></table></figure>

<h4 id="at-下标-访问"><a href="#at-下标-访问" class="headerlink" title="at(下标)访问"></a>at(下标)访问</h4><p>​				返回给定索引处的数组元素。接受从最后一项往回计算的负整数。</p>
<h4 id="concat-合并"><a href="#concat-合并" class="headerlink" title="concat()合并"></a>concat()合并</h4><p>​				用于多个数组的合并。尾插，然后返回一个新数组，原数组不变。</p>
<p>​				如果数组成员包括对象，<code>concat</code>方法返回当前数组的一个浅拷贝。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[&#x27;hello&#x27;].concat([&#x27;world&#x27;], [&#x27;!&#x27;], [&#123;a:4&#125;], 1)   </span><br><span class="line">// [&quot;hello&quot;, &quot;world&quot;, &quot;!&quot;, &#123;a:4&#125;, 1]</span><br></pre></td></tr></table></figure>

<h4 id="reverse"><a href="#reverse" class="headerlink" title="reverse()"></a>reverse()</h4><p>​				用于颠倒排列数组元素，返回改变后的数组。注意，该方法将改变原数组。</p>
<h4 id="slice-切片"><a href="#slice-切片" class="headerlink" title="slice()切片"></a>slice()切片</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">arr.slice(start, end);</span><br></pre></td></tr></table></figure>

<h4 id="splice-删除"><a href="#splice-删除" class="headerlink" title="splice()删除"></a>splice()删除</h4><p>​				用于删除原数组的一部分成员，并可以在删除的位置添加新的数组成员，返回值是被删除的元素。注意，该方法会改变原数组。</p>
<h4 id="sort-不传参-排字典序"><a href="#sort-不传参-排字典序" class="headerlink" title="sort(不传参)排字典序"></a>sort(不传参)排字典序</h4><p>​				对数组成员进行排序。排序后，原数组将被改变。</p>
<p>​				不是按大小排序，而是按字典排序。数值会被先转成字符串，再比较，所以<code>101</code>排在<code>11</code>的前面。</p>
<h4 id="sort-传入函数-排数值序"><a href="#sort-传入函数-排数值序" class="headerlink" title="sort(传入函数)排数值序"></a>sort(传入函数)排数值序</h4><p>​				.sort((a, b) &#x3D;&gt; a - b)</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[1, 4, 2, 6, 0, 6, 2, 6].sort((a, b) =&gt; a - b)</span><br></pre></td></tr></table></figure>

<h4 id="map-传入函数-所有成员依次执行函数"><a href="#map-传入函数-所有成员依次执行函数" class="headerlink" title="map(传入函数)所有成员依次执行函数"></a>map(传入函数)所有成员依次执行函数</h4><p>​				将数组的所有成员依次传入参数函数，然后把每一次的执行结果组成一个新数组返回。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var numbers = [1, 2, 3];</span><br><span class="line"></span><br><span class="line">numbers.map(function (n) &#123;</span><br><span class="line">  return n + 1;</span><br><span class="line">&#125;);</span><br><span class="line">// [2, 3, 4]</span><br><span class="line"></span><br><span class="line">numbers</span><br><span class="line">// [1, 2, 3]</span><br></pre></td></tr></table></figure>

<h4 id="forEach-传入函数-所有成员依次执行函数"><a href="#forEach-传入函数-所有成员依次执行函数" class="headerlink" title="forEach(传入函数)所有成员依次执行函数"></a>forEach(传入函数)所有成员依次执行函数</h4><p>​				与<code>map()</code>方法很相似，也是对数组的所有成员依次执行参数函数。但不返回值，只用来操作数据。</p>
<h4 id="filter-传入函数-所有成员依次执行函数"><a href="#filter-传入函数-所有成员依次执行函数" class="headerlink" title="filter(传入函数)所有成员依次执行函数"></a>filter(传入函数)所有成员依次执行函数</h4><p>​			过滤数组成员，参数是一个函数，所有数组成员依次执行该函数，返回结果为<code>true</code>的成员组成一个新数组返回。该方法不会改变原数组。</p>
<h4 id="some-存在，every-所有"><a href="#some-存在，every-所有" class="headerlink" title="some()存在，every()所有"></a>some()存在，every()所有</h4><p>​				判断数组成员是否符合某种条件，返回一个布尔值。</p>
<p>​				它们接受一个函数作为参数，所有数组成员依次执行该函数。</p>
<p>​				every方法是所有成员的返回值都是true<code>，整个</code>every<code>方法才返回</code>true<code>，否则返回</code>false。</p>
<h4 id="reduce-，reduceRight"><a href="#reduce-，reduceRight" class="headerlink" title="reduce()，reduceRight()"></a>reduce()，reduceRight()</h4><p>​				<code>reduce()</code>方法和<code>reduceRight()</code>方法依次处理数组的每个成员，最终累计为一个值。它们的差别是，<code>reduce()</code>是从左到右处理（从第一个成员到最后一个成员），<code>reduceRight()</code>则是从右到左（从最后一个成员到第一个成员），其他完全一样。</p>
<h4 id="indexOf-，lastIndexOf"><a href="#indexOf-，lastIndexOf" class="headerlink" title="indexOf()，lastIndexOf()"></a>indexOf()，lastIndexOf()</h4><p>​				<code>indexOf</code>方法返回给定元素在数组中第一次出现的位置，如果没有出现则返回<code>-1</code>。</p>
<p>​				<code>lastIndexOf</code>方法返回给定元素在数组中最后一次出现的位置，如果没有出现则返回<code>-1</code>。</p>
<p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/fill"><code>Array.prototype.fill()</code></a></p>
<p>用静态值填充数组中从开始索引到结束索引的所有元素。</p>
<h4 id="链式使用"><a href="#链式使用" class="headerlink" title="链式使用"></a>链式使用</h4><p>上面这些数组方法之中，有不少返回的还是数组，所以可以链式使用。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var users = [</span><br><span class="line">  &#123;name: &#x27;tom&#x27;, email: &#x27;tom@example.com&#x27;&#125;,</span><br><span class="line">  &#123;name: &#x27;peter&#x27;, email: &#x27;peter@example.com&#x27;&#125;</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line">users</span><br><span class="line">.map(function (user) &#123;</span><br><span class="line">  return user.email;</span><br><span class="line">&#125;)</span><br><span class="line">.filter(function (email) &#123;</span><br><span class="line">  return /^t/.test(email);</span><br><span class="line">&#125;)</span><br><span class="line">.forEach(function (email) &#123;</span><br><span class="line">  console.log(email);</span><br><span class="line">&#125;);</span><br><span class="line">// &quot;tom@example.com&quot;</span><br></pre></td></tr></table></figure>

<p>上面代码中，先产生一个所有 Email 地址组成的数组，然后再过滤出以<code>t</code>开头的 Email 地址，最后将它打印出来。</p>
<h2 id="4-6-3原始类型的对象化"><a href="#4-6-3原始类型的对象化" class="headerlink" title="4.6.3原始类型的对象化"></a>4.6.3原始类型的对象化</h2><h3 id="1-三种包装对象"><a href="#1-三种包装对象" class="headerlink" title="1.三种包装对象"></a>1.三种包装对象</h3><p>Number、String、Boolean</p>
<h3 id="2-包装成对象的原因"><a href="#2-包装成对象的原因" class="headerlink" title="2.包装成对象的原因"></a>2.包装成对象的原因</h3><p>用于继承并使用Object类型中的函数。其中三者公用的是valueOf()<code>和</code>toString()。</p>
<h4 id="2-1valueOf"><a href="#2-1valueOf" class="headerlink" title="2.1valueOf()"></a>2.1valueOf()</h4><p>返回包装对象实例对应的原始类型的值。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">new Number(123).valueOf()  // 123</span><br><span class="line">new String(&#x27;abc&#x27;).valueOf() // &quot;abc&quot;</span><br><span class="line">new Boolean(true).valueOf() // true</span><br></pre></td></tr></table></figure>

<h4 id="2-2toString"><a href="#2-2toString" class="headerlink" title="2.2toString()"></a>2.2toString()</h4><p>返回对应的字符串形式。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">new Number(123).toString() // &quot;123&quot;</span><br><span class="line">new String(&#x27;abc&#x27;).toString() // &quot;abc&quot;</span><br><span class="line">new Boolean(true).toString() // &quot;true&quot;</span><br></pre></td></tr></table></figure>

<h2 id="4-6-2小结"><a href="#4-6-2小结" class="headerlink" title="4.6.2小结"></a>4.6.2小结</h2><p>有些类型直接使用太麻烦，包装成对象可以调用更多的库函数。</p>
<h2 id="4-6-3Boolean"><a href="#4-6-3Boolean" class="headerlink" title="4.6.3Boolean"></a>4.6.3Boolean</h2><h4 id="0-使用与易错点"><a href="#0-使用与易错点" class="headerlink" title="0.使用与易错点"></a>0.使用与易错点</h4><p>0.1使用：直接 let a&#x3D;true；就行。</p>
<p>0.2易错点：小心使用，并不是只有0和false是false，空字符串等也是。</p>
<h4 id="1-Boolean中得到true的例子（都要记住）"><a href="#1-Boolean中得到true的例子（都要记住）" class="headerlink" title="1.Boolean中得到true的例子（都要记住）"></a>1.Boolean中得到true的例子（都要记住）</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Boolean(1) // true				数字</span><br><span class="line">Boolean(&#x27;false&#x27;) // true		字符串</span><br><span class="line">Boolean([]) // true				空数组</span><br><span class="line">Boolean(&#123;&#125;) // true				空对象</span><br><span class="line">Boolean(function () &#123;&#125;) // true	空函数</span><br><span class="line">Boolean(/foo/) // true			正则</span><br></pre></td></tr></table></figure>

<h3 id="2-JS和C中的bool类型的异同"><a href="#2-JS和C中的bool类型的异同" class="headerlink" title="2.JS和C中的bool类型的异同"></a>2.JS和C中的bool类型的异同</h3><p>异同点:</p>
<p>都只有两个值:true 和 false。</p>
<p>都用于表示逻辑上的真假。</p>
<h4 id="2-1不同点一-存储方式不同。"><a href="#2-1不同点一-存储方式不同。" class="headerlink" title="2.1不同点一:存储方式不同。"></a>2.1不同点一:存储方式不同。</h4><p>JS:Boolean 是基本数据类型,占据1个字节。<br>C:没有标准的 bool 类型,一般使用整型来存储,占据1个字节(char)或4个字节(int)。</p>
<h4 id="2-2不同点二-转换规则不同。"><a href="#2-2不同点二-转换规则不同。" class="headerlink" title="2.2不同点二:转换规则不同。"></a>2.2不同点二:转换规则不同。</h4><p>JS:在 Boolean 上下文中,以下值会转换为 false:<br> - false<br> - 0<br> - “”(空字符串)<br> - null<br> - undefined<br> - NaN<br>C:所有非零的值都会转换为 true,0 转换为 false。</p>
<h4 id="2-3不同点三-操作方式不同。"><a href="#2-3不同点三-操作方式不同。" class="headerlink" title="2.3不同点三:操作方式不同。"></a>2.3不同点三:操作方式不同。</h4><p>JS:可以直接对 Boolean 类型的值进行逻辑运算(&amp;&amp;、||、!)<br>C:需要先将值转换为整型,再进行逻辑运算。</p>
<p>例如:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">js</span><br><span class="line">let t = true;</span><br><span class="line">let f = false;</span><br><span class="line"></span><br><span class="line">t &amp;&amp; f;     // false</span><br><span class="line">t || f;     // true </span><br><span class="line">!t;         // false</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">c</span><br><span class="line">int t = 1;  // true</span><br><span class="line">int f = 0;  // false</span><br><span class="line"></span><br><span class="line">t &amp;&amp; f;     // 0 </span><br><span class="line">t || f;     // 1</span><br><span class="line">!t;         // 0</span><br></pre></td></tr></table></figure>

<p>所以,Boolean 作为两种语言的基本数据类型,在概念上是相通的,但是具体的实现与使用上存在一定的差异。总体来说,JS 对 Boolean 的支持更加丰富,使用也更加方便,而 C 由于缺乏标准的 bool 类型, Boolean 的表达相对局限。这也是两种语言的特点的体现:JS 侧重表达,C 侧重底层实现。理解两者在这一点上的差异,有助于更好的使用两种语言。</p>
<h3 id="3-boolean类型与Boolean对象"><a href="#3-boolean类型与Boolean对象" class="headerlink" title="3.boolean类型与Boolean对象"></a>3.boolean类型与Boolean对象</h3><p>在 JS 中,boolean 类型和 Boolean 对象是不同的:</p>
<h4 id="3-1boolean-类型"><a href="#3-1boolean-类型" class="headerlink" title="3.1boolean 类型:"></a>3.1boolean 类型:</h4><p>是 JS 的基本数据类型之一,只有 true 和 false 两个值。<br>- 表示逻辑上的真或假。<br>- 大小写敏感,true 和 True 是不同的。<br>- 可以直接在条件语句中使用,如 if 和 while。例如:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">js</span><br><span class="line">let bool = true;     // boolean 类型</span><br><span class="line"></span><br><span class="line">if (bool) &#123; ... &#125;    // 可以直接用于条件判断</span><br></pre></td></tr></table></figure>

<h4 id="3-2Boolean-对象"><a href="#3-2Boolean-对象" class="headerlink" title="3.2Boolean 对象:"></a>3.2Boolean 对象:</h4><p>是 JS 的内置对象,继承自 Object。<br>- 包装了 boolean 基本类型,有 true 和 false 两个值。<br>- 大小写不敏感,TRUE 和 true 是同一个值。<br>- 不能直接在条件语句中使用,需要调用 valueOf() 方法。<br>- 除了 true 和 false,可以有其他的属性和方法。例如:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">js</span><br><span class="line">let bool = new Boolean(true);   // Boolean 对象</span><br><span class="line"></span><br><span class="line">if (bool.valueOf()) &#123; ... &#125;    // 需要调用 valueOf() 方法</span><br><span class="line"></span><br><span class="line">bool.constructor = 123;        // 可以添加属性</span><br></pre></td></tr></table></figure>

<p>所以,boolean 类型和 Boolean 对象的主要区别在于:- boolean 是基本数据类型,Boolean 是对象。<br>- boolean 只有 true 和 false 两个字面量,Boolean 除了 true 和 false 值外,还可以有其他属性和方法。<br>- boolean 可以直接用于条件判断,Boolean 需要调用 valueOf() 方法。但是,在大多数情况下,我们可以把 Boolean 对象当作 boolean 类型来使用,因为:- Boolean 对象在布尔表达式中会自动调用 valueOf() 方法,返回基本类型值。</p>
<h2 id="4-6-3小结"><a href="#4-6-3小结" class="headerlink" title="4.6.3小结"></a>4.6.3小结</h2><p><strong>基于性能考虑,大多数情况下我们会使用基本类型boolean而不是Boolean对象。</strong>所以,boolean 和 Boolean的关系可以看作,boolean 是基本数据类型,Boolean 是它的对象包装形式。</p>
<h2 id="4-6-4Number"><a href="#4-6-4Number" class="headerlink" title="4.6.4Number"></a>4.6.4Number</h2><p>只有可继承的原型函数prototype.toString（）值得一看</p>
<h2 id="4-6-5-String"><a href="#4-6-5-String" class="headerlink" title="4.6.5.String"></a>4.6.5.String</h2><h3 id="5-1实例属性（原型属性）"><a href="#5-1实例属性（原型属性）" class="headerlink" title="5.1实例属性（原型属性）"></a>5.1实例属性（原型属性）</h3><ol>
<li>字符串实例的length属性返回字符串的长度。</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#x27;abc&#x27;.length // 3</span><br></pre></td></tr></table></figure>

<h3 id="5-2实例方法（原型函数）"><a href="#5-2实例方法（原型函数）" class="headerlink" title="5.2实例方法（原型函数）"></a>5.2实例方法（原型函数）</h3><ol>
<li><p>charAt():返回指定索引处的字符,索引从 0 开始。</p>
<p>或当成数组，使用下标访问(这种方法是只读的，想改动这个字符就会报错)。</p>
</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#x27;hello&#x27;.charAt(0);  // &#x27;h&#x27;</span><br><span class="line">&#x27;hello&#x27;[0];			// &#x27;h&#x27;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>at():返回指定索引处的字符。接受负整数，从最后一个字符串字符开始倒数。</li>
<li>includes():确定调用字符串是否包含 searchString。</li>
<li>concat():连接两个或多个字符串,返回连接后的字符串。</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#x27;hello&#x27;.concat(&#x27; &#x27;, &#x27;world&#x27;);  // &#x27;hello world&#x27;</span><br></pre></td></tr></table></figure>

<ol start="5">
<li>startsWith():检查字符串是否以指定的子字符串开头,返回 true 或 false。</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#x27;hello&#x27;.startsWith(&#x27;he&#x27;);   // true</span><br></pre></td></tr></table></figure>

<ol start="6">
<li>endsWith():检查字符串是否以指定的子字符串结尾,返回 true 或 false。</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#x27;hello&#x27;.endsWith(&#x27;lo&#x27;);   // true</span><br></pre></td></tr></table></figure>

<ol start="7">
<li>indexOf():返回指定子字符串首次出现的索引,如果不存在则返回 -1。</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#x27;hello&#x27;.indexOf(&#x27;l&#x27;);   // 2</span><br></pre></td></tr></table></figure>

<ol start="8">
<li>lastIndexOf():返回指定子字符串最后一次出现的索引,如果不存在则返回 -1。</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#x27;hello&#x27;.lastIndexOf(&#x27;l&#x27;);   // 3</span><br></pre></td></tr></table></figure>

<ol start="9">
<li>slice():切片。提取字符串的一部分,返回提取后的字符串。</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#x27;hello&#x27;.slice(1, 3);   // &#x27;el&#x27;</span><br></pre></td></tr></table></figure>

<ol start="10">
<li>split():拆分。将字符串按指定分隔符拆分成数组,返回数组。</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#x27;a-b-c&#x27;.split(&#x27;-&#x27;);   // [&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;]</span><br></pre></td></tr></table></figure>

<ol start="11">
<li>replace():替换字符串中的指定子字符串,返回替换后的字符串。</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#x27;hello&#x27;.replace(&#x27;l&#x27;, &#x27;x&#x27;);   // &#x27;hexxo&#x27;</span><br></pre></td></tr></table></figure>

<p>&#x2F;&#x2F;正则相关<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/String">String - JavaScript | MDN (mozilla.org)</a></p>
<ol start="12">
<li><p>match()</p>
</li>
<li><p>matchAll()</p>
</li>
<li><p>replace()</p>
</li>
<li><p>replaceAll()</p>
</li>
<li><p>serach()</p>
</li>
</ol>
<p>&#x2F;&#x2F;claude认为的常用方法</p>
<ol>
<li>String.prototype.indexOf() 和String.prototype.lastIndexOf() :用于查找字符串中的子字符串,前者从前往后,后者从后往前。</li>
<li>String.prototype.slice() :用于提取字符串的一部分,返回一个新的字符串。</li>
<li>String.prototype.substring() <code>:也用于提取字符串的一部分,返回一个新的字符串。和 slice 稍有不同。</code></li>
<li>String.prototype.substr() :同样用于提取字符串的一部分,返回一个新的字符串。和 slice、substring 也有差异。</li>
<li>String.prototype.replace() :用于替换字符串中的子字符串</li>
<li>String.prototype.toUpperCase() <code>和</code> String.prototype.toLowerCase():用于转换字符串的大小写。</li>
<li>String.prototype.concat() :用于连接两个或更多字符串,返回一个新字符串。&#96;</li>
<li>String.prototype.trim() 、String.prototype.trimStart() <code>和</code> String.prototype.trimEnd():用于删除字符串开头或结尾的空格。</li>
<li>String.prototype.charAt() :返回指定索引处的字符。</li>
<li>String.prototype.split() :将字符串分割成子字符串数组。</li>
<li>String.prototype.match() :将正则表达式应用于字符串,返回匹配结果。</li>
<li>String.prototype.search() :搜索字符串中第一个匹配项的索引。</li>
<li>String.prototype.startsWith() <code>和</code>String.prototype.endsWith() :用于判断字符串是否以某个子字符串开头或结尾。</li>
</ol>
<h3 id="5-3构造函数"><a href="#5-3构造函数" class="headerlink" title="5.3构造函数"></a>5.3构造函数</h3><p>不当构造函数用，当强制转换用：String(value)&#x3D;&#x3D;&#x3D;value.valueOf();返回的不是String对象而是字面量string类型。</p>
<h3 id="5-4静态方法"><a href="#5-4静态方法" class="headerlink" title="5.4静态方法"></a>5.4静态方法</h3><p>没用</p>
<h3 id="5-5其它es6补充"><a href="#5-5其它es6补充" class="headerlink" title="5.5其它es6补充"></a>5.5其它es6补充</h3><h4 id="1-标记变量（并替换）"><a href="#1-标记变量（并替换）" class="headerlink" title="1.标记变量（并替换）${}"></a>1.标记变量（并替换）${}</h4><ol>
<li><p>作用：字符串连接时需要用‘’+‘’号链接，用了＄{}后，就不用了。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">let a = 10;</span><br><span class="line">let b = 20;</span><br><span class="line">console.log(`$&#123;a&#125;小于$&#123;b&#125;`);</span><br><span class="line">// 输出:10小于20 </span><br></pre></td></tr></table></figure>
</li>
<li><p>原理</p>
<p>相当于标记了一下，大括号里的是变量，省的被函数默认当成字符了。</p>
</li>
<li><p>易错点</p>
<p>只有使用反引号,字符串插值语法才会被识别和渲染。`${a}小于${b}`</p>
</li>
</ol>
<h4 id="2-忽略转义"><a href="#2-忽略转义" class="headerlink" title="2.忽略转义"></a>2.忽略转义</h4><p>String.raw()是ES6新增的一个字符串原生方法。它的作用是使转义符和${}失效。</p>
<p>它的基本语法是:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">String.raw`string` </span><br></pre></td></tr></table></figure>

<p>它有以下几个值得注意的点:</p>
<ol>
<li>符串中的转义字符会被当成普通字符直接输出。</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">String.raw`String with \n`   // &quot;String with \n&quot;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>它可以解析字符串模板中${}内的表达式。</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">let name = &quot;Bob&quot;;</span><br><span class="line">String.raw`Hello, $&#123;name&#125;!`   // &quot;Hello, $&#123;name&#125;!&quot;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>它主要用于创建带有未转义\字符的字符串,以及在模板字符串中包含大量${expression}时,避免字符串拼接的性能开销。</li>
<li>如果原字符串没有需要转义的字符或模板变量,使用String.raw()和普通字符串没有任何区别。例子:</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">String.raw`Hello\nworld!`   // &quot;Hello\nworld!&quot;  </span><br><span class="line">String.raw`Hello$&#123;name&#125;!`   // &quot;Hello$&#123;name&#125;!&quot;</span><br><span class="line"></span><br><span class="line">&quot;Hello\nworld!&quot;              // &quot;Hello </span><br><span class="line">world!&quot;</span><br><span class="line">&quot;Hello$&#123;name&#125;!&quot;              // &quot;HelloBob!&quot;</span><br></pre></td></tr></table></figure>

<ol start="5">
<li><h1 id="String-raw-可以和标签函数一起使用-此时会调用标签函数-并将原始字符串作为参数传入。（没看懂）"><a href="#String-raw-可以和标签函数一起使用-此时会调用标签函数-并将原始字符串作为参数传入。（没看懂）" class="headerlink" title="String.raw()可以和标签函数一起使用,此时会调用标签函数,并将原始字符串作为参数传入。（没看懂）"></a>String.raw()可以和标签函数一起使用,此时会调用标签函数,并将原始字符串作为参数传入。（没看懂）</h1>例如:</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function tag(strings) &#123;</span><br><span class="line">  console.log(strings.raw[0]);</span><br><span class="line">&#125;</span><br><span class="line">tag`Hello\nworld!`   // &quot;Hello\\nworld!&quot;</span><br></pre></td></tr></table></figure>

<p>总之,String.raw()是一个获取原生字符串字面量的强大方法,可以用来避免字符串解析,或在模板字符串中包含大量变量时提升性能。</p>
<h3 id="5-6其他补充"><a href="#5-6其他补充" class="headerlink" title="5.6其他补充"></a>5.6其他补充</h3><ol>
<li>长字符串的处理<br>1.+<br>    const longString &#x3D;<br>      “This is a very long string which needs “ +<br>      “to wrap across multiple lines because “ +<br>      “otherwise my code is unreadable.”;<br>2.<br>    const longString &#x3D;<br>      “This is a very long string which needs <br>    to wrap across multiple lines because <br>    otherwise my code is unreadable.”;</li>
</ol>
<h2 id="4-6-6Math"><a href="#4-6-6Math" class="headerlink" title="4.6.6Math"></a>4.6.6Math</h2><h4 id="6-1（只有）静态函数"><a href="#6-1（只有）静态函数" class="headerlink" title="6.1（只有）静态函数"></a>6.1（只有）静态函数</h4><ul>
<li><p><code>Math.abs()</code>：绝对值（负数也适用，求ab差的绝对值：Math.abs(2 - 3)）</p>
<p>两下标之间的距离不能用a+b，要用abs（a-b），防止有负数下标</p>
</li>
<li><p><code>Math.ceil()</code>：向上取整</p>
</li>
<li><p><code>Math.floor()</code>：向下取整</p>
</li>
<li><p><code>Math.max()</code>：最大值</p>
</li>
<li><p><code>Math.min()</code>：最小值</p>
</li>
<li><p><code>Math.pow()</code>：幂运算</p>
<p>Math.pow方法返回以第一个参数为底数、第二个参数为指数的幂运算值。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 等同于 2 ** 2</span><br><span class="line">Math.pow(2, 2) // 4</span><br><span class="line">// 等同于 2 ** 3</span><br><span class="line">Math.pow(2, 3) // 8</span><br></pre></td></tr></table></figure>

<p>下面是计算圆面积的方法。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var radius = 20;</span><br><span class="line">var area = Math.PI * Math.pow(radius, 2);</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>Math.sqrt()</code>：平方根</p>
<p>Math.sqrt方法返回参数值的平方根。如果参数是一个负值，则返回<code>NaN</code>。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Math.sqrt(4) // 2</span><br><span class="line">Math.sqrt(-4) // NaN</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>Math.log()</code>：自然对数</p>
</li>
<li><p><code>Math.exp()</code>：<code>e</code>的指数</p>
</li>
<li><p><code>Math.round()</code>：四舍五入</p>
</li>
<li><p><code>Math.random()</code>：随机数</p>
<p><code>Math.random()</code>返回0到1之间的一个伪随机数，可能等于0，但是一定小于1。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Math.random() // 0.7151307314634323</span><br></pre></td></tr></table></figure>

<p>任意范围的随机数生成函数如下。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function getRandomArbitrary(min, max) &#123;</span><br><span class="line">  return Math.random() * (max - min) + min;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">getRandomArbitrary(1.5, 6.5)</span><br><span class="line">// 2.4942810038223864</span><br></pre></td></tr></table></figure>

<p>任意范围的随机整数生成函数如下。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function getRandomInt(min, max) &#123;</span><br><span class="line">  return Math.floor(Math.random() * (max - min + 1)) + min;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">getRandomInt(1, 6) // 5</span><br></pre></td></tr></table></figure>

<p>返回随机字符的例子如下。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function random_str(length) &#123;</span><br><span class="line">  var ALPHABET = &#x27;ABCDEFGHIJKLMNOPQRSTUVWXYZ&#x27;;</span><br><span class="line">  ALPHABET += &#x27;abcdefghijklmnopqrstuvwxyz&#x27;;</span><br><span class="line">  ALPHABET += &#x27;0123456789-_&#x27;;</span><br><span class="line">  var str = &#x27;&#x27;;</span><br><span class="line">  for (var i = 0; i &lt; length; ++i) &#123;</span><br><span class="line">    var rand = Math.floor(Math.random() * ALPHABET.length);</span><br><span class="line">    str += ALPHABET.substring(rand, rand + 1);</span><br><span class="line">  &#125;</span><br><span class="line">  return str;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">random_str(6) // &quot;NdQKOr&quot;</span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>random_str</code>函数接受一个整数作为参数，返回变量<code>ALPHABET</code>内的随机字符所组成的指定长度的字符串。</p>
</li>
</ul>
<h2 id="4-6-7Date-x2F-x2F-主要了解如何创建日期-new-Date，get方法"><a href="#4-6-7Date-x2F-x2F-主要了解如何创建日期-new-Date，get方法" class="headerlink" title="4.6.7Date&#x2F;&#x2F;主要了解如何创建日期 new Date，get方法"></a>4.6.7Date&#x2F;&#x2F;主要了解如何创建日期 new Date，get方法</h2><h4 id="7-1作为普通函数"><a href="#7-1作为普通函数" class="headerlink" title="7.1作为普通函数"></a>7.1作为普通函数</h4><p>无论有没有参数，直接调用<code>Date</code>总是返回当前时间。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Date()</span><br><span class="line">// &quot;Tue Dec 01 2015 09:34:43 GMT+0800 (CST)&quot;</span><br></pre></td></tr></table></figure>

<h4 id="7-2作为构造函数"><a href="#7-2作为构造函数" class="headerlink" title="7.2作为构造函数"></a>7.2作为构造函数</h4><p>作为构造函数时，<code>Date</code>对象可以接受多种格式的参数，返回一个该参数对应的时间实例。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 参数为日期字符串</span><br><span class="line">new Date(&#x27;January 6, 2013&#x27;);</span><br><span class="line">// Sun Jan 06 2013 00:00:00 GMT+0800 (CST)</span><br><span class="line"></span><br><span class="line">// 参数为多个整数，</span><br><span class="line">// 代表年、月、日、小时、分钟、秒、毫秒</span><br><span class="line">new Date(2013, 0, 1, 0, 0, 0, 0)</span><br><span class="line">// Tue Jan 01 2013 00:00:00 GMT+0800 (CST)</span><br></pre></td></tr></table></figure>

<h4 id="7-3包含的静态函数"><a href="#7-3包含的静态函数" class="headerlink" title="7.3包含的静态函数"></a>7.3包含的静态函数</h4><p>没啥用</p>
<h4 id="7-4实例方法"><a href="#7-4实例方法" class="headerlink" title="7.4实例方法"></a>7.4实例方法</h4><p><strong>（1）只有get函数有用</strong>（暂时记住年月日星期就行）</p>
<ul>
<li><code>getTime()</code>：返回实例距离1970年1月1日00:00:00的毫秒数，等同于<code>valueOf</code>方法。</li>
<li><code>getDate()</code>：返回实例对象对应每个月的几号（从1开始）。</li>
<li><code>getDay()</code>：返回星期几，星期日为0，星期一为1，以此类推。</li>
<li><code>getFullYear()</code>：返回四位的年份。</li>
<li><code>getMonth()</code>：返回月份（0表示1月，11表示12月）。</li>
<li><code>getHours()</code>：返回小时（0-23）。</li>
<li><code>getMilliseconds()</code>：返回毫秒（0-999）。</li>
<li><code>getMinutes()</code>：返回分钟（0-59）。</li>
<li><code>getSeconds()</code>：返回秒（0-59）。</li>
<li><code>getTimezoneOffset()</code>：返回当前时间与 UTC 的时区差异，以分钟表示，返回结果考虑到了夏令时因素。</li>
</ul>
<p><strong>（2）本地时间</strong></p>
<p>以下三种方法，可以将 Date 实例转为表示本地时间的字符串。</p>
<ul>
<li>Date.prototype.toLocaleString()：完整的本地时间。</li>
<li>Date.prototype.toLocaleDateString()：本地日期（不含小时、分和秒）。</li>
<li>Date.prototype.toLocaleTimeString()：本地时间（不含年月日）。</li>
</ul>
<p>下面是用法实例。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var d = new Date(2013, 0, 1);</span><br><span class="line"></span><br><span class="line">d.toLocaleString()</span><br><span class="line">// 中文版浏览器为&quot;2013年1月1日 上午12:00:00&quot;</span><br><span class="line">// 英文版浏览器为&quot;1/1/2013 12:00:00 AM&quot;</span><br><span class="line"></span><br><span class="line">d.toLocaleDateString()</span><br><span class="line">// 中文版浏览器为&quot;2013年1月1日&quot;</span><br><span class="line">// 英文版浏览器为&quot;1/1/2013&quot;</span><br><span class="line"></span><br><span class="line">d.toLocaleTimeString()</span><br><span class="line">// 中文版浏览器为&quot;上午12:00:00&quot;</span><br><span class="line">// 英文版浏览器为&quot;12:00:00 AM&quot;</span><br></pre></td></tr></table></figure>

<p>这三个方法都有两个可选的参数。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">dateObj.toLocaleString([locales[, options]])</span><br><span class="line">dateObj.toLocaleDateString([locales[, options]])</span><br><span class="line">dateObj.toLocaleTimeString([locales[, options]])</span><br></pre></td></tr></table></figure>

<p>这两个参数中，<code>locales</code>是一个指定所用语言的字符串，<code>options</code>是一个配置对象。下面是<code>locales</code>的例子，分别采用<code>en-US</code>和<code>zh-CN</code>语言设定。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var d = new Date(2013, 0, 1);</span><br><span class="line"></span><br><span class="line">d.toLocaleString(&#x27;en-US&#x27;) // &quot;1/1/2013, 12:00:00 AM&quot;</span><br><span class="line">d.toLocaleString(&#x27;zh-CN&#x27;) // &quot;2013/1/1 上午12:00:00&quot;</span><br><span class="line"></span><br><span class="line">d.toLocaleDateString(&#x27;en-US&#x27;) // &quot;1/1/2013&quot;</span><br><span class="line">d.toLocaleDateString(&#x27;zh-CN&#x27;) // &quot;2013/1/1&quot;</span><br><span class="line"></span><br><span class="line">d.toLocaleTimeString(&#x27;en-US&#x27;) // &quot;12:00:00 AM&quot;</span><br><span class="line">d.toLocaleTimeString(&#x27;zh-CN&#x27;) // &quot;上午12:00:00&quot;</span><br></pre></td></tr></table></figure>

<h2 id="4-6-8RegExp正则-x2F-x2F-找旧笔记对比着看"><a href="#4-6-8RegExp正则-x2F-x2F-找旧笔记对比着看" class="headerlink" title="4.6.8RegExp正则&#x2F;&#x2F;找旧笔记对比着看"></a>4.6.8RegExp正则&#x2F;&#x2F;找旧笔记对比着看</h2><h2 id="4-6-9JOSN"><a href="#4-6-9JOSN" class="headerlink" title="4.6.9JOSN"></a>4.6.9JOSN</h2><h4 id="9-1格式"><a href="#9-1格式" class="headerlink" title="9.1格式"></a>9.1格式</h4><ol>
<li><p>[]  {}</p>
<p>复合类型的值只能是数组或对象，不能是函数、正则表达式对象、日期对象。</p>
</li>
<li><p>String，Number，Boolean，NULL</p>
<p>原始类型的值只有四种：字符串、数值（必须以十进制表示，二进制十六进制都不行）、布尔值和null（不能使用NaN<code>, </code>Infinity, -Infinity和undefined）。</p>
</li>
<li><p>“asdf”</p>
<p>字符串必须使用双引号表示，不能使用单引号。</p>
</li>
<li><p>“key”：value</p>
<p>对象的键名必须放在双引号里面。</p>
</li>
<li><p>数组或对象最后一个成员的后面，不能加逗号。</p>
</li>
</ol>
<h4 id="9-2静态方法"><a href="#9-2静态方法" class="headerlink" title="9.2静态方法"></a>9.2静态方法</h4><ol>
<li><p>JSON.stringify	&#x2F;&#x2F;Json字符串化</p>
<ol>
<li><p>JSON.stringify(obj，[‘key1’,’key2’])	</p>
</li>
<li><p>JSON.stringify(value)</p>
<p>value可以是任何JSON格式支持的值，包括空对象、null、空数组</p>
</li>
<li><p>JSON.stringify(value,function)</p>
</li>
</ol>
</li>
<li><p>JSON.parse()              &#x2F;&#x2F;字符串JSON化</p>
</li>
</ol>
]]></content>
      <categories>
        <category>code</category>
        <category>note</category>
      </categories>
      <tags>
        <tag>JS</tag>
      </tags>
  </entry>
  <entry>
    <title>爬虫学习笔记-6.0两种异步观念（base大学数据结构+OS老师）</title>
    <url>/2023/03/16/Python/%E7%88%AC%E8%99%AB/P6-Py-0%E4%B8%A4%E7%A7%8D%E5%BC%82%E6%AD%A5%E8%A7%82%E5%BF%B5/</url>
    <content><![CDATA[<h1 id="有疑问-同步-关注通信机制-跟同步-描述进程中之间的关系-的区别-并发并行与异步的联系"><a href="#有疑问-同步-关注通信机制-跟同步-描述进程中之间的关系-的区别-并发并行与异步的联系" class="headerlink" title="[有疑问]同步(关注通信机制)跟同步(描述进程中之间的关系)的区别  并发并行与异步的联系"></a>[有疑问]同步(关注通信机制)跟同步(描述进程中之间的关系)的区别  并发并行与异步的联系</h1><h2 id="两种关于异步的理解"><a href="#两种关于异步的理解" class="headerlink" title="两种关于异步的理解"></a><strong>两种关于异步的理解</strong></h2><p>1.线程&#x2F;进程&#x2F;作业 不按代码顺序执行(其他)</p>
<p>2.不按发送请求的顺序返回结果(消息通信机制)</p>
<p><strong>消息通信机制中的同步异步(顺带并发并行)</strong></p>
<p>同步和异步关注的是<strong>消息通信机制</strong> (synchronous communication&#x2F; asynchronous communication)。所谓同步，就是在发出一个<em>调用</em>时，在没有得到结果之前，该<em>调用</em>就不返回。但是一旦调用返回，就得到返回值了。换句话说，就是由<em>调用者</em>主动等待这个<em>调用</em>的结果。</p>
<p>而异步则是相反，<em>调用</em>在发出之后，这个调用就直接返回了，所以没有返回结果。换句话说，当一个异步过程调用发出后，调用者不会立刻得到结果。而是在<em>调用</em>发出后，<em>被调用者</em>通过状态、通知来通知调用者，或通过回调函数处理这个调用。</p>
<p>并发和并行其实是异步(线程&#x2F;进程&#x2F;作业 不按代码顺序执行,不按发送请求的顺序返回结果)线程实现的两种形式。(这里的异步指的是什么异步???)</p>
<p>并行其实是真正的异步，多核CUP可以同时开启多条线程供多个任务同时执行，互不干扰。但</p>
<p>是并发就不一样了，是一个伪异步。在单核CUP中只能有一条线程，但是又想执行多个任务。这个时候，只能在一条线程上不停的切换任务，但是当并发是在多个cpu的情况下，那么并行和并发就没多大的区别了。但是在单个cpu的情况下的话，那么就只能并发而不能并行了。</p>
<p><strong>操作系统中的异步机制和进程同步机制</strong></p>
<ul>
<li>1.异步机制:由于操作系统都是并发的(一段时间内cpu到处跳),即拥有了异步性,导致了有些情况</li>
</ul>
<p><strong>(———–<strong>比如AB两进程并发操作数据10,想得到的结果是A进程先执行除法,B再进行加法….,再比如两人同时存钱,<strong>同时访问数据库,导致操作出问题</strong>(好像是有三四种可能,此处关于数据库安全性)</strong>————)</strong></p>
<p>无法按照顺序得到想要的结果,故提出进程同步机制,其中一个即信号量机制,信号量机制又可以实现同步和互斥,其中的同步和同步机制是两个概念.</p>
<ul>
<li>2.同步机制:使进程按某种顺序执行的各种机制(方法).<strong>并不是一定A执行完了B才能执行(同步)这种严格的顺序.还有AB谁先执行都行,但是同一时间只能有一个进程执行.</strong></li>
</ul>
<p><strong>操作系统中的同步机制中的同步和互斥</strong></p>
<p>显然，同步是一种更为复杂的互斥，而互斥是一种特殊的同步。</p>
<p>也就是说互斥是两个线程之间不可以同时运行，他们会相互排斥，必须等待一个线程运行完毕，另一个才能运行，而同步也是不能同时运行，但他是必须要安照某种次序来运行相应的线程（也是一种互斥）！</p>
<p><strong>互斥</strong>：是指某一资源同时只允许一个访问者对其进行访问，具有唯一性和排它性。但互斥无法限制访问者对资源的访问顺序，即访问是无序的。<strong>进程之间的执行没有先后顺序,但资源共享,同一时间只能有一个进程访问这个资源.</strong></p>
<p><strong>同步</strong>：是指在互斥的基础上（大多数情况），通过其它机制实现访问者对资源的有序访问。在大多数情况下，同步已经实现了互斥，特别是所有写入资源的情况必定是互斥的。少数情况是指可以允许多个访问者同时访问资源。<strong>进程之间的执行必须有先后顺序,资源共享,同一时间只能有一个进程访问这个资源.</strong></p>
<h1 id="同步异步并串行并行并发的区别"><a href="#同步异步并串行并行并发的区别" class="headerlink" title="同步异步并串行并行并发的区别"></a><strong>同步异步并串行并行并发的区别</strong></h1><p>   <strong>同步、异步：</strong></p>
<p>指的是能否开启新的线程。同步不能开启新的线程，异步可以。</p>
<p>   <strong>串行、并行：</strong></p>
<p>指的是任务的执行方式。串行是指多个任务时，各个任务按顺序执行，完成一个之后才能进行下一个。并行指的是多个任务可以同时执行。异步是多个任务并行的前提条件。</p>
<p>   <strong>并发和并行其实是异步线程实现的两种形式。并行其实是真正的异步，多核CUP可以同时开启多条线程供多个任务同时执行，互不干扰。但是并发就不一样了，是一个伪异步。在单核CUP中只能有一条线程，但是又想执行多个任务。这个时候，只能在一条线程上不停的切换任务，比如任务A执行了20%，任务A停下里，线程让给任务B，任务执行了30%停下，再让任务A执行。这样我们用的时候，由于CUP处理速度快，你看起来好像是同时执行，其实不是的，同一时间只会执行单个任务。但是当并发是在多个cpu的情况下，那么并行和并发就没多大的区别了。但是在单个cpu的情况下的话，那么就只能并发而不能并行了。</strong></p>
<p><a href="https://www.cnblogs.com/czk666/articles/9353160.html">查看原文</a></p>
<h1 id="同步异步-阻塞非阻塞-和nginx的IO模型"><a href="#同步异步-阻塞非阻塞-和nginx的IO模型" class="headerlink" title="同步异步,阻塞非阻塞 和nginx的IO模型"></a>同步异步,阻塞非阻塞 和nginx的IO模型</h1><p><a href="http://www.cnblogs.com/wxl-dede/p/5134636.html"><strong>同步异步,阻塞非阻塞 和nginx的IO模型</strong></a><strong>（这人的笔记都很有用!!!）</strong></p>
<p><a href="https://www.zhihu.com/question/19732473/answer/20851256">https://www.zhihu.com/question/19732473/answer/20851256</a></p>
<p><a href="https://www.zhihu.com/question/19732473/answer/14413599">https://www.zhihu.com/question/19732473/answer/14413599</a></p>
<p><a href="https://www.zhihu.com/question/19732473/answer/241673170">https://www.zhihu.com/question/19732473/answer/241673170</a></p>
]]></content>
      <categories>
        <category>code</category>
        <category>note</category>
      </categories>
      <tags>
        <tag>Python，Scrapy</tag>
      </tags>
  </entry>
  <entry>
    <title>爬虫学习笔记-6.100Scrapy性能提升（base百度）</title>
    <url>/2023/03/20/Python/%E7%88%AC%E8%99%AB/P6-Py-100Scrapy%E6%80%A7%E8%83%BD%E6%8F%90%E9%AB%98/</url>
    <content><![CDATA[<p>需求：scrapy爬取网页速度十分缓慢，在目标网站良好的情况下三天才跑了80w条数据，参考其他爬虫的速度，一天抓取1000w条数据是没有问题的，scrapy性能需要优化。</p>
<p>思路：经过各种搜索，scrapy提高性能核心逻辑是提高并发数量，最简单的实现方式可以通过调整settings的‘CONCURRENT_REQUESTS’等参数或者使用分布式爬虫来提速。除此之外代码也要尽量少用循环。本人的简单优化主要通过以下方式</p>
<p><strong>settings中设置CONCURRENT_REQUESTS</strong></p>
<p>scrapy默认CONCURRENT_REQUESTS 为16,可以将CONCURRENT_REQUESTS 的数量增加。要注意download_delay会影响到并发的效果，大概是由于每个request的处理要在download_delay时间之后。具体见链接<a href="https://link.jianshu.com/?t=http://blog.csdn.net/s150503/article/details/72571680">scrapy中CONCURRENT_REQUESTS与DOWNLOAD_DELAY的联系</a></p>
<p>DEPTH_PRIORITY &#x3D; 1 SCHEDULER_DISK_QUEUE &#x3D; ‘scrapy.squeues.PickleFifoDiskQueue’ SCHEDULER_MEMORY_QUEUE &#x3D; ‘scrapy.squeues.FifoMemoryQueue’</p>
<p><strong>spider中的循环优化</strong></p>
<p>尽量减少循环的层数，另外参考python优化的原则，在循环中少用”.”的方法。</p>
<p>lowerlist &#x3D; [‘this’, ‘is’, ‘lowercase’] upper &#x3D; str.upper upperlist &#x3D; [] append &#x3D; upperlist.append for word in lowerlist:    append(upper(word))    print(upperlist)</p>
<p><strong>中间价的优化</strong></p>
<p>当时写了一个简单的中间件用来记录请求失败的url，将中间件删掉后速度有所提升。</p>
<p><strong>异步导出数据</strong></p>
<p>具体没尝试过故此只放链接在次</p>
<p>[异步导出数据]<a href="https://link.jianshu.com/?t=http://www.cnblogs.com/ruoniao/p/6906344.html">http://www.cnblogs.com/ruoniao/p/6906344.html</a></p>
<p>参考文章</p>
<p><a href="https://link.jianshu.com/?t=http://python.jobbole.com/81035/">提升 Python 程序性能的 6 个技巧</a></p>
<p><a href="https://www.jianshu.com/p/df9c0d1e9087">Scrapy爬虫入门教程十三 Settings（设置）</a></p>
<p><a href="https://link.jianshu.com/?t=http://blog.csdn.net/zongzhiyuan/article/details/53364749">【Scrapy爬虫系列2】性能调优</a></p>
]]></content>
      <categories>
        <category>code</category>
        <category>note</category>
      </categories>
      <tags>
        <tag>Python，Scrapy</tag>
      </tags>
  </entry>
  <entry>
    <title>爬虫学习笔记-6.1异步相关问答（base大学JS+OS老师）</title>
    <url>/2023/03/17/Python/%E7%88%AC%E8%99%AB/P6-Py-1%E5%BC%82%E6%AD%A5%E9%97%AE%E7%AD%94/</url>
    <content><![CDATA[<h1 id="异步概念，异步执行，异步机制，异步传输数据"><a href="#异步概念，异步执行，异步机制，异步传输数据" class="headerlink" title="异步概念，异步执行，异步机制，异步传输数据"></a>异步概念，异步执行，异步机制，异步传输数据</h1><p>在我印象里异步传输数据就是A发送一字节数据，B不知道啥时候接收到，也不知道B啥时候返回。B返回时会通知A回来处理。</p>
<p>异步机制是通过回调函数。。。。。。</p>
<p>异步概念跟异步传输差不多</p>
<p>异步执行是异步概念基础上加了函数执行，目前只知道js里的函数能异步执行。</p>
<p>然后异步函数为了保证执行顺序 我们可以使用promise或者async&#x2F;await对异步函数进行包装</p>
<h2 id="1-既然是异步，为什么还要保证执行顺序？"><a href="#1-既然是异步，为什么还要保证执行顺序？" class="headerlink" title="1.既然是异步，为什么还要保证执行顺序？"></a>1.既然是异步，为什么还要保证执行顺序？</h2><p><strong>答：</strong>异步有时候需要做执行顺序的调整啊</p>
<p>比如</p>
<p>A:一个异步请求</p>
<p>B:一个输出</p>
<blockquote>
<p>你输出的时候，异步请求的结果还没出来(因为执行顺序不是同步的，异步就变成先执行B再执行A)</p>
</blockquote>
<h3 id="1-1设计操作系统的时候就应该解决这种问题了啊，同步和互斥，加锁。"><a href="#1-1设计操作系统的时候就应该解决这种问题了啊，同步和互斥，加锁。" class="headerlink" title="1.1设计操作系统的时候就应该解决这种问题了啊，同步和互斥，加锁。"></a>1.1设计操作系统的时候就应该解决这种问题了啊，同步和互斥，加锁。</h3><p>想通了：操作系统解决的是最基础的，函数顺序可能有问题关他毛事。函数是自己写的，os又不可能未卜先知。</p>
<img src="./P6-Py-1%E5%BC%82%E6%AD%A5%E9%97%AE%E7%AD%94.assets/image-20230421173728251.png" alt="image-20230421173728251" style="zoom:50%;" />

<h3 id="1-2宏观任务为什么就异步了？宏观任务是什么？"><a href="#1-2宏观任务为什么就异步了？宏观任务是什么？" class="headerlink" title="1.2宏观任务为什么就异步了？宏观任务是什么？"></a>1.2宏观任务为什么就异步了？宏观任务是什么？</h3><p>我的理解:因为宏观任务，微观任务这些都需要时间，比如花时间去请求，或者花时间调用计时器。 js的设计可能是为了避免这些用时的异步函数阻塞了执行。所以才会设计成先执行同步代码，再执行异步的。</p>
<p>宏观任务应该说是事件的来源</p>
<p>js里面的计时器是自带的，所以是宏观任务。 然后promise或者请求一般是宿主发出的，是微观请求。</p>
<h3 id="1-2异步函数是指os控制下使普通函数变得异步是么，还是说函数受程序员控制，你调什么东西让它异步？（应该是后面那个，比如用框架，但是框架是怎么让函数变成异步执行的？）"><a href="#1-2异步函数是指os控制下使普通函数变得异步是么，还是说函数受程序员控制，你调什么东西让它异步？（应该是后面那个，比如用框架，但是框架是怎么让函数变成异步执行的？）" class="headerlink" title="1.2异步函数是指os控制下使普通函数变得异步是么，还是说函数受程序员控制，你调什么东西让它异步？（应该是后面那个，比如用框架，但是框架是怎么让函数变成异步执行的？）"></a>1.2异步函数是指os控制下使普通函数变得异步是么，还是说函数受程序员控制，你调什么东西让它异步？（应该是后面那个，比如用框架，但是框架是怎么让函数变成异步执行的？）</h3><h3 id="1-3异步函数的实际执行顺序受制于避免阻塞还有？？"><a href="#1-3异步函数的实际执行顺序受制于避免阻塞还有？？" class="headerlink" title="1.3异步函数的实际执行顺序受制于避免阻塞还有？？"></a>1.3异步函数的实际执行顺序受制于避免阻塞还有？？</h3><p>想通了：异步函数的实际执行顺序好像跟进程的执行顺序一个道理。（想啥呢进程不就是函数+pcb）</p>
<blockquote>
<p>这块我明天得捋一捋了，我具体也忘了浏览器四个进程现在是怎么划分的，还有进程的一些特点之类</p>
</blockquote>
<blockquote>
<p>异步的问题，你看看掘金上对于event loop的解释，你就会明白js的执行顺序。</p>
<p>同步代码会直接按顺序执行。异步(分成宏任务和微任务，具体的区别你可以查一查。常见的宏任务主要是setTimeout,SetInterval这类计时器，以及I&#x2F;O操作,ui渲染的操作，微任务主要是Promise之类)。</p>
<p>具体的执行顺序看event loop的文章，我解释起来可能有点费劲。我把思路理一理再做解释</p>
</blockquote>
<ol start="4">
<li></li>
</ol>
]]></content>
      <categories>
        <category>code</category>
        <category>note</category>
      </categories>
      <tags>
        <tag>Python，Scrapy</tag>
      </tags>
  </entry>
  <entry>
    <title>爬虫学习笔记-6.3Ajax工作原理及实例（base百度）</title>
    <url>/2023/03/19/Python/%E7%88%AC%E8%99%AB/P6-Py-3Ajax%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%E5%8F%8A%E5%AE%9E%E4%BE%8B/</url>
    <content><![CDATA[<p><strong>1、关于ajax的名字</strong>　　</p>
<p>　　ajax 的全称是Asynchronous JavaScript and XML，其中，Asynchronous 是异步的意思，它有别于传统web开发中采用的同步的方式。</p>
<p><strong>2、关于同步和异步</strong>　</p>
<p>　　异步传输是面向字符的传输，它的单位是字符；而同步传输是面向比特的传输，它的单位是桢，它传输的时候要求接受方和发送方的时钟是保持一致的。</p>
<p>具体来说，异步传输是将比特分成小组来进行传送。一般每个小组是一个8位字符，在每个小组的头部和尾部都有一个开始位和一个停止位，它在传送过程中接收方和发送方的时钟不要求一致，也就是说，发送方可以在任何时刻发送这些小组，而接收方并不知道它什么时候到达。一个最明显的例子就是计算机键盘和主机的通信，按下一个键的同时向主机发送一个8比特位的ASCII代 码，键盘可以在任何时刻发送代码，这取决于用户的输入速度，内部的硬件必须能够在任何时刻接收一个键入的字符。这是一个典型的异步传输过程。异步传输存在 一个潜在的问题，即接收方并不知道数据会在什么时候到达。在它检测到数据并做出响应之前，第一个比特已经过去了。这就像有人出乎意料地从后面走上来跟你说 话，而你没来得及反应过来，漏掉了最前面的几个词。因此，每次异步传输的信息都以一个起始位开头，它通知接收方数据已经到达了，这就给了接收方响应、接收 和缓存数据比特的时间；在传输结束时，一个停止位表示该次传输信息的终止。按照惯例，空闲（没有传送数据）的线路实际携带着一个代表二进制1的信号。步传输的开始位使信号变成0，其他的比特位使信号随传输的数据信息而变化。最后，停止位使信号重新变回1，该信号一直保持到下一个开始位到达。例如在键盘上数字“1”，按照8比特位的扩展ASCII编码，将发送“00110001”，同时需要在8比特位的前面加一个起始位，后面一个停止位。</p>
<p>同步传输的比特分组要大得多。它不是独立地发送每个字符，每个字符都有自己的开始位和停止位，而是把它们组合起来一起发送。我们将这些组合称为数据帧，或简称为帧。</p>
<p>　　数据帧的第一部分包含一组同步字符，它是一个独特的比特组合，类似于前面提到的起始位，用于通知接收方一个帧已经到达，但它同时还能确保接收方的采样速度和比特的到达速度保持一致，使收发双方进入同步。</p>
<p>　　帧的最后一部分是一个帧结束标记。与同步字符一样，它也是一个独特的比特串，类似于前面提到的停止位，用于表示在下一帧开始之前没有别的即将到达的数据了。</p>
<p>　　同步传输通常要比异步传输快速得多。接收方不必对每个字符进行开始和停止的操作。一旦检测到帧同步字符，它就在接下来的数据到达时接收它们。另外，同步传输的开销也比较少。例如，一个典型的帧可能有500字节（即4000比特）的数据，其中可能只包含100比特的开销。这时，增加的比特位使传输的比特总数增加2.5%，这与异步传输中25 %的增值要小得多。随着数据帧中实际数据比特位的增加，开销比特所占的百分比将相应地减少。但是，数据比特位越长，缓存数据所需要的缓冲区也越大，这就限制了一个帧的大小。另外，帧越大，它占据传输媒体的连续时间也越长。在极端的情况下，这将导致其他用户等得太久。</p>
<p>　3、<strong>ajax所包含的技术</strong></p>
<p>　　<strong>ajax并非一种新的技术，而是几种原有技术的结合体。它由下列技术组合而成。</strong></p>
<p>　1.使用CSS和XHTML来表示。</p>
<ol start="2">
<li>使用DOM模型来交互和动态显示。</li>
</ol>
<p>  3.使用XMLHttpRequest来和服务器进行异步通信。</p>
<p>  4.使用javascript来绑定和调用。</p>
<p>在上面几中技术中，除了XmlHttpRequest对象以外，其它所有的技术都是基于web标准并且已经得到了广泛使用的，XMLHttpRequest虽然目前还没有被W3C所采纳，但是它已经是一个事实的标准，因为目前几乎所有的主流浏览器都支持它。</p>
<p>  <strong>4、ajax原理和XmlHttpRequest对象</strong></p>
<p>　　<strong>Ajax的原理简单来说通过XmlHttpRequest对象来向服务器发异步请求，从服务器获得数据，然后用javascript来操作DOM而更新页面。这其中最关键的一步就是从服务器获得请求数据。要清楚这个过程和原理，我们必须对 XMLHttpRequest有所了解。</strong></p>
<p>XMLHttpRequest是ajax的核心机制，它是在IE5中首先引入的，是一种支持异步请求的技术。简单的说，也就是javascript可以及时向服务器提出请求和处理响应，而不阻塞用户。达到无刷新的效果。</p>
<p> 　所以我们先从XMLHttpRequest讲起，来看看它的工作原理。</p>
<p> 　首先，我们先来看看XMLHttpRequest这个对象的属性。</p>
<p> 　　它的属性有：</p>
<p> 　　onreadystatechange 每次状态改变所触发事件的事件处理程序。</p>
<p> 　　responseText   从服务器进程返回数据的字符串形式。</p>
<p> 　　responseXML   从服务器进程返回的DOM兼容的文档数据对象。</p>
<p> 　　status      从服务器返回的数字代码，比如常见的404（未找到）和200（已就绪）</p>
<p> 　　status Text    伴随状态码的字符串信息</p>
<p> 　　readyState    对象状态值</p>
<p>　　　　0 (未初始化) 对象已建立，但是尚未初始化（尚未调用open方法）</p>
<p>　　　　1 (初始化) 对象已建立，尚未调用send方法</p>
<p>　　　　2 (发送数据) send方法已调用，但是当前的状态及http头未知</p>
<p>　　　　3 (数据传送中) 已接收部分数据，因为响应及http头不全，这时通过responseBody和responseText获取部分数据会出现错误，</p>
<p>　　　　4 (完成) 数据接收完毕,此时可以通过通过responseXml和responseText获取完整的回应数据</p>
<p>　　但是，由于各浏览器之间存在差异，所以创建一个XMLHttpRequest对象可能需要不同的方法。这个差异主要体现在IE和其它浏览器之间。下面是一个比较标准的创建XMLHttpRequest对象的方法。</p>
<p>function CreateXmlHttp() {</p>
<p>​    &#x2F;&#x2F;非IE浏览器创建XmlHttpRequest对象</p>
<p>​    if (window.XmlHttpRequest) {</p>
<p>​        xmlhttp &#x3D; new XmlHttpRequest();</p>
<p>​    }</p>
<p>​    &#x2F;&#x2F;IE浏览器创建XmlHttpRequest对象</p>
<p>​    if (window.ActiveXObject) {</p>
<p>​        try {</p>
<p>​            xmlhttp &#x3D; new ActiveXObject(“Microsoft.XMLHTTP”);</p>
<p>​        }</p>
<p>​        catch (e) {</p>
<p>​            try {</p>
<p>​                xmlhttp &#x3D; new ActiveXObject(“msxml2.XMLHTTP”);</p>
<p>​            }</p>
<p>​            catch (ex) { }</p>
<p>​        }</p>
<p>​    }</p>
<p>}</p>
<p>function Ustbwuyi() {</p>
<p>​    var data &#x3D; document.getElementById(“username”).value;</p>
<p>​    CreateXmlHttp();</p>
<p>​    if (!xmlhttp) {</p>
<p>​        alert(“创建xmlhttp对象异常！”);</p>
<p>​        return false;</p>
<p>​    }</p>
<p>​    xmlhttp.open(“POST”, url, false);</p>
<p>​    xmlhttp.onreadystatechange &#x3D; function () {</p>
<p>​        if (xmlhttp.readyState &#x3D;&#x3D; 4) {</p>
<p>​            document.getElementById(“user1”).innerHTML &#x3D; “数据正在加载…”;</p>
<p>​            if (xmlhttp.status &#x3D;&#x3D; 200) {</p>
<p>​                document.write(xmlhttp.responseText);</p>
<p>​            }</p>
<p>​        }</p>
<p>​    }</p>
<p>​    xmlhttp.send();</p>
<p>}</p>
<p>　　如上所示，函数首先检查XMLHttpRequest的整体状态并且保证它已经完成（readyStatus&#x3D;4），即数据已经发送完毕。然后根据服务器的设定询问请求状态，如果一切已经就绪（status&#x3D;200），那么就执行下面需要的操作。</p>
<p>对于XmlHttpRequest的两个方法，open和send，其中open方法指定了：</p>
<p>a、向服务器提交数据的类型，即post还是get。</p>
<p>b、请求的url地址和传递的参数。</p>
<p>c、传输方式，false为同步，true为异步。默认为true。如果是异步通信方式(true)，客户机就不等待服务器的响应；如果是同步方式(false)，客户机就要等到服务器返回消息后才去执行其他操作。我们需要根据实际需要来指定同步方式，在某些页面中，可能会发出多个请求，甚至是有组织有计划有队形大规模的高强度的request，而后一个是会覆盖前一个的，这个时候当然要指定同步方式。</p>
<p>Send方法用来发送请求。</p>
<p>　　知道了XMLHttpRequest的工作流程，我们可以看出，XMLHttpRequest是完全用来向服务器发出一个请求的，它的作用也局限于此，但它的作用是整个ajax实现的关键，因为ajax无非是两个过程，发出请求和响应请求。并且它完全是一种客户端的技术。而XMLHttpRequest正是处理了服务器端和客户端通信的问题所以才会如此的重要。</p>
<p>　　现在，我们对ajax的原理大概可以有一个了解了。我们可以把服务器端看成一个数据接口，它返回的是一个纯文本流，当然，这个文本流可以是XML格式，可以是Html，可以是Javascript代码，也可以只是一个字符串。这时候，XMLHttpRequest向服务器端请求这个页面，服务器端将文本的结果写入页面，这和普通的web开发流程是一样的，不同的是，客户端在异步获取这个结果后，不是直接显示在页面，而是先由javascript来处理，然后再显示在页面。至于现在流行的很多ajax控件，比如magicajax等，可以返回DataSet等其它数据类型，只是将这个过程封装了的结果，本质上他们并没有什么太大的区别。</p>
<p>　　<strong>5、ajax的缺点</strong></p>
<p>下面我着重讲一讲ajax的缺陷，因为平时我们大多注意的都是ajax给我们所带来的好处诸如用户体验的提升。而对ajax所带来的缺陷有所忽视。</p>
<p>　　下面所阐述的ajax的缺陷都是它先天所产生的。</p>
<p>  　1、ajax干掉了back按钮，即对浏览器后退机制的破坏。后退按钮是一个标准的web站点的重要功能，但是它没法和js进行很好的合作。这是ajax所带来的一个比较严重的问题，因为用户往往是希望能够通过后退来取消前一次操作的。那么对于这个问题有没有办法？答案是肯定的，用过Gmail的知道，Gmail下面采用的ajax技术解决了这个问题，在Gmail下面是可以后退的，但是，它也并不能改变ajax的机制，它只是采用的一个比较笨但是有效的办法，即用户单击后退按钮访问历史记录时，通过创建或使用一个隐藏的IFRAME来重现页面上的变更。（例如，当用户在Google Maps中单击后退时，它在一个隐藏的IFRAME中进行搜索，然后将搜索结果反映到Ajax元素上，以便将应用程序状态恢复到当时的状态。）</p>
<p>但是，虽然说这个问题是可以解决的，但是它所带来的开发成本是非常高的，和ajax框架所要求的快速开发是相背离的。这是ajax所带来的一个非常严重的问题。</p>
<p>   2、安全问题</p>
<p>技术同时也对IT企业带来了新的安全威胁，ajax技术就如同对企业数据建立了一个直接通道。这使得开发者在不经意间会暴露比以前更多的数据和服务器逻辑。ajax的逻辑可以对客户端的安全扫描技术隐藏起来，允许黑客从远端服务器上建立新的攻击。还有ajax也难以避免一些已知的安全弱点，诸如跨站点脚步攻击、SQL注入攻击和基于credentials的安全漏洞等。</p>
<p>   3、对搜索引擎的支持比较弱。</p>
<p>   4、破坏了程序的异常机制。至少从目前看来，像ajax.dll，ajaxpro.dll这些ajax框架是会破坏程序的异常机制的。关于这个问题，我曾经在开发过程中遇到过，但是查了一下网上几乎没有相关的介绍。后来我自己做了一次试验，分别采用ajax和传统的form提交的模式来删除一条数据……给我们的调试带来了很大的困难。</p>
<p>   5、另外，像其他方面的一些问题，比如说违背了url和资源定位的初衷。例如，我给你一个url地址，如果采用了ajax技术，也许你在该url地址下面看到的和我在这个url地址下看到的内容是不同的。这个和资源定位的初衷是相背离的。</p>
<p>   6、一些手持设备（如手机、PDA等）现在还不能很好的支持ajax，比如说我们在手机的浏览器上打开采用ajax技术的网站时，它目前是不支持的，当然，这个问题和我们没太多关系。</p>
<p>　　<strong>5、$.ajax()方法详解</strong>　　　</p>
<p>jquery中的ajax方法参数总是记不住，这里记录一下。</p>
<p><strong>1.url</strong>: </p>
<p>要求为String类型的参数，（默认为当前页地址）发送请求的地址。</p>
<p><strong>2.type</strong>: </p>
<p>要求为String类型的参数，请求方式（post或get）默认为get。注意其他http请求方法，例如put和delete也可以使用，但仅部分浏览器支持。</p>
<p><strong>3.timeout</strong>: </p>
<p>要求为Number类型的参数，设置请求超时时间（毫秒）。此设置将覆盖$.ajaxSetup()方法的全局设置。</p>
<p><strong>4.async</strong>: </p>
<p>要求为Boolean类型的参数，默认设置为true，所有请求均为异步请求。如果需要发送同步请求，请将此选项设置为false。注意，同步请求将锁住浏览器，用户其他操作必须等待请求完成才可以执行。</p>
<p><strong>5.cache</strong>: </p>
<p>要求为Boolean类型的参数，默认为true（当dataType为script时，默认为false），设置为false将不会从浏览器缓存中加载请求信息。</p>
<p><strong>6.data</strong>: </p>
<p>要求为Object或String类型的参数，发送到服务器的数据。如果已经不是字符串，将自动转换为字符串格式。get请求中将附加在url后。防止这种自动转换，可以查看　　processData选项。对象必须为key&#x2F;value格式，例如{foo1:”bar1”,foo2:”bar2”}转换为&amp;foo1&#x3D;bar1&amp;foo2&#x3D;bar2。如果是数组，JQuery将自动为不同值对应同一个名称。例如{foo:[“bar1”,”bar2”]}转换为&amp;foo&#x3D;bar1&amp;foo&#x3D;bar2。</p>
<p><strong>7.dataType</strong>: </p>
<p>要求为String类型的参数，预期服务器返回的数据类型。如果不指定，JQuery将自动根据http包mime信息返回responseXML或responseText，并作为回调函数参数传递。可用的类型如下：</p>
<p>xml：返回XML文档，可用JQuery处理。</p>
<p>html：返回纯文本HTML信息；包含的script标签会在插入DOM时执行。</p>
<p>script：返回纯文本JavaScript代码。不会自动缓存结果。除非设置了cache参数。注意在远程请求时（不在同一个域下），所有post请求都将转为get请求。</p>
<p>json：返回JSON数据。</p>
<p>jsonp：JSONP格式。使用SONP形式调用函数时，例如myurl?callback&#x3D;?，JQuery将自动替换后一个“?”为正确的函数名，以执行回调函数。</p>
<p>text：返回纯文本字符串。</p>
<p><strong>8.beforeSend</strong>：</p>
<p>要求为Function类型的参数，发送请求前可以修改XMLHttpRequest对象的函数，例如添加自定义HTTP头。在beforeSend中如果返回false可以取消本次ajax请求。XMLHttpRequest对象是惟一的参数。</p>
<p>​      function(XMLHttpRequest){</p>
<p>​        this;  &#x2F;&#x2F;调用本次ajax请求时传递的options参数</p>
<p>​      }</p>
<p><strong>9.complete</strong>：</p>
<p>要求为Function类型的参数，请求完成后调用的回调函数（请求成功或失败时均调用）。参数：XMLHttpRequest对象和一个描述成功请求类型的字符串。</p>
<p>​     function(XMLHttpRequest, textStatus){</p>
<p>​       this;  &#x2F;&#x2F;调用本次ajax请求时传递的options参数</p>
<p>​     }</p>
<p><strong>10.success</strong>：要求为Function类型的参数，请求成功后调用的回调函数，有两个参数。</p>
<p>​     (1)由服务器返回，并根据dataType参数进行处理后的数据。</p>
<p>​     (2)描述状态的字符串。</p>
<p>​     function(data, textStatus){</p>
<p>​      &#x2F;&#x2F;data可能是xmlDoc、jsonObj、html、text等等</p>
<p>​      this; &#x2F;&#x2F;调用本次ajax请求时传递的options参数</p>
<p>​     }</p>
<p><strong>11.error</strong>:</p>
<p>要求为Function类型的参数，请求失败时被调用的函数。该函数有3个参数，即XMLHttpRequest对象、错误信息、捕获的错误对象(可选)。ajax事件函数如下：</p>
<p>​    function(XMLHttpRequest, textStatus, errorThrown){</p>
<p>​     &#x2F;&#x2F;通常情况下textStatus和errorThrown只有其中一个包含信息</p>
<p>​     this;  &#x2F;&#x2F;调用本次ajax请求时传递的options参数</p>
<p>​    }</p>
<p><strong>12.contentType</strong>：</p>
<p>要求为String类型的参数，当发送信息至服务器时，内容编码类型默认为”application&#x2F;x-www-form-urlencoded”。该默认值适合大多数应用场合。</p>
<p><strong>13.dataFilter</strong>：</p>
<p>要求为Function类型的参数，给Ajax返回的原始数据进行预处理的函数。提供data和type两个参数。data是Ajax返回的原始数据，type是调用jQuery.ajax时提供的dataType参数。函数返回的值将由jQuery进一步处理。</p>
<p>​      function(data, type){</p>
<p>​        &#x2F;&#x2F;返回处理后的数据</p>
<p>​        return data;</p>
<p>​      }</p>
<p><strong>14.dataFilter</strong>：</p>
<p>要求为Function类型的参数，给Ajax返回的原始数据进行预处理的函数。提供data和type两个参数。data是Ajax返回的原始数据，type是调用jQuery.ajax时提供的dataType参数。函数返回的值将由jQuery进一步处理。</p>
<p>​      function(data, type){</p>
<p>​        &#x2F;&#x2F;返回处理后的数据</p>
<p>​        return data;</p>
<p>​      }</p>
<p><strong>15.global</strong>：</p>
<p>要求为Boolean类型的参数，默认为true。表示是否触发全局ajax事件。设置为false将不会触发全局ajax事件，ajaxStart或ajaxStop可用于控制各种ajax事件。</p>
<p><strong>16.ifModified</strong>：</p>
<p>要求为Boolean类型的参数，默认为false。仅在服务器数据改变时获取新数据。服务器数据改变判断的依据是Last-Modified头信息。默认值是false，即忽略头信息。</p>
<p><strong>17.jsonp</strong>：</p>
<p>要求为String类型的参数，在一个jsonp请求中重写回调函数的名字。该值用来替代在”callback&#x3D;?”这种GET或POST请求中URL参数里的”callback”部分，例如{jsonp:’onJsonPLoad’}会导致将”onJsonPLoad&#x3D;?”传给服务器。</p>
<p><strong>18.username</strong>：</p>
<p>要求为String类型的参数，用于响应HTTP访问认证请求的用户名。</p>
<p><strong>19.password</strong>：</p>
<p>要求为String类型的参数，用于响应HTTP访问认证请求的密码。</p>
<p><strong>20.processData</strong>：</p>
<p>要求为Boolean类型的参数，默认为true。默认情况下，发送的数据将被转换为对象（从技术角度来讲并非字符串）以配合默认内容类型”application&#x2F;x-www-form-urlencoded”。如果要发送DOM树信息或者其他不希望转换的信息，请设置为false。</p>
<p><strong>21.scriptCharset</strong>：</p>
<p>要求为String类型的参数，只有当请求时dataType为”jsonp”或者”script”，并且type是GET时才会用于强制修改字符集(charset)。通常在本地和远程的内容编码不同时使用。</p>
<p>案例代码：</p>
<p>​    <img src="https://note.youdao.com/yws/res/235/3EB867867B6C4083AFDEC192BB4C964A" alt="复制代码"></p>
<p>$(function(){    $(‘#send’).click(function(){         $.ajax({             type: “GET”,             url: “test.json”,             data: {username:$(“#username”).val(), content:$(“#content”).val()},             dataType: “json”,             success: function(data){                         $(‘#resText’).empty();   &#x2F;&#x2F;清空resText里面的所有内容                         var html &#x3D; ‘’;                          $.each(data, function(commentIndex, comment){                               html +&#x3D; ‘</p>
<h6 id="‘-comment-‘username’-‘"><a href="#‘-comment-‘username’-‘" class="headerlink" title="‘ + comment[‘username’]                                         + ‘:"></a>‘ + comment[‘username’]                                         + ‘:</h6><p>‘;                         });                         $(‘#resText’).html(html);                      }         });    });});</p>
<p>​    <img src="https://note.youdao.com/yws/res/237/AAABEE8CEF9F4C8F939708C74D3126EA" alt="复制代码"></p>
<p><a href="http://www.cnblogs.com/tylerdonet/p/3520862.html"> </a></p>
<p>　</p>
]]></content>
      <categories>
        <category>code</category>
        <category>note</category>
      </categories>
      <tags>
        <tag>Python，JS</tag>
      </tags>
  </entry>
  <entry>
    <title>爬虫学习笔记-6.2Scrapy、JS等异步的事件轮询机制（base百度）</title>
    <url>/2023/03/18/Python/%E7%88%AC%E8%99%AB/P6-Py-2%E5%BC%82%E6%AD%A5%E7%9A%84%E4%BA%8B%E4%BB%B6%E8%BD%AE%E8%AF%A2%E6%9C%BA%E5%88%B6/</url>
    <content><![CDATA[<h1 id="Scrapy、JS等异步的事件轮询机制"><a href="#Scrapy、JS等异步的事件轮询机制" class="headerlink" title="Scrapy、JS等异步的事件轮询机制"></a>Scrapy、JS等异步的事件轮询机制</h1><p><strong>什么是异步</strong></p>
<p><a href="https://www.cnblogs.com/lan-cheng/p/10223455.html">https://www.cnblogs.com/lan-cheng/p/10223455.html</a></p>
<p><strong>什么是异步</strong></p>
<p>提起异步大家大家首先应该想到同步，首先解释一下什么是同步。同步即为按照顺序执行，下一任务需要等前一个任务执行完成后才可以开始。那异步是什么呢，简单理解就是和同步相反，他不用等待上一个任务完成就可以开始，像io操作，网络请求一般会采用异步的方式进行</p>
<p><strong>JS是如何是实现异步操作的？</strong> </p>
<p>  js是单线程语言,JS的异步是通过回调函数实现的，即通过任务队列，在主线程执行完当前的任务栈（所有的同步操作），主线程空闲后<strong>轮询</strong>任务队列，并将任务队列中的任务（回调函数）取出来执行。”回调函数”（callback），就是那些会被主线程挂起来的代码。异步任务必须指定回调函数，当主线程开始执行异步任务，就是执行对应的回调函数。</p>
<p><strong>关于<strong><strong>异步中的轮询</strong></strong>机制和<strong><strong>OS中的轮询</strong></strong>机制的区别：异步中的轮询是指当一个线程执行完任务栈中所有任务后轮询任务队列中被挂起的任务——–cpu有事干，没事干了再统一问一次；OS中的轮询是指只要这个I&#x2F;O控制器没就绪，就一直问，就绪也在询问——–cpu有事没事都要问（输入输出系统中用到）；</strong></p>
<p>  虽然JS是单线程的但是浏览器的内核是多线程的，在浏览器的内核中不同的异步操作由不同的浏览器内核模块调度执行，异步操作会将相关回调添加到任务队列中。而不同的异步操作添加到任务队列的时机也不同，（看不懂）如 onclick, setTimeout, ajax 处理的方式都不同，这些异步操作是由浏览器内核的 webcore 来执行的，webcore 包含上图中的3种 webAPI，分别是 DOM Binding、network、timer模块。</p>
<p><strong>JS中的异步运行机制如下:</strong> </p>
<p>（1）所有同步任务都在主线程上执行，形成一个执行栈（execution context stack）。</p>
<p>（2）主线程之外，还存在一个”任务队列”（task queue）。只要异步任务有了运行结果，就在”任务队列”之中放置一个事件。</p>
<p>（3）一旦”执行栈”中的所有同步任务执行完毕，系统就会读取”任务队列”，看看里面有哪些事件。那些对应的异步任务，于是结束等待状态，进入执行栈，开始执行。</p>
<p>（4）主线程不断重复上面的第三步。</p>
<p>-—————————————————————————————————————————————————————————-</p>
<img src="./P6-Py-2%E5%BC%82%E6%AD%A5%E5%AD%A6%E4%B9%A0.assets/image-20230421174507864.png" alt="image-20230421174507864" style="zoom:50%;" />

<p>-————————————————————————————————————————————————————————————</p>
<img src="./P6-Py-2%E5%BC%82%E6%AD%A5%E5%AD%A6%E4%B9%A0.assets/image-20230421174442474.png" alt="image-20230421174442474" style="zoom:50%;" />

<p><strong>异步的几种实现方式</strong></p>
<ol>
<li>回调函数</li>
<li>使用promise</li>
<li>ES7的Async&#x2F;Await</li>
</ol>
<p> 　</p>
]]></content>
      <categories>
        <category>code</category>
        <category>note</category>
      </categories>
      <tags>
        <tag>Python，JS</tag>
      </tags>
  </entry>
  <entry>
    <title>JS学习笔记-4.7过滤（base  gpt ）</title>
    <url>/2023/04/13/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/JS/Q4-JS-7%E8%BF%87%E6%BB%A4/</url>
    <content><![CDATA[<h1 id="4-7-1数组过滤"><a href="#4-7-1数组过滤" class="headerlink" title="4.7.1数组过滤"></a>4.7.1数组过滤</h1><ol>
<li><p>filter():过滤出符合条件的元素,返回新数组。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">array.filter(callbackFunc)</span><br></pre></td></tr></table></figure>

<p>callbackFunc 是过滤函数,用于测试每个元素是否通过测试。<br>filter() 方法返回一个过滤后的新数组。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">const fruits = [&#x27;apple&#x27;, &#x27;banana&#x27;, &#x27;grape&#x27;, &#x27;mango&#x27;, &#x27;orange&#x27;];</span><br><span class="line"></span><br><span class="line">const filterItems = fruits.filter(fruit =&gt; fruit.length &gt; 6);</span><br><span class="line"></span><br><span class="line">console.log(filterItems); </span><br><span class="line">// [&#x27;banana&#x27;, &#x27;mango&#x27;, &#x27;orange&#x27;]</span><br></pre></td></tr></table></figure>
</li>
<li><p>slice():提取符合条件的元素,返回新数组，属于浅拷贝。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">array.slice(start, end)</span><br></pre></td></tr></table></figure>

<p>start 和 end 表示截取的起止位置,不包含 end 位置的元素。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">let fruits = [&#x27;apple&#x27;, &#x27;banana&#x27;, &#x27;grape&#x27;, &#x27;mango&#x27;, &#x27;orange&#x27;];</span><br><span class="line">let sliceFruits = fruits.slice(1, 3);</span><br><span class="line">// sliceFruits = [&#x27;banana&#x27;, &#x27;grape&#x27;]</span><br></pre></td></tr></table></figure>
</li>
<li><p>splice():移除元素,并可以在移除的位置添加新元素。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">array.splice(start, deleteCount, ...newItems) </span><br></pre></td></tr></table></figure>

<p>- start:移除元素的起始位置<br>- deleteCount:要移除的元素个数<br>- newItems:要添加的新元素示例:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">let fruits = [&#x27;apple&#x27;, &#x27;banana&#x27;, &#x27;grape&#x27;, &#x27;mango&#x27;, &#x27;orange&#x27;]; </span><br><span class="line">fruits.splice(1, 2, &#x27;strawberry&#x27;);</span><br><span class="line">// fruits = [&#x27;apple&#x27;, &#x27;strawberry&#x27;, &#x27;mango&#x27;, &#x27;orange&#x27;]</span><br></pre></td></tr></table></figure>
</li>
<li><p>pop()&#x2F;shift():移除数组的最后&#x2F;第一个元素。</p>
</li>
<li><p>concat():相当于C++里的set。连接两个数组,并返回新数组。可以用于过滤两个数组的公共元素。</p>
</li>
<li><p>…(展开运算符):将一个数组展开为用 , 分隔的参数序列,可以用于过滤数组中的某些元素。</p>
<p>除此之外,我们也可以使用 ES6 的 Set 和 Map 等新数据结构进行过滤。</p>
</li>
</ol>
]]></content>
      <categories>
        <category>code</category>
        <category>note</category>
      </categories>
      <tags>
        <tag>JS</tag>
      </tags>
  </entry>
  <entry>
    <title>JS学习笔记-4.8面向对象（base  gpt/答疑 ）</title>
    <url>/2023/04/14/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/JS/Q4-JS-8%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/</url>
    <content><![CDATA[<h1 id="4-8面向对象"><a href="#4-8面向对象" class="headerlink" title="4.8面向对象"></a>4.8面向对象</h1><h2 id="4-8-1浅薄的了解"><a href="#4-8-1浅薄的了解" class="headerlink" title="4.8.1浅薄的了解"></a>4.8.1浅薄的了解</h2><h3 id="1-构造函数"><a href="#1-构造函数" class="headerlink" title="1.构造函数"></a>1.构造函数</h3><p>用于反复创建相同的对象，和Java一样，就是父类。</p>
<p>this.price&#x3D;price;意味着把传进来的price参数挂载到构造函数内部当作属性用了。</p>
<h3 id="2-是否使用原型函数（prototype）"><a href="#2-是否使用原型函数（prototype）" class="headerlink" title="2.是否使用原型函数（prototype）"></a>2.是否使用原型函数（prototype）</h3><p>构造函数内的方法如果是不变的，那么每次new一个新实例的时候都会调用这个方法，从而造成资源浪费。所以要把它挂载到原型上，并写在函数外部，这样就相当于只初始化一次。这样他实例化时，就会通过实例化（子类）的声明覆盖掉父类的声明。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//Car构造函数的初始化</span><br><span class="line">Car(price)&#123;</span><br><span class="line">	this.price=price;</span><br><span class="line">&#125;</span><br><span class="line">//给Car函数增加原型函数</span><br><span class="line">Car.run=function()&#123;console.log(&quot;run as 100km/h&quot;)&#125;</span><br></pre></td></tr></table></figure>

<p>构造函数内的方法如果是基于传进来的参数要进行选择性创建的，那么就不用写成原型函数，且可以写在构造函数内部。<br><img src="./Q4-JS-7%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1.assets/image-20230421171703306.png" alt="image-20230421171703306" style="zoom:33%;" /></p>
<h3 id="3-原型链"><a href="#3-原型链" class="headerlink" title="3.原型链"></a>3.原型链</h3><p>在调用某个类的子函数的时候，先去找它本身是否声明过（这会覆盖父类的声明），然后找父类内部是否声明过，再找父类的prototype（原型）函数中有没有。</p>
<h3 id="4-覆盖"><a href="#4-覆盖" class="headerlink" title="4.覆盖"></a>4.覆盖</h3><p>子类的重复声明，会把父类的声明覆盖掉。</p>
<h3 id="5-静态属性"><a href="#5-静态属性" class="headerlink" title="5.静态属性"></a>5.静态属性</h3><p>就是只属于自己的属性。简称属性。</p>
<p>注：构造函数也可以有只属于自己的（无法被继承的）属性。</p>
<h3 id="6-一些疑问"><a href="#6-一些疑问" class="headerlink" title="6.一些疑问"></a>6.一些疑问</h3><p>1.浅拷贝都有什么实现方式<br>2.为什么创建对象的时候，对象里面的方法用的是引用，而属性不是</p>
<pre><code>这是因为在 JavaScript 中,对象的方法和属性有不同的存储方式:
属性:
- 属性的值直接存储在对象中
- 当读取属性时,直接返回对象中存储的值方法:- 方法的值实际上是一个函数
- 函数是引用类型,所以方法的值是一个指向函数的引用
- 当读取方法时,返回的是对函数的引用
</code></pre>
<p>   <a href="https://test-rnt2063.slack.com/archives/D053Z3YFB4Y/p1682137400226899">https://test-rnt2063.slack.com/archives/D053Z3YFB4Y/p1682137400226899</a><br>3.为什么函数是引用类型，而不是拷贝？</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1.为了让函数实现共用</span><br><span class="line">2.避免每次传递函数时都需要创建一个函数的完整拷贝。</span><br><span class="line">因为函数也是对象,如果是值类型,每次传递都需要将整个函数对象拷贝一份,这会消耗额外资源。</span><br><span class="line">而作为引用类型,我们只需要传递函数的引用,就能在多个地方调用同一个函数,不需要每次都创建一个新的函数对象。</span><br><span class="line">3.支持函数的动态性。如果函数是值类型,那么函数创建后其引用就永远固定了。而作为引用类型,函数的引用是可以动态修改和重新赋值的。</span><br><span class="line">在 JavaScript 中,函数是对象,而对象是引用类型。</span><br><span class="line">所以当我们传递或赋值一个函数时,传递的其实是对该函数对象的引用,而不是函数的拷贝。</span><br></pre></td></tr></table></figure>

<p>   <a href="https://test-rnt2063.slack.com/archives/D053Z3YFB4Y/p1682137463065349">https://test-rnt2063.slack.com/archives/D053Z3YFB4Y/p1682137463065349</a><br>4.引用在JS里有什么用？</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. 允许对象之间共享信息。因为对对象的引用可以在多个变量之间传递,所以指向同一对象的多个变量可以共享该对象中的信息。</span><br><span class="line">例如:</span><br><span class="line">js</span><br><span class="line">let obj = &#123; a: 1 &#125;;</span><br><span class="line">let ref1 = obj;</span><br><span class="line">let ref2 = obj;</span><br><span class="line"></span><br><span class="line">ref1.a = 2;  // 通过 ref1 修改</span><br><span class="line"></span><br><span class="line">console.log(ref2.a); // 2  ref2 也受到影响</span><br><span class="line">这里 ref1 和 ref2 指向同一对象 obj,所以通过 ref1 对 obj 的修改也影响了 ref2。</span><br><span class="line"></span><br><span class="line">2. 实现继承和原型链。JS 中的继承是通过原型链实现的,子对象通过__proto__属性指向父对象,这个过程其实就是引用传递。</span><br><span class="line">例如:</span><br><span class="line">js</span><br><span class="line">let parent = &#123;</span><br><span class="line">  name: &#x27;parent&#x27; </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">let child = &#123;</span><br><span class="line">  __proto__: parent  // child 的 __proto__ 属性引用 parent</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">console.log(child.name); // parent </span><br><span class="line">这里 child 对 parent 的引用允许其访问 parent 的属性和方法。</span><br><span class="line"></span><br><span class="line">3. 函数也是对象,所以对函数的传递和赋值也是通过引用来实现的。这意味着多个变量可以共享同一个函数,并且函数的内部状态会影响所有接受到其引用的变量。</span><br><span class="line">例如:</span><br><span class="line">js</span><br><span class="line">function foo() &#123;</span><br><span class="line">  foo.count++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let bar = foo;</span><br><span class="line"></span><br><span class="line">bar();  // foo.count 是 1 </span><br><span class="line">foo();  // foo.count 是 2</span><br><span class="line">这里 bar 和 foo 指向同一个函数对象,所以调用 bar 或 foo 都会修改这个共享的函数对象。</span><br><span class="line"></span><br><span class="line">4. 允许循环引用。通过引用,两个对象可以相互引用对方,形成闭环。</span><br><span class="line">例如:</span><br><span class="line">js</span><br><span class="line">let obj1 = &#123;</span><br><span class="line">  name: &#x27;obj1&#x27;,</span><br><span class="line">  ref: obj2  // 引用 obj2 </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">let obj2 = &#123;</span><br><span class="line">  name: &#x27;obj2&#x27;,</span><br><span class="line">  ref: obj1  // 引用 obj1</span><br><span class="line">&#125;;</span><br><span class="line">  </span><br><span class="line">所以,总结来说,引用在 JS 中实现了对象之间的连接,是支持大部分面向对象特性和功能的基础。</span><br></pre></td></tr></table></figure>

<p>   <a href="https://test-rnt2063.slack.com/archives/D053Z3YFB4Y/p1682137511999319">https://test-rnt2063.slack.com/archives/D053Z3YFB4Y/p1682137511999319</a><br>5.为什么对象是引用类型？<br>   <a href="https://test-rnt2063.slack.com/archives/D053Z3YFB4Y/p1682137569143519">https://test-rnt2063.slack.com/archives/D053Z3YFB4Y/p1682137569143519</a><br>6.构造函数可以被继承的部分一定是引用类型吗？<br>   <a href="https://test-rnt2063.slack.com/archives/D053Z3YFB4Y/p1682137669380839">https://test-rnt2063.slack.com/archives/D053Z3YFB4Y/p1682137669380839</a><br>7.不是引用类型的部分怎么实现可以被继承的？<br>   <a href="https://test-rnt2063.slack.com/archives/D053Z3YFB4Y/p1682137704757199">https://test-rnt2063.slack.com/archives/D053Z3YFB4Y/p1682137704757199</a><br>8.构造函数中，可继承的部分中，不是引用类型的部分为什么不用引用实现被继承？<br>    每一个继承对象理应拥有父对象中某些属性的一个独立拷贝,而不是共享一个属性的引用<br>    <a href="https://test-rnt2063.slack.com/archives/D053Z3YFB4Y/p1682138844233269">https://test-rnt2063.slack.com/archives/D053Z3YFB4Y/p1682138844233269</a><br>9.完整拷贝对象比引用浪费了哪些资源？<br>    1更多的内存空间,需要存储对象的完整结构<br>    2更长的处理时间,需要遍历对象属性进行拷贝<br>    3创建额外的临时对象   </p>
<p>10.引用不用储存对象的完整结构吗？什么叫对象的完整结构？<br>    引用也需要存储对象的结构,但是与拷贝相比,引用只需要存储对象结构一次。<br>    引用的工作原理是:多个变量存储的是对同一个对象的引用,通过这个引用可以访问到对象的结构。</p>
]]></content>
      <categories>
        <category>code</category>
        <category>note</category>
      </categories>
      <tags>
        <tag>JS</tag>
      </tags>
  </entry>
  <entry>
    <title>JS学习笔记-4.9衍生知识（base gpt/答疑）</title>
    <url>/2023/04/15/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/JS/Q4-JS-9%E8%A1%8D%E7%94%9F%E7%9F%A5%E8%AF%86%EF%BC%88es6%E3%80%81%E8%BF%87%E6%BB%A4%E6%80%9D%E8%B7%AF%E3%80%81%E6%B7%B1%E6%B5%85%E6%8B%B7%E8%B4%9D%E7%9A%84%E5%8E%9F%E7%90%86%E3%80%81debug%E3%80%81%E5%87%BD%E6%95%B0%E5%A4%8D%E7%94%A8%EF%BC%89/</url>
    <content><![CDATA[<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 一个数据里面去匹配</span><br><span class="line">// 1.字符的匹配</span><br><span class="line">const text = &#x27;hello world&#x27;;</span><br><span class="line">const reg = /helli/;</span><br><span class="line"></span><br><span class="line">const result = text.match(reg);</span><br><span class="line"></span><br><span class="line">// console.log(&quot;result&quot;,result)</span><br><span class="line"></span><br><span class="line">// 2.在一堆数据里面去筛选</span><br><span class="line"></span><br><span class="line">// 3.浅拷贝</span><br><span class="line">const shallowClone = (target) =&gt; &#123;</span><br><span class="line">  const result = &#123;&#125;;</span><br><span class="line">  for (let key in target) &#123;</span><br><span class="line">    result[key] = target[key];</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  return result;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">// // 4.深拷贝</span><br><span class="line">// const deepClone = (target) =&gt; &#123;</span><br><span class="line">//     const obj = &#123;&#125;</span><br><span class="line">//     for (let key in target) &#123;</span><br><span class="line">//         const value = target[key];</span><br><span class="line">//         if (isObj(target)) &#123;</span><br><span class="line">//             obj[key] = deepClone(value)</span><br><span class="line">//         &#125; else &#123;</span><br><span class="line">//             obj[key] = value</span><br><span class="line">//         &#125;</span><br><span class="line">//     &#125;</span><br><span class="line"></span><br><span class="line">//     return obj</span><br><span class="line">// &#125;</span><br><span class="line"></span><br><span class="line">//5.找到复杂对象中的某几个符合的数据</span><br><span class="line">const list = [</span><br><span class="line">  &#123; name: &#x27;zhangsan&#x27;, id: 1 &#125;,</span><br><span class="line">  &#123; name: &#x27;lisi&#x27;, id: 2 &#125;,</span><br><span class="line">  &#123; name: &#x27;wangwu&#x27;, id: 3 &#125;,</span><br><span class="line">  &#123; name: &#x27;wangwu&#x27;, id: 4 &#125;,</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line">// 得分字段 score:10</span><br><span class="line"></span><br><span class="line">const getName = function (item) &#123;</span><br><span class="line">  return item.name === &#x27;wangwu&#x27;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">// 5.1 forEach 遍历</span><br><span class="line"></span><br><span class="line">// 5.2 for of遍历，判断 数组是否满足条件</span><br><span class="line"></span><br><span class="line">//5.3 判断条件独立出来，函数复用</span><br><span class="line"></span><br><span class="line">// 5.2.1every 所有条件满足返回true,否则返回false</span><br><span class="line">const everyResult = list.every(getName);</span><br><span class="line">console.log(&#x27;everyResult&#x27;, everyResult);</span><br><span class="line"></span><br><span class="line">// 5.2.2some 任一条件满足返回true，否则返回false</span><br><span class="line">const someResult = list.some(getName);</span><br><span class="line">console.log(&#x27;someResult&#x27;, someResult);</span><br><span class="line"></span><br><span class="line">const target = [];</span><br><span class="line"></span><br><span class="line">list.forEach((item) =&gt; &#123;</span><br><span class="line">  target.push(&#123;</span><br><span class="line">    ...item,</span><br><span class="line">    score: 10,</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">return target;</span><br><span class="line"></span><br><span class="line">// 5.3map</span><br><span class="line"></span><br><span class="line">// 5.4reduce</span><br><span class="line"></span><br><span class="line">// 6.深拷贝的底层原理：判断数据类型是否为Object</span><br><span class="line">const isObj = (target) =&gt;</span><br><span class="line">  Object.prototype.toString.call(target) === &#x27;[object Object]&#x27;;</span><br><span class="line"></span><br><span class="line">const deepClone = (target) =&gt; &#123;</span><br><span class="line">  const obj = &#123;&#125;;</span><br><span class="line">  for (let key in target) &#123;</span><br><span class="line">    const value = target[key];</span><br><span class="line">    debugger;</span><br><span class="line">    if (isObj(value)) &#123;</span><br><span class="line">      debugger;</span><br><span class="line">      obj[key] = deepClone(value);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      debugger;</span><br><span class="line">      obj[key] = value;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  return obj;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">deepClone(&#123; a: &#123; b: 10 &#125; &#125;);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>code</category>
        <category>note</category>
      </categories>
      <tags>
        <tag>JS</tag>
      </tags>
  </entry>
  <entry>
    <title></title>
    <url>/2023/04/22/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E3%80%90%E3%80%90%E3%80%90%E3%80%90%E3%80%90%E7%96%91%E9%97%AE%E8%A7%A3%E7%AD%94%E3%80%91%E3%80%91%E3%80%91%E3%80%91%E3%80%91/JS/main/</url>
    <content><![CDATA[// // // 一个数据里面去匹配 
// // // 字符的匹配
// // const text = 'hello world'
// // const reg = /helli/

// // const result = text.match(reg)

// // // console.log("result",result)


// // // 在一堆数据里面去筛选



// // // 浅拷贝
// // const shallowClone = (target) => {
// //     const result = {};
// //     for (let key in target) {
// //         result[key] = target[key]
// //     }

// //     return result
// // }



// // // 深拷贝
// // const deepClone = (target) => {   
// //     const obj = {}
// //     for (let key in target) {
// //         const value = target[key];
// //         if (isObj(target)) {
// //             obj[key] = deepClone(value)
// //         } else {
// //             obj[key] = value
// //         }
// //     }

// //     return obj
// // }



// // const list = [
// //     {name:"zhangsan",id:1},
// //     {name:"lisi",id:2},
// //     {name:"wangwu",id:3},
// //     {name:"wangwu",id:4},
// // ]


// // // 得分字段 score:10


// // const getName = function(item) {
// //     return item.name === 'wangwu'
// // };


// // // forEach 遍历


// // // 判断 数组是否满足条件

// // // every 所有条件满足返回true,否则返回false
// // const everyResult= list.every(getName)
// // console.log("everyResult",everyResult)

// // // some 任一条件满足返回true，否则返回false
// // const someResult= list.some(getName)
// // console.log("someResult",someResult)


// // const target = [];

// // list.forEach(item => {
// //     target.push({
// //         ...item,
// //         score:10
// //     })
// // })

// // return target

// // // map



// // // reduce

// // // 判断数据类型是否为Object
// const isObj = (target) => Object.prototype.toString.call(target) === '[object Object]'

// const deepClone = (target) => {   
//     const obj = {}
//     for (let key in target) {
//         const value = target[key];
//         debugger
//         if (isObj(value)) {
//             debugger
//             obj[key] = deepClone(value)
//         } else {
//             debugger
//             obj[key] = value
//         }
//     }

//     return obj
// }

// deepClone({a:{b:10}})]]></content>
  </entry>
  <entry>
    <title></title>
    <url>/2023/04/04/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E3%80%90%E3%80%90%E3%80%90%E3%80%90%E3%80%90%E7%96%91%E9%97%AE%E8%A7%A3%E7%AD%94%E3%80%91%E3%80%91%E3%80%91%E3%80%91%E3%80%91/CSS/%E5%9B%9B%E7%82%B9%E9%AA%B0%E5%AD%90/%E5%9B%9B%E7%82%B9%E9%AA%B0%E5%AD%90/</url>
    <content><![CDATA[/* 容器 */
.box {
    width: 80px;
    height: 80px;
    border-radius: 8px;

    /* 阴影效果 */
    box-shadow: rgba(50, 50, 93, 0.25) 0px 2px 5px -1px, rgba(0, 0, 0, 0.3) 0px 1px 3px -1px;
    display: flex;
    flex-direction: column;
    justify-content: space-between;
    padding: 12px 12px;
}

/*子容器*/
.box-content {
    display: flex;
    justify-content: space-between;
}


/* 骰子的点 */
.dot {
    width: 10px;
    height: 10px;
    background-color: #000;
    border-radius:50%;
}


]]></content>
  </entry>
  <entry>
    <title></title>
    <url>/2023/04/04/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E3%80%90%E3%80%90%E3%80%90%E3%80%90%E3%80%90%E7%96%91%E9%97%AE%E8%A7%A3%E7%AD%94%E3%80%91%E3%80%91%E3%80%91%E3%80%91%E3%80%91/CSS/%E5%9B%9B%E7%82%B9%E9%AA%B0%E5%AD%90/%E5%9B%9B%E7%82%B9%E9%AA%B0%E5%AD%90/</url>
    <content><![CDATA[<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
    <link rel="stylesheet" href="./main.css">
</head>
<body>
    <div class="box">
        <div class="box-content">
            <div class="dot"></div>
            <div class="dot"></div>
        </div>
        <div class="box-content">
            <div class="dot"></div>
            <div class="dot"></div>
        </div>
    </div>
</body>
</html>]]></content>
  </entry>
  <entry>
    <title></title>
    <url>/2023/04/05/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E3%80%90%E3%80%90%E3%80%90%E3%80%90%E3%80%90%E7%96%91%E9%97%AE%E8%A7%A3%E7%AD%94%E3%80%91%E3%80%91%E3%80%91%E3%80%91%E3%80%91/CSS/4.4%204.5position/3.%E7%B2%98%E6%80%A7%E5%AE%9A%E4%BD%8D/index/</url>
    <content><![CDATA[<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
    <link rel="stylesheet" href="./main.css">
</head>

<body>
    <div class="box">
        <ul class="menu">
            <li>链接A</li>
            <li>链接B</li>
            <li>链接C</li>
        </ul>
        <div class="content">
            <div>内容很长</div>
            <div>内容很长</div>
            <div>内容很长</div>
            <div>内容很长</div>
            <div>内容很长</div>
            <div>内容很长</div>
            <div>内容很长</div>
            <div>内容很长</div>
            <div>内容很长</div>
            <div>内容很长</div>
            <div>内容很长</div>
            <div>内容很长</div>
            <div>内容很长</div>
            <div>内容很长</div>
            <div>内容很长</div>
            <div>内容很长</div>
            <div>内容很长</div>
            <div>内容很长</div>
            <div>内容很长</div>
            <div>内容很长</div>
        </div>
    </div>
</body>

</html>]]></content>
  </entry>
  <entry>
    <title></title>
    <url>/2023/04/05/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E3%80%90%E3%80%90%E3%80%90%E3%80%90%E3%80%90%E7%96%91%E9%97%AE%E8%A7%A3%E7%AD%94%E3%80%91%E3%80%91%E3%80%91%E3%80%91%E3%80%91/CSS/4.4%204.5position/3.%E7%B2%98%E6%80%A7%E5%AE%9A%E4%BD%8D/main/</url>
    <content><![CDATA[* {
    margin: 0;
    padding: 0;
}
.box {
    position: relative;
}
ul {
    list-style: none;
    display: flex;
    background-color: #09d;
    padding: 6px 6px;
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
}
ul li {
    font-size: 14px;
    color: #fff;
}
ul li:not(:last-child) {
    margin-right: 8px;
}

.content div {
    margin: 60px 0;
}]]></content>
  </entry>
  <entry>
    <title></title>
    <url>/2023/04/05/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E3%80%90%E3%80%90%E3%80%90%E3%80%90%E3%80%90%E7%96%91%E9%97%AE%E8%A7%A3%E7%AD%94%E3%80%91%E3%80%91%E3%80%91%E3%80%91%E3%80%91/CSS/4.4%204.5position/1.%E5%9F%BA%E7%A1%80position/index/</url>
    <content><![CDATA[<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
    <link rel="stylesheet" href="./main.css">
</head>

<body>
    <div class="container">
        <div class="box"></div>
    </div>

    <div class="grand">
        <div class="parent">
            <div class="child"></div>
        </div>
    </div>
</body>

</html>]]></content>
  </entry>
  <entry>
    <title></title>
    <url>/2023/04/05/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E3%80%90%E3%80%90%E3%80%90%E3%80%90%E3%80%90%E7%96%91%E9%97%AE%E8%A7%A3%E7%AD%94%E3%80%91%E3%80%91%E3%80%91%E3%80%91%E3%80%91/CSS/4.4%204.5position/1.%E5%9F%BA%E7%A1%80position/main/</url>
    <content><![CDATA[.container {
    background-color: #09d;
    width: 400px;
    height: 400px;
    margin: 20px 20px;
}

.box {
    width: 50px;
    height: 50px;
    background-color: red;
    position: absolute;
    top: 0;
    left: 0;
}

.grand {
    background-color: yellow;
    width: 600px;
    height: 600px;
    margin: 20px 20px;
    /* 实际上不会根据 .grand 做偏移，直接父元素是body，为什么不能根据body做偏移？*/
    position: relative;
    top: 0px;
}

.parent {
    background-color: blue;
    width: 300px;
    height: 300px;
    padding: 10px 10px;
    /**可以尝试给.parent 加上position: relative;看下效果**/
}

.child {
    width: 50px;
    height: 50px;
    position: absolute;
    top: 0;
    left: 0;
}]]></content>
  </entry>
  <entry>
    <title></title>
    <url>/2023/04/05/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E3%80%90%E3%80%90%E3%80%90%E3%80%90%E3%80%90%E7%96%91%E9%97%AE%E8%A7%A3%E7%AD%94%E3%80%91%E3%80%91%E3%80%91%E3%80%91%E3%80%91/CSS/4.4%204.5position/0.%E7%9B%92%E5%AD%90/index/</url>
    <content><![CDATA[<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
    <link rel="stylesheet" href="./main.css">
</head>

<body>
    <div class="container">
        <div class="a">A</div>
        <div class="b">B</div>
    </div>
</body>

</html>]]></content>
  </entry>
  <entry>
    <title></title>
    <url>/2023/04/05/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E3%80%90%E3%80%90%E3%80%90%E3%80%90%E3%80%90%E7%96%91%E9%97%AE%E8%A7%A3%E7%AD%94%E3%80%91%E3%80%91%E3%80%91%E3%80%91%E3%80%91/CSS/4.4%204.5position/0.%E7%9B%92%E5%AD%90/main/</url>
    <content><![CDATA[.container {
    display: flex;
    justify-content: space-around;
}
.container .a,.container .b {
    width: 300px;
    height: 300px;
    background-color: #09d;
    font-size: 14px;
    color: #fff;
    padding: 12px 0;
    border: 2px solid red;
}

.container .a{
    box-sizing: border-box;
}


.container .b {
    box-sizing: content-box;
}]]></content>
  </entry>
  <entry>
    <title>JS学习笔记-4.10两道题（base gpt/答疑/BFE网站）</title>
    <url>/2023/04/15/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/JS/Q4-JS-10%E4%B8%A4%E9%81%93%E9%A2%98%EF%BC%88BFE.dev%EF%BC%89/</url>
    <content><![CDATA[<h2 id="107-找到最大的差"><a href="#107-找到最大的差" class="headerlink" title="107.找到最大的差"></a>107.找到最大的差</h2><p><a href="https://bigfrontend.dev/zh/problem/Find-the-largest-difference">107. 找到最大的差 | BFE.dev - 前端刷题，准备前端面试拿到心仪的Offer。 (bigfrontend.dev)</a></p>
<p>原始思路：略（还是框在C语言和Python里了，实现方法很麻烦，很多东西JS已经给包装好了可以直接用）</p>
<h3 id="法一："><a href="#法一：" class="headerlink" title="法一："></a>法一：</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 给定一个整数数组，任意选择两个数a和b，可以通过 Math.abs(a - b)求得其差值。</span><br><span class="line">// 请实现一个函数来求得这个数组的最大差值。</span><br><span class="line"></span><br><span class="line">// 解体思路其实就是最小值 - 最大值，再做绝对值的计算（因为差值是非0整数）</span><br><span class="line"></span><br><span class="line">// 如果不会使用sort方法进行排序，我们也可以自己实现一个sort方法</span><br><span class="line"></span><br><span class="line">// 默认的type为&quot;max&quot;,找出最大值,反之为&quot;max&quot;，找出最小值</span><br><span class="line">const findNum = (list, type = &quot;max&quot;) =&gt; &#123;</span><br><span class="line">  let target;</span><br><span class="line">  if (type === &quot;max&quot;) &#123;</span><br><span class="line">    list.forEach((item, index) =&gt; &#123;</span><br><span class="line">      if (index === 0) &#123;</span><br><span class="line">        // 开始循环，将首个数字作为基准，进行比较</span><br><span class="line">        target = item;</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">        if (item &gt; target) &#123;</span><br><span class="line">          // 替换target的值</span><br><span class="line">          target = item;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    list.forEach((item, index) =&gt; &#123;</span><br><span class="line">      if (index === 0) &#123;</span><br><span class="line">        target = item;</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">        if (item &lt; target) &#123;</span><br><span class="line">          target = item;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">  return target;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">// 上述的代码可以优化一下语句，因为整体思路是一致的</span><br><span class="line">// 进行index === 0 赋值</span><br><span class="line">// 通过 type 判断是什么条件下，更新target的值</span><br><span class="line">const simplifyFindNum = (list, type = &quot;max&quot;) =&gt; &#123;</span><br><span class="line">  let target;</span><br><span class="line">  // 优化一下，type不为max或者min，不处理数据了。</span><br><span class="line">  // 避免进入forEach语句浪费性能</span><br><span class="line">  if (type !== &quot;min&quot; &amp;&amp; type !== &quot;max&quot;) return target;</span><br><span class="line"></span><br><span class="line">  list.forEach((item, index) =&gt; &#123;</span><br><span class="line">    if (index === 0) &#123;</span><br><span class="line">      // 开始循环，将首个数字作为基准，进行比较</span><br><span class="line">      target = item;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      // 替换target的值</span><br><span class="line">      if (type === &quot;max&quot; &amp;&amp; item &gt; target) &#123;</span><br><span class="line">        target = item;</span><br><span class="line">      &#125;</span><br><span class="line">      if (type === &quot;min&quot; &amp;&amp; item &lt; target) &#123;</span><br><span class="line">        target = item;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">  return target;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">const largestDiff = (list) =&gt; &#123;</span><br><span class="line">    const maxNum = simplifyFindNum(list); // 获取数组最大值</span><br><span class="line">    const minNum = simplifyFindNum(list,&quot;min&quot;) // 获取数组最小值</span><br><span class="line">    const diff = Math.abs(minNum - maxNum) // 最小值 - 最大值，进行绝对值的计算</span><br><span class="line"></span><br><span class="line">    return diff</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const diff = largestDiff([-1, 2,3,10, 9]);</span><br></pre></td></tr></table></figure>

<h3 id="法二："><a href="#法二：" class="headerlink" title="法二："></a>法二：</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 给定一个整数数组，任意选择两个数a和b，可以通过 Math.abs(a - b)求得其差值。</span><br><span class="line">// 请实现一个函数来求得这个数组的最大差值。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// 解体思路其实就是最小值 - 最大值，再做绝对值的计算（因为差值是非0整数）</span><br><span class="line">const largestDiff = (list) =&gt; &#123;</span><br><span class="line">    const maxNum = Math.max.apply(Math,list); // 数组通过apply调用Math的max方法，获取数组最大值</span><br><span class="line">    const minNum = Math.min.apply(Math,list) // 同上，获取数组最小值</span><br><span class="line">    const diff = Math.abs(minNum - maxNum) // 最小值 - 最大值，进行绝对值的计算</span><br><span class="line"></span><br><span class="line">    return diff</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// largestDiff([-1, 2,3,10, 9])</span><br><span class="line"></span><br><span class="line">const diff = largestDiff([-1, 2,3,10, 9]);</span><br><span class="line">console.log(&quot;diff&quot;,diff)</span><br></pre></td></tr></table></figure>

<h3 id="法三："><a href="#法三：" class="headerlink" title="法三："></a>法三：</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 给定一个整数数组，任意选择两个数a和b，可以通过 Math.abs(a - b)求得其差值。</span><br><span class="line">// 请实现一个函数来求得这个数组的最大差值。</span><br><span class="line"></span><br><span class="line">// 解体思路其实就是最小值 - 最大值，再做绝对值的计算（因为差值是非0整数）</span><br><span class="line">// 解题思路，通过sort方法进行排序</span><br><span class="line">const largestDiff = (list) =&gt; &#123;</span><br><span class="line">  const sortedList = list.sort((prev, next) =&gt; next - prev); // 按照从大到小排序</span><br><span class="line">  const maxNum = sortedList[0];</span><br><span class="line">  const minNum = sortedList[sortedList.length-1];</span><br><span class="line">  const diff = Math.abs(minNum - maxNum); // 最小值 - 最大值，进行绝对值的计算</span><br><span class="line">  return diff;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">const diff = largestDiff([-1, 2, 3, 10, 9]);</span><br><span class="line">console.log(&quot;diff&quot;, diff);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="162-请找到未重复出现的整数"><a href="#162-请找到未重复出现的整数" class="headerlink" title="162. 请找到未重复出现的整数"></a>162. 请找到未重复出现的整数</h2><p><a href="https://bigfrontend.dev/zh/problem/find-the-single-integer">162. 请找到未重复出现的整数 | BFE.dev - 前端刷题，准备前端面试拿到心仪的Offer。 (bigfrontend.dev)</a></p>
<p>原始思路：哈希&#x2F;桶排（注意负数，需要下标映射）</p>
<p>claude思路：map（es6新特性，还没学到）</p>
<h3 id="原始方法（动态数组未映射）："><a href="#原始方法（动态数组未映射）：" class="headerlink" title="原始方法（动态数组未映射）："></a>原始方法（动态数组未映射）：</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">const arr = [10, 2, 2 , 1, 0, 0, 10]</span><br><span class="line">function findSingle(arr) &#123;</span><br><span class="line">  //js的除法是向下取整吗？（是的）</span><br><span class="line">  //哈希思想，需要映射数据，麻烦。const countArr=[arr.length/2+1];</span><br><span class="line">  //桶排思想，空间复杂度高，方便。但出现负数怎么办？（也要映射，整体前移就好）</span><br><span class="line">  //js数组不是动态数组吗(是)，不能自动扩容直接下标访问吗（能下标访问，但也要初始化，好像不能自动扩容），需要遍历出最大数值再生成数组是吗（可以不需要，用的话最好，用完了直接前移映射就完了）</span><br><span class="line">  </span><br><span class="line">  const countArr=[]</span><br><span class="line">  for(let i=0;i&lt;arr.length;++i)&#123;</span><br><span class="line">  	if(!countArr[arr[i]])&#123;</span><br><span class="line">  	countArr[arr[i]]=0;</span><br><span class="line">  	&#125;</span><br><span class="line">    countArr[arr[i]]++;</span><br><span class="line">    console.log(countArr[arr[i]])</span><br><span class="line">  &#125;</span><br><span class="line">  for(let i=0;i&lt;countArr.length;++i)&#123;</span><br><span class="line">    if(countArr[i]===1)&#123;</span><br><span class="line">      return countArr[i];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">findSingle(arr)</span><br></pre></td></tr></table></figure>



<h3 id="法一：定长数组桶排映射"><a href="#法一：定长数组桶排映射" class="headerlink" title="法一：定长数组桶排映射"></a>法一：定长数组桶排映射</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">使用数组解决第一个题目(找出数组中只出现一次的数)的最优解是:</span><br><span class="line">const arr = [10, 2, 2 , 1, 0, 0, 10, -5, -2];</span><br><span class="line"></span><br><span class="line">function findSingle(arr) &#123;</span><br><span class="line">  let max = 0;</span><br><span class="line">  let min = 0;</span><br><span class="line">  for (let num of arr) &#123;</span><br><span class="line">    max = Math.max(max, num);</span><br><span class="line">    min = Math.min(min, num);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  let countArr = new Array(max - min + 1).fill(0);</span><br><span class="line">  </span><br><span class="line">  for (let num of arr) &#123;</span><br><span class="line">    countArr[num - min]++; </span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  for (let i = 0; i &lt; countArr.length; i++) &#123;</span><br><span class="line">    if (countArr[i] === 1) return i + min;</span><br><span class="line">  &#125; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">findSingle(arr);  // -5</span><br><span class="line">解释:</span><br><span class="line">1. 这种方法先遍历数组一次,得到最大值 max 和最小值 min。</span><br><span class="line">2. 初始化 countArr 长度为 max - min + 1,正好可以容纳所有数值。</span><br><span class="line">3. 第二次遍历,使用 num - min 作为 countArr 下标,统计每个数出现次数。</span><br><span class="line">4. 找到次数为 1 的下标后,返回 i + min 恢复真实数值。</span><br><span class="line">5. 这种方法空间复杂度稳定在数组范围内,可以容纳任意范围的数,包括负数。</span><br><span class="line">这种方法相比其他数组方法有以下优点:</span><br><span class="line">1. 空间复杂度稳定,不会随数组最大值变化。</span><br><span class="line">2. 可以容纳任意范围的数,通过映射到数组中。</span><br><span class="line">3. 代码简洁高效。只需遍历两次数组。</span><br><span class="line">总结:</span><br><span class="line">相比动态数组多次判断是否初始化的方式,这个方法通过一次遍历得知数组范围,初始化恰当大小的数组,使空间复杂度稳定,且代码更简洁高效。</span><br><span class="line">所以如果要我选最优的数组解法,我会选择这个方法。当然,Map 方法由于内部实现原因,在大多数情况下仍然更为高效和优秀。但是如果考虑到兼容性,这个数组方法也是一个不错的选择。</span><br></pre></td></tr></table></figure>

<h3 id="法二：map-hash"><a href="#法二：map-hash" class="headerlink" title="法二：map-hash"></a>法二：map-hash</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 通过Map做映射关系</span><br><span class="line">// Map和Object的区别，Object的key需要为字符串，如果不是，会转化为字符串类型</span><br><span class="line">// Map的key可以为任意类型</span><br><span class="line">// Map使用set（写）和get（读） has(判断是否有映射关系)</span><br><span class="line">// https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Map</span><br><span class="line"></span><br><span class="line">const findSingle = (list) =&gt; &#123;</span><br><span class="line">  const hash = new Map(); // key为出现的数字，value为出现的次数</span><br><span class="line">  list.forEach((num) =&gt; &#123;</span><br><span class="line">    const val = hash.get(num);</span><br><span class="line">    // 没有映射关系，说明该数字首次出现</span><br><span class="line">    if (!hash.has(num)) &#123;</span><br><span class="line">      hash.set(num, 1); // 首次出现</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      hash.set(num, val + 1); // 出现次数+1</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  // hash是Map类型，是可迭代对象，可以直接使用forEach进行遍历</span><br><span class="line">  // 遍历哈希表(hash),找出出现次数(value)为1的数字(key)</span><br><span class="line">  // 如果这个题目存在多个出现次数为1的数字，可以考虑将target初始化为空数组，每次找出对应的数字做push操作</span><br><span class="line">  let target;</span><br><span class="line">  hash.forEach((value, key) =&gt; &#123;</span><br><span class="line">    if (value === 1) &#123;</span><br><span class="line">      target = key;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  return target</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">findSingle([10, 2, 2, 1, 0, 0, 10]);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="法三：-1"><a href="#法三：-1" class="headerlink" title="法三："></a>法三：</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 给定一个整数数组，除了一个数字之外，其余的数字均出现了两次。请找出这个只出现了一次的数。</span><br><span class="line">// const arr = [10, 2, 2 , 1, 0, 0, 10]</span><br><span class="line">// findSingle(arr) // 1</span><br><span class="line"></span><br><span class="line">// 思路，通过哈希表去实现（前端js没有对应的数据结构，但是我们一般可以通过Object的key-value的映射关系去实现）</span><br><span class="line">// 其中 key 代表 出现的数字,value 代表该次数出现的次数</span><br><span class="line">// 最终将对应的Object取出value为1的数字</span><br><span class="line"></span><br><span class="line">const findSingle = (list) =&gt; &#123;</span><br><span class="line">    const hash = &#123;&#125;; // key为出现的数字，value为出现的次数</span><br><span class="line">    list.forEach((num) =&gt; &#123;</span><br><span class="line">        const val = hash[num];</span><br><span class="line">        // 没有映射关系，说明该数字首次出现</span><br><span class="line">        if (!val) &#123;</span><br><span class="line">            hash[num] = 1;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            hash[num] = val +1; // 出现次数+1</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    // 遍历哈希表(hash),找出出现次数(value)为1的数字(key)</span><br><span class="line">    // 如果这个题目存在多个出现次数为1的数字，可以考虑将target初始化为空数组，每次找出对应的数字做push操作</span><br><span class="line">    let target;</span><br><span class="line">    for (const key in hash) &#123;</span><br><span class="line">        // 找出出现次数为1的数据</span><br><span class="line">        if (hash[key] === 1) &#123;</span><br><span class="line">            // target = key</span><br><span class="line">            target = Number(key)</span><br><span class="line">            // 这边有一个陷阱，key在存储时会被转成string类型，对应的数字的number类型，需要转化为Number</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">        </span><br><span class="line">    return target</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">findSingle([10, 2, 2 , 1, 0, 0, 10])</span><br></pre></td></tr></table></figure>





<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>思想钢印：再也不要想最优解的事了，下意识也不要想。</p>
<p>先实现再迭代优化。</p>
<p>不要纠结思路不是最优解，思路没问题也写得费劲说明需要熟悉语法。</p>
<h2 id="延申："><a href="#延申：" class="headerlink" title="延申："></a>延申：</h2><p>OK,让我们重新开始吧!到目前为止,我们探讨了几种解决这道题的思路和方法:</p>
<ol>
<li><p>定长数组:- 空间复杂度低但需要知道最大值,否则容易越界<br> - 无法容纳负数<br> - 适用于最大值已知且较小的情况</p>
</li>
<li><p>动态数组:- 可以自动扩容,无最大值限制,但是空间复杂度随最大值变化<br> - 需要判断数组元素是否存在,如果不存在先赋默认值<br> - 可以通过映射容纳负数<br> - 适用于最大值较大但性能要求不高的情况</p>
</li>
<li><p>Map:- key 可以是任意值,无最大值和负数限制<br> - 空间复杂度稳定,自动扩容<br> - 使用方便,get() 设置默认值,遍历使用 for..of<br> - 是解决这个问题的最通用高效数据结构</p>
</li>
</ol>
<p>  那么,如果让您重新解答这个问题,您会选择哪种思路和方法呢?除了上述几种,您还有其他的好想法吗?</p>
<p>  这里是一个新的问题供您思考和解答:输入一个整数数组,找到两个数和为特定值的下标。例如:输入: [3, 2, 5, 4, 1], target &#x3D; 7<br>  输出: [1, 3] (nums[1] + nums[3] &#x3D; 2 + 5 &#x3D; 7)</p>
<p>  您会如何解决这个问题?欢迎提出您的思路和代码实现,我们可以就此进行进一步探讨。</p>
]]></content>
      <categories>
        <category>code</category>
        <category>note</category>
      </categories>
      <tags>
        <tag>JS</tag>
      </tags>
  </entry>
  <entry>
    <title></title>
    <url>/2023/04/22/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/JS/VSCode%E4%BB%A3%E7%A0%81/test/</url>
    <content><![CDATA[let arr = ['a', 'b', 'c', 'A', 'B', 'A'];
let findA = (arr) => {
  const result = [];
  for (value of arr) {
    if (value === 'A') {
      result.push(value);
    }
  }
  return result;
};
findA(arr);
console.log(result);
]]></content>
  </entry>
  <entry>
    <title></title>
    <url>/2023/04/24/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E3%80%90%E3%80%90%E3%80%90%E3%80%90%E3%80%90%E7%96%91%E9%97%AE%E8%A7%A3%E7%AD%94%E3%80%91%E3%80%91%E3%80%91%E3%80%91%E3%80%91/JS/%E4%B8%A4%E9%81%93%E9%A2%98/01-custom-sort/</url>
    <content><![CDATA[// 给定一个整数数组，任意选择两个数a和b，可以通过 Math.abs(a - b)求得其差值。
// 请实现一个函数来求得这个数组的最大差值。

// 解体思路其实就是最小值 - 最大值，再做绝对值的计算（因为差值是非0整数）

// 如果不会使用sort方法进行排序，我们也可以自己实现一个sort方法

// 默认的type为"max",找出最大值,反之为"max"，找出最小值
const findNum = (list, type = "max") => {
  let target;
  if (type === "max") {
    list.forEach((item, index) => {
      if (index === 0) {
        // 开始循环，将首个数字作为基准，进行比较
        target = item;
      } else {
        if (item > target) {
          // 替换target的值
          target = item;
        }
      }
    });
  } else {
    list.forEach((item, index) => {
      if (index === 0) {
        target = item;
      } else {
        if (item < target) {
          target = item;
        }
      }
    });
  }
  return target;
};

// 上述的代码可以优化一下语句，因为整体思路是一致的
// 进行index === 0 赋值
// 通过 type 判断是什么条件下，更新target的值
const simplifyFindNum = (list, type = "max") => {
  let target;
  // 优化一下，type不为max或者min，不处理数据了。
  // 避免进入forEach语句浪费性能
  if (type !== "min" && type !== "max") return target;

  list.forEach((item, index) => {
    if (index === 0) {
      // 开始循环，将首个数字作为基准，进行比较
      target = item;
    } else {
      // 替换target的值
      if (type === "max" && item > target) {
        target = item;
      }
      if (type === "min" && item < target) {
        target = item;
      }
    }
  });
  return target;
};

const largestDiff = (list) => {
    const maxNum = simplifyFindNum(list); // 获取数组最大值
    const minNum = simplifyFindNum(list,"min") // 获取数组最小值
    const diff = Math.abs(minNum - maxNum) // 最小值 - 最大值，进行绝对值的计算

    return diff
}

const diff = largestDiff([-1, 2,3,10, 9]);]]></content>
  </entry>
  <entry>
    <title></title>
    <url>/2023/04/24/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E3%80%90%E3%80%90%E3%80%90%E3%80%90%E3%80%90%E7%96%91%E9%97%AE%E8%A7%A3%E7%AD%94%E3%80%91%E3%80%91%E3%80%91%E3%80%91%E3%80%91/JS/%E4%B8%A4%E9%81%93%E9%A2%98/01-sort/</url>
    <content><![CDATA[// 给定一个整数数组，任意选择两个数a和b，可以通过 Math.abs(a - b)求得其差值。
// 请实现一个函数来求得这个数组的最大差值。

// 解体思路其实就是最小值 - 最大值，再做绝对值的计算（因为差值是非0整数）
// 解题思路，通过sort方法进行排序
const largestDiff = (list) => {
  const sortedList = list.sort((prev, next) => next - prev); // 按照从大到小排序
  const maxNum = sortedList[0];
  const minNum = sortedList[sortedList.length-1];
  const diff = Math.abs(minNum - maxNum); // 最小值 - 最大值，进行绝对值的计算
  return diff;
};

const diff = largestDiff([-1, 2, 3, 10, 9]);
console.log("diff", diff);
]]></content>
  </entry>
  <entry>
    <title></title>
    <url>/2023/04/24/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E3%80%90%E3%80%90%E3%80%90%E3%80%90%E3%80%90%E7%96%91%E9%97%AE%E8%A7%A3%E7%AD%94%E3%80%91%E3%80%91%E3%80%91%E3%80%91%E3%80%91/JS/%E4%B8%A4%E9%81%93%E9%A2%98/01-math/</url>
    <content><![CDATA[// 给定一个整数数组，任意选择两个数a和b，可以通过 Math.abs(a - b)求得其差值。
// 请实现一个函数来求得这个数组的最大差值。


// 解体思路其实就是最小值 - 最大值，再做绝对值的计算（因为差值是非0整数）
const largestDiff = (list) => {
    const maxNum = Math.max.apply(Math,list); // 数组通过apply调用Math的max方法，获取数组最大值
    const minNum = Math.min.apply(Math,list) // 同上，获取数组最小值
    const diff = Math.abs(minNum - maxNum) // 最小值 - 最大值，进行绝对值的计算

    return diff
}





// largestDiff([-1, 2,3,10, 9])

const diff = largestDiff([-1, 2,3,10, 9]);
console.log("diff",diff)]]></content>
  </entry>
  <entry>
    <title></title>
    <url>/2023/04/24/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E3%80%90%E3%80%90%E3%80%90%E3%80%90%E3%80%90%E7%96%91%E9%97%AE%E8%A7%A3%E7%AD%94%E3%80%91%E3%80%91%E3%80%91%E3%80%91%E3%80%91/JS/%E4%B8%A4%E9%81%93%E9%A2%98/02-map-hash/</url>
    <content><![CDATA[// 通过Map做映射关系
// Map和Object的区别，Object的key需要为字符串，如果不是，会转化为字符串类型
// Map的key可以为任意类型
// Map使用set（写）和get（读） has(判断是否有映射关系)
// https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Map

const findSingle = (list) => {
  const hash = new Map(); // key为出现的数字，value为出现的次数
  list.forEach((num) => {
    const val = hash.get(num);
    // 没有映射关系，说明该数字首次出现
    if (!hash.has(num)) {
      hash.set(num, 1); // 首次出现
    } else {
      hash.set(num, val + 1); // 出现次数+1
    }
  });

  // hash是Map类型，是可迭代对象，可以直接使用forEach进行遍历
  // 遍历哈希表(hash),找出出现次数(value)为1的数字(key)
  // 如果这个题目存在多个出现次数为1的数字，可以考虑将target初始化为空数组，每次找出对应的数字做push操作
  let target;
  hash.forEach((value, key) => {
    if (value === 1) {
      target = key;
    }
  });

  return target
};

findSingle([10, 2, 2, 1, 0, 0, 10]);
]]></content>
  </entry>
  <entry>
    <title></title>
    <url>/2023/04/24/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E3%80%90%E3%80%90%E3%80%90%E3%80%90%E3%80%90%E7%96%91%E9%97%AE%E8%A7%A3%E7%AD%94%E3%80%91%E3%80%91%E3%80%91%E3%80%91%E3%80%91/JS/%E4%B8%A4%E9%81%93%E9%A2%98/02-obj-hash/</url>
    <content><![CDATA[// 给定一个整数数组，除了一个数字之外，其余的数字均出现了两次。请找出这个只出现了一次的数。
// const arr = [10, 2, 2 , 1, 0, 0, 10]
// findSingle(arr) // 1

// 思路，通过哈希表去实现（前端js没有对应的数据结构，但是我们一般可以通过Object的key-value的映射关系去实现）
// 其中 key 代表 出现的数字,value 代表该次数出现的次数
// 最终将对应的Object取出value为1的数字

const findSingle = (list) => {
    const hash = {}; // key为出现的数字，value为出现的次数
    list.forEach((num) => {
        const val = hash[num];
        // 没有映射关系，说明该数字首次出现
        if (!val) {
            hash[num] = 1;
        } else {
            hash[num] = val +1; // 出现次数+1
        }
    })

    // 遍历哈希表(hash),找出出现次数(value)为1的数字(key)
    // 如果这个题目存在多个出现次数为1的数字，可以考虑将target初始化为空数组，每次找出对应的数字做push操作
    let target;
    for (const key in hash) {
        // 找出出现次数为1的数据
        if (hash[key] === 1) {
            // target = key
            target = Number(key)
            // 这边有一个陷阱，key在存储时会被转成string类型，对应的数字的number类型，需要转化为Number
        }
    }
        
    return target
}

findSingle([10, 2, 2 , 1, 0, 0, 10])]]></content>
  </entry>
  <entry>
    <title></title>
    <url>/2023/05/01/giligili/</url>
    <content><![CDATA[<p><img src="/./markdown-img/giligili.assets/image-20230501160218413.png" alt="image-20230501160218413"></p>
<p>为什么直接使用display flex就能直接让flex的内容横过来</p>
<p>注释写好，是为了方便查找，ctrl f头部就能找到头部的所有样式</p>
<p><img src="/./markdown-img/giligili.assets/image-20230501162247727.png" alt="image-20230501162247727"></p>
<p><img src="/./markdown-img/giligili.assets/image-20230501162235824.png" alt="image-20230501162235824"></p>
<p>在f12计算样式里查样式</p>
<p>去掉边框线</p>
<p><img src="/./markdown-img/giligili.assets/image-20230501170906132.png" alt="image-20230501170906132"></p>
<p>padding ：上下px  左右px；</p>
<p>win+v剪切板</p>
]]></content>
  </entry>
  <entry>
    <title></title>
    <url>/2023/04/30/github%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<p>tailwind.css（公司在用）         </p>
<p>两个预处理器：sass（网站：sass文档）（用的多可以学，优点比如嵌套）less（用的多）</p>
<p>怎么在desktop上，</p>
<p>C:\Users\11096\Documents\GitHub\MyBlog&gt;code .</p>
<p>pnpm的优点</p>
<p>​		软连接</p>
<p>vscode 里直接打开终端</p>
<p>ctrl shift c（cmd） 或者ctrl shift &#96;（内嵌）</p>
<p>npm i下载依赖</p>
<p>npm run 【script命令】</p>
<p>0.npm -i下载依赖</p>
<p>&#x2F;&#x2F;上传</p>
<p>1.npm run build(第一个终端，结束后别关)</p>
<p>2.npm run start（第二个终端）</p>
<p>&#x2F;&#x2F;</p>
<p>1.本地启动</p>
<p>C:\Users\11096\Documents\GitHub\MyBlog&gt;npm run dev</p>
<blockquote>
<p><a href="mailto:&#98;&#x6c;&#x6f;&#x67;&#x2d;&#x76;&#50;&#64;&#48;&#x2e;&#x31;&#x2e;&#48;">&#98;&#x6c;&#x6f;&#x67;&#x2d;&#x76;&#50;&#64;&#48;&#x2e;&#x31;&#x2e;&#48;</a> dev<br>next dev -p 3002</p>
</blockquote>
<ol start="2">
<li></li>
</ol>
<p>更改about页面</p>
<p><img src="/./../%E5%85%B6%E5%AE%83/markdown-img/github%E4%BD%BF%E7%94%A8.assets/image-20230430144640393.png" alt="image-20230430144640393"></p>
<p>github仓库自动部署用网站</p>
<p><a href="https://app.netlify.com/">https://app.netlify.com/</a></p>
]]></content>
  </entry>
  <entry>
    <title>静态页面-1girigiri_love</title>
    <url>/2023/05/01/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%85%B6%E5%AE%83/Q0-intrest/</url>
    <content><![CDATA[<h1 id="1-视差滚动"><a href="#1-视差滚动" class="headerlink" title="1.视差滚动"></a>1.视差滚动</h1><p>可以查范例看看</p>
]]></content>
      <categories>
        <category>code</category>
        <category>note</category>
      </categories>
      <tags>
        <tag>HTML</tag>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title>静态页面-1girigiri_love</title>
    <url>/2023/05/01/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E9%9D%99%E6%80%81%E9%A1%B5%E9%9D%A2%E7%BB%83%E4%B9%A0/girigiri_love/</url>
    <content><![CDATA[<h2 id="1-一个问题"><a href="#1-一个问题" class="headerlink" title="1.一个问题"></a>1.一个问题</h2><p>想实现的效果：head里的‘个人’图标，想要实现红色圆形底色，且‘个人’图标需要跟其它图标大小相等。且内容部分不会由于宽度的原因冒出头来。</p>
<ol>
<li><h3 id="用broder-box"><a href="#用broder-box" class="headerlink" title="用broder-box"></a>用broder-box</h3><p>直接用会导致‘个人’图标缩小</p>
<img src="./../_posts/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%85%B6%E5%AE%83/markdown-img/girigiri_love.assets/image-20230505225632986.png" alt="image-20230505225632986" style="zoom:50%;" />
</li>
<li><h3 id="不用broder-box"><a href="#不用broder-box" class="headerlink" title="不用broder-box"></a>不用broder-box</h3><p>主体部分中，很多部分都需要设定宽度100%，又需要设定position：absolute</p>
<img src="./../_posts/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%85%B6%E5%AE%83/markdown-img/girigiri_love.assets/image-20230505225731776.png" alt="image-20230505225731776" style="zoom:33%;" />
</li>
<li><h3 id="总结：用broder-box，所以要改‘个人部分’，最好的办法是"><a href="#总结：用broder-box，所以要改‘个人部分’，最好的办法是" class="headerlink" title="总结：用broder-box，所以要改‘个人部分’，最好的办法是"></a>总结：用broder-box，所以要改‘个人部分’，最好的办法是</h3><ol>
<li><p>利用选择器的优先级原理，给‘个人’的·上一层加一个id&#x3D;user。上一层本身的class选择器不用管。</p>
<p>重复的部分会被id选择器覆盖。</p>
<p><img src="./../_posts/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%85%B6%E5%AE%83/markdown-img/girigiri_love.assets/image-20230505232718506.png" alt="image-20230505232718506" style="zoom:33%;" /><img src="./../_posts/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%85%B6%E5%AE%83/markdown-img/girigiri_love.assets/image-20230505233056969.png" alt="image-20230505233056969" style="zoom: 50%;" /></p>
</li>
<li><p>设置它的宽高使其（装‘个人’图片的盒子）成为一个正方形，然后设置border-radius。&#x2F;&#x2F;底部红圆</p>
</li>
<li><p>然后通过设置padding来合理缩小图片。</p>
<img src="./../_posts/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%85%B6%E5%AE%83/markdown-img/girigiri_love.assets/1683300580219.png" alt="1683300580219" style="zoom:38%;" /></li>
</ol>
</li>
</ol>
<h2 id="2-一个知识点"><a href="#2-一个知识点" class="headerlink" title="2.一个知识点"></a>2.一个知识点</h2><p>position：absolute是在偏移，它如果设了left 20等，这和width：100%是互斥的。所以要用broder-box；</p>
<h2 id="3-一个技巧"><a href="#3-一个技巧" class="headerlink" title="3.一个技巧"></a>3.一个技巧</h2><p>debug可以在浏览器端*{border: 1px solid green;}</p>
<h2 id="4-最终效果-底部红字是桌面歌词"><a href="#4-最终效果-底部红字是桌面歌词" class="headerlink" title="4.最终效果(底部红字是桌面歌词)"></a>4.最终效果(底部红字是桌面歌词)</h2><p><img src="/./../_posts/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%85%B6%E5%AE%83/markdown-img/girigiri_love.assets/image-20230505234450766.png" alt="image-20230505234450766"></p>
]]></content>
      <categories>
        <category>code</category>
        <category>note</category>
      </categories>
      <tags>
        <tag>HTML</tag>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title></title>
    <url>/2023/04/25/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/JS/VSCode%E4%BB%A3%E7%A0%81/String%E7%BB%83%E4%B9%A0/</url>
    <content><![CDATA[let str = 'Hello World';

//1.访问单个字符：charAt访问法||方括号访问法
console.log('1.访问单个字符：charAt访问法||方括号访问法');
console.log('charAt访问法 ' + str.charAt(0));
console.log('方括号访问法 ' + str[0]);
console.log('由于方括号表示法不可修改该字符,否则会报错' + str);
//str[0] = 'c';
//str[0] = '';

//2.标记变量（es6）
console.log('2.标记变量（es6）');
let a = 'a',
  b = 'b';
console.log(
  '${}号使得' +
    `${a} 不用加号就能连接 ${b}  ，易错点：用的是反单引号，不是单引号`
);

//3.比较字符串：><=
console.log('3.比较字符串：><=');
if (a < b) {
  console.log(`${a} < ${b}`);
}

//4.at()
var str4 = str;
console.log('4. ' + str4.at(1));

//5.includes()
var str5 = str;
console.log('5. ' + str5.includes('he'));

//6.concat()
var str6 = str;
console.log('6. ' + str6.concat(' ', 'hi', ' ', 'there'));

//7.lastIndexOf()
var str7 = str;
console.log('7. ' + str7 + '最后一个l的下标是' + str7.lastIndexOf('l'));

//8.slice()切片
var str8 = str;
console.log('8. ' + str8.slice(0, 9));

//9.split()拆分
]]></content>
  </entry>
  <entry>
    <title></title>
    <url>/2023/06/21/MachineLearning/Machine-learning-learning-notes-master/README/</url>
    <content><![CDATA[<p>本文为周志华《机器学习》的学习笔记，记录了本人在学习这本书的过程中的理解思路以及一些有助于消化书内容的拓展知识，笔记中参考了许多网上的大牛经典博客以及李航《统计学习》的内容，向前辈们和知识致敬！</p>
<blockquote>
<p>啃西瓜学习交流QQ群: 531701485， 遇到疑问可以随时在上面提问，并会不定期分享优质的机器&#x2F;深度学习资料，欢迎各位机器学习爱好者的入群讨论学习!</p>
</blockquote>
<blockquote>
<p>作者目前在腾讯微信事业群从事大数据、机器学习、推荐系统工作，团队会定期输出：机器学习在实际业务领域的技术总结，欢迎大家关注学习，共同进步！</p>
</blockquote>
<img src="https://ftp.bmp.ovh/imgs/2021/07/022f98f41a401e3a.jpeg" width="250px" height="250px" />

]]></content>
  </entry>
  <entry>
    <title>西瓜书1 2.1 2.2 2.3 2.4</title>
    <url>/2023/06/21/MachineLearning/Machine-learning-learning-notes-master/%E5%91%A8%E5%BF%97%E5%8D%8E%E3%80%8AMachine%20Learning%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(1)--%E7%BB%AA%E8%AE%BA/</url>
    <content><![CDATA[<p><strong>1  绪论</strong></p>
<p>傍晚小街路面上沁出微雨后的湿润，和熙的细风吹来，抬头看看天边的晚霞，嗯，明天又是一个好天气。走到水果摊旁，挑了个根蒂蜷缩、敲起来声音浊响的青绿西瓜，一边满心期待着皮薄肉厚瓢甜的爽落感，一边愉快地想着，这学期狠下了工夫，基础概念弄得清清楚楚，算法作业也是信手拈来，这门课成绩一定差不了！哈哈，也希望自己这学期的machine learning课程取得一个好成绩！</p>
<p><strong>1.1 机器学习的定义</strong></p>
<p>正如我们根据过去的经验来判断明天的天气，吃货们希望从购买经验中挑选一个好瓜，那能不能让计算机帮助人类来实现这个呢？机器学习正是这样的一门学科，人的“经验”对应计算机中的“数据”，让计算机来学习这些经验数据，生成一个算法模型，在面对新的情况中，计算机便能作出有效的判断，这便是机器学习。</p>
<p>另一本经典教材的作者Mitchell给出了一个形式化的定义，假设：</p>
<ul>
<li>P：计算机程序在某任务类T上的性能。</li>
<li>T：计算机程序希望实现的任务类。</li>
<li>E：表示经验，即历史的数据集。</li>
</ul>
<p>若该计算机程序通过利用经验E在任务T上获得了性能P的改善，则称该程序对E进行了学习。</p>
<p><strong>1.2 机器学习的一些基本术语</strong></p>
<p>假设我们收集了一批西瓜的数据，例如：（色泽&#x3D;青绿;根蒂&#x3D;蜷缩;敲声&#x3D;浊响)， (色泽&#x3D;乌黑;根蒂&#x3D;稍蜷;敲声&#x3D;沉闷)， (色泽&#x3D;浅自;根蒂&#x3D;硬挺;敲声&#x3D;清脆)……每对括号内是一个西瓜的记录，定义：	 </p>
<ul>
<li><p>所有记录的集合为：数据集。</p>
</li>
<li><p>每一条记录为：一个实例（instance）或样本（sample）。</p>
</li>
<li><p>例如：色泽或敲声，单个的特点为【【特征】】（feature）或属性（attribute）。</p>
</li>
<li><p>对于一条记录，如果在坐标轴上表示，每个西瓜都可以用坐标轴中的一个点表示，一个点也是一个向量，例如（青绿，蜷缩，浊响），即每个西瓜为：一个【【特征向量】】（feature vector）。</p>
</li>
<li><p>一个样本的特征数为：维数（dimensionality），该西瓜的例子维数为3，当维数非常大时，也就是现在说的“维数灾难”。</p>
<p> 计算机程序学习经验数据生成算法模型的过程中，每一条记录称为一个“训练样本”，同时在训练好模型后，我们希望使用新的样本来测试模型的效果，则每一个新的样本称为一个“测试样本”。定义：	</p>
</li>
<li><p>所有训练样本的集合为：训练集（trainning set），[特殊]。</p>
</li>
<li><p>所有测试样本的集合为：测试集（test set），[一般]。  </p>
</li>
<li><p>机器学习出来的模型适用于新样本的能力为：泛化能力（generalization），即从特殊到一般。</p>
<p> 西瓜的例子中，我们是想计算机通过学习西瓜的特征数据，训练出一个决策模型，来判断一个新的西瓜是否是好瓜。可以得知我们预测的是：西瓜是好是坏，即好瓜与差瓜两种，是离散值。同样地，也有通过历年的人口数据，来预测未来的人口数量，人口数量则是连续值。定义：	</p>
</li>
<li><p>预测值为离散值的问题为：分类（classification）。</p>
</li>
<li><p>预测值为连续值的问题为：回归（regression）。</p>
<p> 我们预测西瓜是否是好瓜的过程中，很明显对于训练集中的西瓜，我们事先已经知道了该瓜是否是好瓜，学习器通过学习这些好瓜或差瓜的特征，从而总结出规律，即训练集中的西瓜我们都做了标记，称为标记信息。但也有没有标记信息的情形，例如：我们想将一堆西瓜根据特征分成两个小堆，使得某一堆的西瓜尽可能相似，即都是好瓜或差瓜，对于这种问题，我们事先并不知道西瓜的好坏，样本没有标记信息。定义：	</p>
</li>
<li><p>训练数据有标记信息的学习任务为：监督学习（supervised learning），容易知道上面所描述的分类和回归都是监督学习的范畴。</p>
</li>
<li><p>训练数据没有标记信息的学习任务为：无监督学习（unsupervised learning），常见的有聚类和关联规则。</p>
</li>
</ul>
<p><strong>2  模型的评估与选择</strong></p>
<p><strong>2.1 误差与过拟合</strong></p>
<p>我们将学习器对样本的实际预测结果与样本的真实值之间的差异成为：误差（error）。定义：	</p>
<ul>
<li>在训练集上的误差称为训练误差（training error）或经验误差（empirical error）。</li>
<li>在测试集上的误差称为测试误差（test error）。</li>
<li>学习器在所有新样本上的误差称为泛化误差（generalization error）。</li>
</ul>
<p>显然，我们希望得到的是在新样本上表现得很好的学习器，即泛化误差小的学习器。因此，我们应该让学习器尽可能地从训练集中学出普适性的“一般特征”，这样在遇到新样本时才能做出正确的判别。然而，当学习器把训练集学得“太好”的时候，即把一些训练样本的自身特点当做了普遍特征；同时也有学习能力不足的情况，即训练集的基本特征都没有学习出来。我们定义：</p>
<ul>
<li>学习能力过强，以至于把训练样本所包含的不太一般的特性都学到了，称为：过拟合（overfitting）。</li>
<li>学习能太差，训练样本的一般性质尚未学好，称为：欠拟合（underfitting）。</li>
</ul>
<p>可以得知：在过拟合问题中，训练误差十分小，但测试误差教大；在欠拟合问题中，训练误差和测试误差都比较大。目前，欠拟合问题比较容易克服，例如增加迭代次数等，但过拟合问题还没有十分好的解决方案，过拟合是机器学习面临的关键障碍。</p>
<p><img src="https://i.loli.net/2018/10/17/5bc7181172996.png"></p>
<p><strong>2.2 评估方法</strong></p>
<p>在现实任务中，我们往往有多种算法可供选择，那么我们应该选择哪一个算法才是最适合的呢？如上所述，我们希望得到的是泛化误差小的学习器，理想的解决方案是对模型的泛化误差进行评估，然后选择泛化误差最小的那个学习器。但是，泛化误差指的是模型在所有新样本上的适用能力，我们无法直接获得泛化误差。</p>
<p>因此，通常我们采用一个“测试集”来测试学习器对新样本的判别能力，然后以“测试集”上的“测试误差”作为“泛化误差”的近似。显然：我们选取的测试集应尽可能与训练集互斥，下面用一个小故事来解释why：</p>
<p>假设老师出了10 道习题供同学们练习，考试时老师又用同样的这10道题作为试题，可能有的童鞋只会做这10 道题却能得高分，很明显：这个考试成绩并不能有效地反映出真实水平。回到我们的问题上来，我们希望得到泛化性能好的模型，好比希望同学们课程学得好并获得了对所学知识”举一反三”的能力；训练样本相当于给同学们练习的习题，测试过程则相当于考试。显然，若测试样本被用作训练了，则得到的将是过于”乐观”的估计结果。</p>
<p><strong>2.3 训练集与测试集的划分方法</strong></p>
<p>如上所述：我们希望用一个“测试集”的“测试误差”来作为“泛化误差”的近似，因此我们需要对初始数据集进行有效划分，划分出互斥的“训练集”和“测试集”。下面介绍几种常用的划分方法：</p>
<p><strong>2.3.1 留出法</strong>【【【【分层抽样具体应用在哪些方法上了？？】】】】</p>
<p>将数据集D划分为两个互斥的集合，一个作为训练集S，一个作为测试集T，满足D&#x3D;S∪T且S∩T&#x3D;∅，常见的划分为：大约2&#x2F;3-4&#x2F;5的样本用作训练，剩下的用作测试。需要注意的是：训练&#x2F;测试集的划分要尽可能保持数据分布的一致性，以避免由于分布的差异引入额外的偏差，常见的做法是采取分层抽样。同时，由于划分的随机性，单次的留出法结果往往不够稳定，一般要采用若干次随机划分，重复实验取平均值的做法。</p>
<p><strong>2.3.2 交叉验证法</strong></p>
<p>将数据集D划分为k个大小相同的互斥子集，满足D&#x3D;D1∪D2∪…∪Dk，Di∩Dj&#x3D;∅（i≠j），同样地尽可能保持数据分布的一致性，即采用分层抽样的方法获得这些子集。交叉验证法的思想是：每次用k-1个子集的并集作为训练集，余下的那个子集作为测试集，这样就有K种训练集&#x2F;测试集划分的情况，从而可进行k次训练和测试，最终返回k次测试结果的均值。交叉验证法也称“k折交叉验证”，k最常用的取值是10，下图给出了10折交叉验证的示意图。</p>
<p><img src="https://i.loli.net/2018/10/17/5bc718115d224.png"></p>
<p>与留出法类似，将数据集D划分为K个子集的过程具有随机性，因此K折交叉验证通常也要重复p次，称为p次k折交叉验证，常见的是10次10折交叉验证，即进行了100次训练&#x2F;测试。特殊地当划分的k个子集的每个子集中只有一个样本时，称为“留一法”，显然，留一法的评估结果比较准确，但对计算机的消耗也是巨大的。</p>
<p><strong>2.3.3 自助法</strong></p>
<p>我们希望评估的是用整个D训练出的模型。但在留出法和交叉验证法中，由于保留了一部分样本用于测试，因此实际评估的模型所使用的训练集比D小，这必然会引入一些因训练样本规模不同而导致的估计偏差。留一法受训练样本规模变化的影响较小，但计算复杂度又太高了。“自助法”正是解决了这样的问题。</p>
<p>自助法的基本思想是：给定包含m个样本的数据集D，每次随机从D 中挑选一个样本，将其拷贝放入D’，然后再将该样本放回初始数据集D 中，使得该样本在下次采样时仍有可能被采到。重复执行m 次，就可以得到了包含m个样本的数据集D’。可以得知在m次采样中，样本始终不被采到的概率取极限为：</p>
<p><img src="https://i.loli.net/2018/10/17/5bc71811246dd.png"></p>
<p>这样，通过自助采样，初始样本集D中大约有36.8%的样本没有出现在D’中，于是可以将D’作为训练集，D-D’作为测试集。自助法在数据集较小，难以有效划分训练集&#x2F;测试集时很有用，但由于自助法产生的数据集（随机抽样）改变了初始数据集的分布，因此引入了估计偏差。在初始数据集足够时，留出法和交叉验证法更加常用。</p>
<p><strong>2.4 调参</strong></p>
<p>大多数学习算法都有些参数(parameter) 需要设定，参数配置不同，学得模型的性能往往有显著差别，这就是通常所说的”参数调节”或简称”调参” (parameter tuning)。</p>
<p>学习算法的很多参数是在实数范围内取值，因此，对每种参数取值都训练出模型来是不可行的。常用的做法是：对每个参数选定一个范围和步长λ，这样使得学习的过程变得可行。例如：假定算法有3 个参数，每个参数仅考虑5 个候选值，这样对每一组训练&#x2F;测试集就有5<em>5</em>5&#x3D; 125 个模型需考察，由此可见：拿下一个参数（即经验值）对于算法人员来说是有多么的happy。</p>
<p>最后需要注意的是：当选定好模型和调参完成后，我们需要使用初始的数据集D重新训练模型，即让最初划分出来用于评估的测试集也被模型学习，增强模型的学习效果。用上面考试的例子来比喻：就像高中时大家每次考试完，要将考卷的题目消化掉（大多数题目都还是之前没有见过的吧？），这样即使考差了也能开心的玩耍了~。</p>
]]></content>
      <categories>
        <category>AI</category>
        <category>note</category>
      </categories>
      <tags>
        <tag>ML</tag>
      </tags>
  </entry>
  <entry>
    <title></title>
    <url>/2023/06/21/MachineLearning/Machine-learning-learning-notes-master/%E5%91%A8%E5%BF%97%E5%8D%8E%E3%80%8AMachine%20Learning%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(11)--%E8%81%9A%E7%B1%BB/</url>
    <content><![CDATA[<p>上篇主要介绍了一种机器学习的通用框架–集成学习方法，首先从准确性和差异性两个重要概念引出集成学习“<strong>好而不同</strong>”的四字真言，接着介绍了现阶段主流的三种集成学习方法：AdaBoost、Bagging及Random Forest，AdaBoost采用最小化指数损失函数迭代式更新样本分布权重和计算基学习器权重，Bagging通过自助采样引入样本扰动增加了基学习器之间的差异性，随机森林则进一步引入了属性扰动，最后简单概述了集成模型中的三类结合策略：平均法、投票法及学习法，其中Stacking是学习法的典型代表。本篇将讨论无监督学习中应用最为广泛的学习算法–聚类。</p>
<p>#<strong>10、聚类算法</strong></p>
<p>聚类是一种经典的<strong>无监督学习</strong>方法，<strong>无监督学习的目标是通过对无标记训练样本的学习，发掘和揭示数据集本身潜在的结构与规律</strong>，即不依赖于训练数据集的类标记信息。聚类则是试图将数据集的样本划分为若干个互不相交的类簇，从而每个簇对应一个潜在的类别。</p>
<p>聚类直观上来说是将相似的样本聚在一起，从而形成一个<strong>类簇（cluster）</strong>。那首先的问题是如何来<strong>度量相似性</strong>（similarity measure）呢？这便是<strong>距离度量</strong>，在生活中我们说差别小则相似，对应到多维样本，每个样本可以对应于高维空间中的一个数据点，若它们的距离相近，我们便可以称它们相似。那接着如何来评价聚类结果的好坏呢？这便是<strong>性能度量</strong>，性能度量为评价聚类结果的好坏提供了一系列有效性指标。</p>
<p>##<strong>10.1 距离度量</strong></p>
<p>谈及距离度量，最熟悉的莫过于欧式距离了，从年头一直用到年尾的距离计算公式：即对应属性之间相减的平方和再开根号。度量距离还有其它的很多经典方法，通常它们需要满足一些基本性质：</p>
<p><img src="https://i.loli.net/2018/10/18/5bc84ed4c0390.png" alt="1.png"></p>
<p>最常用的距离度量方法是**“闵可夫斯基距离”（Minkowski distance)**：</p>
<p><img src="https://i.loli.net/2018/10/18/5bc84ed49e31f.png" alt="2.png"></p>
<p>当p&#x3D;1时，闵可夫斯基距离即<strong>曼哈顿距离（Manhattan distance）</strong>：</p>
<p><img src="https://i.loli.net/2018/10/18/5bc84ed49c31f.png" alt="3.png"></p>
<p>当p&#x3D;2时，闵可夫斯基距离即<strong>欧氏距离（Euclidean distance）</strong>：</p>
<p><img src="https://i.loli.net/2018/10/18/5bc84ed497613.png" alt="4.png"></p>
<p>我们知道属性分为两种：<strong>连续属性</strong>和<strong>离散属性</strong>（有限个取值）。对于连续值的属性，一般都可以被学习器所用，有时会根据具体的情形作相应的预处理，例如：归一化等；而对于离散值的属性，需要作下面进一步的处理：</p>
<blockquote>
<p>若属性值之间<strong>存在序关系</strong>，则可以将其转化为连续值，例如：身高属性“高”“中等”“矮”，可转化为{1, 0.5, 0}。<br>若属性值之间<strong>不存在序关系</strong>，则通常将其转化为向量的形式，例如：性别属性“男”“女”，可转化为{（1,0），（0,1）}。</p>
</blockquote>
<p>在进行距离度量时，易知<strong>连续属性和存在序关系的离散属性都可以直接参与计算</strong>，因为它们都可以反映一种程度，我们称其为“<strong>有序属性</strong>”；而对于不存在序关系的离散属性，我们称其为：“<strong>无序属性</strong>”，显然无序属性再使用闵可夫斯基距离就行不通了。</p>
<p><strong>对于无序属性，我们一般采用VDM进行距离的计算</strong>，例如：对于离散属性的两个取值a和b，定义：</p>
<p><img src="https://i.loli.net/2018/10/18/5bc84ed4e9560.png" alt="5.png"></p>
<p>于是，在计算两个样本之间的距离时，我们可以将闵可夫斯基距离和VDM混合在一起进行计算：</p>
<p><img src="https://i.loli.net/2018/10/18/5bc84ed507bc7.png" alt="6.png"></p>
<p>若我们定义的距离计算方法是用来度量相似性，例如下面将要讨论的聚类问题，即距离越小，相似性越大，反之距离越大，相似性越小。这时距离的度量方法并不一定需要满足前面所说的四个基本性质，这样的方法称为：<strong>非度量距离（non-metric distance）</strong>。</p>
<p>##<strong>10.2 性能度量</strong></p>
<p>由于聚类算法不依赖于样本的真实类标，就不能像监督学习的分类那般，通过计算分对分错（即精确度或错误率）来评价学习器的好坏或作为学习过程中的优化目标。一般聚类有两类性能度量指标：<strong>外部指标</strong>和<strong>内部指标</strong>。</p>
<p>###<strong>10.2.1 外部指标</strong></p>
<p>即将聚类结果与某个参考模型的结果进行比较，<strong>以参考模型的输出作为标准，来评价聚类好坏</strong>。假设聚类给出的结果为λ，参考模型给出的结果是λ*，则我们将样本进行两两配对，定义：</p>
<p><img src="https://i.loli.net/2018/10/18/5bc84ed59160e.png" alt="7.png"></p>
<p>显然a和b代表着聚类结果好坏的正能量，b和c则表示参考结果和聚类结果相矛盾，基于这四个值可以导出以下常用的外部评价指标：</p>
<p><img src="https://i.loli.net/2018/10/18/5bc84ed587438.png" alt="8.png"></p>
<p>###<strong>10.2.2 内部指标</strong></p>
<p>内部指标即不依赖任何外部模型，直接对聚类的结果进行评估，聚类的目的是想将那些相似的样本尽可能聚在一起，不相似的样本尽可能分开，直观来说：<strong>簇内高内聚紧紧抱团，簇间低耦合老死不相往来</strong>。定义：</p>
<p><img src="https://i.loli.net/2018/10/18/5bc84ed581852.png" alt="9.png"></p>
<p>基于上面的四个距离，可以导出下面这些常用的内部评价指标：</p>
<p><img src="https://i.loli.net/2018/10/18/5bc84ed582854.png" alt="10.png"></p>
<p>##<strong>10.3 原型聚类</strong></p>
<p>原型聚类即“<strong>基于原型的聚类</strong>”（prototype-based clustering），原型表示模板的意思，就是通过参考一个模板向量或模板分布的方式来完成聚类的过程，常见的K-Means便是基于簇中心来实现聚类，混合高斯聚类则是基于簇分布来实现聚类。</p>
<p>###<strong>10.3.1 K-Means</strong></p>
<p>K-Means的思想十分简单，<strong>首先随机指定类中心，根据样本与类中心的远近划分类簇，接着重新计算类中心，迭代直至收敛</strong>。但是其中迭代的过程并不是主观地想象得出，事实上，若将样本的类别看做为“隐变量”（latent variable），类中心看作样本的分布参数，这一过程正是通过<strong>EM算法</strong>的两步走策略而计算出，其根本的目的是为了最小化平方误差函数E：</p>
<p><img src="https://i.loli.net/2018/10/18/5bc84fb82b5d3.png" alt="11.png"></p>
<p>K-Means的算法流程如下所示：</p>
<p><img src="https://i.loli.net/2018/10/18/5bc84fb9c0817.png" alt="12.png"></p>
<p>###<strong>10.3.2 学习向量量化（LVQ）</strong></p>
<p>LVQ也是基于原型的聚类算法，与K-Means不同的是，<strong>LVQ使用样本真实类标记辅助聚类</strong>，首先LVQ根据样本的类标记，从各类中分别随机选出一个样本作为该类簇的原型，从而组成了一个<strong>原型特征向量组</strong>，接着从样本集中随机挑选一个样本，计算其与原型向量组中每个向量的距离，并选取距离最小的原型向量所在的类簇作为它的划分结果，再与真实类标比较。</p>
<blockquote>
<p><strong>若划分结果正确，则对应原型向量向这个样本靠近一些</strong><br><strong>若划分结果不正确，则对应原型向量向这个样本远离一些</strong></p>
</blockquote>
<p>LVQ算法的流程如下所示：</p>
<p><img src="https://i.loli.net/2018/10/18/5bc84fb9d59f2.png" alt="13.png"></p>
<p>###<strong>10.3.3 高斯混合聚类</strong></p>
<p>现在可以看出K-Means与LVQ都试图以类中心作为原型指导聚类，高斯混合聚类则采用高斯分布来描述原型。现假设<strong>每个类簇中的样本都服从一个多维高斯分布，那么空间中的样本可以看作由k个多维高斯分布混合而成</strong>。</p>
<p>对于多维高斯分布，其概率密度函数如下所示：</p>
<p><img src="https://i.loli.net/2018/10/18/5bc84fb870d98.png" alt="14.png"></p>
<p>其中u表示均值向量，∑表示协方差矩阵，可以看出一个多维高斯分布完全由这两个参数所确定。接着定义高斯混合分布为：</p>
<p><img src="https://i.loli.net/2018/10/18/5bc84fb876794.png" alt="15.png"></p>
<p>α称为混合系数，这样空间中样本的采集过程则可以抽象为：<strong>（1）先选择一个类簇（高斯分布），（2）再根据对应高斯分布的密度函数进行采样</strong>，这时候贝叶斯公式又能大展身手了：</p>
<p><img src="https://i.loli.net/2018/10/18/5bc84fb9191d9.png" alt="16.png"></p>
<p>此时只需要选择PM最大时的类簇并将该样本划分到其中，看到这里很容易发现：这和那个传说中的贝叶斯分类不是神似吗，都是通过贝叶斯公式展开，然后计算类先验概率和类条件概率。但遗憾的是：<strong>这里没有真实类标信息，对于类条件概率，并不能像贝叶斯分类那样通过最大似然法美好地计算出来</strong>，因为这里的样本可能属于所有的类簇，这里的似然函数变为：</p>
<p><img src="https://i.loli.net/2018/10/18/5bc84fb871d4a.png" alt="17.png"></p>
<p>可以看出：简单的最大似然法根本无法求出所有的参数，这样PM也就没法计算。<strong>这里就要召唤出之前的EM大法，首先对高斯分布的参数及混合系数进行随机初始化，计算出各个PM（即γji，第i个样本属于j类），再最大化似然函数（即LL（D）分别对α、u和∑求偏导 ），对参数进行迭代更新</strong>。</p>
<p><img src="https://i.loli.net/2018/10/18/5bc84fb8a6f32.png" alt="18.png"></p>
<p>高斯混合聚类的算法流程如下图所示：</p>
<p><img src="https://i.loli.net/2018/10/18/5bc84fb9c4fa4.png" alt="19.png"></p>
<p>##<strong>10.4 密度聚类</strong></p>
<p>密度聚类则是基于密度的聚类，它从样本分布的角度来考察样本之间的可连接性，并基于可连接性（密度可达）不断拓展疆域（类簇）。其中最著名的便是<strong>DBSCAN</strong>算法，首先定义以下概念：</p>
<p><img src="https://i.loli.net/2018/10/18/5bc84fb9bd69c.png" alt="20.png"></p>
<p><img src="https://i.loli.net/2018/10/18/5bc8509f8d619.png" alt="21.png"></p>
<p>简单来理解DBSCAN便是：<strong>找出一个核心对象所有密度可达的样本集合形成簇</strong>。首先从数据集中任选一个核心对象A，找出所有A密度可达的样本集合，将这些样本形成一个密度相连的类簇，直到所有的核心对象都遍历完。DBSCAN算法的流程如下图所示：</p>
<p><img src="https://i.loli.net/2018/10/18/5bc8509feb587.png" alt="22.png"></p>
<p>##<strong>10.5 层次聚类</strong></p>
<p>层次聚类是一种基于树形结构的聚类方法，常用的是<strong>自底向上</strong>的结合策略（<strong>AGNES算法</strong>）。假设有N个待聚类的样本，其基本步骤是：</p>
<blockquote>
<p>1.初始化–&gt;把每个样本归为一类，计算每两个类之间的距离，也就是样本与样本之间的相似度；<br>2.寻找各个类之间最近的两个类，把他们归为一类（这样类的总数就少了一个）；<br>3.重新计算新生成的这个<strong>类与各个旧类之间的相似度</strong>；<br>4.重复2和3直到所有样本点都归为一类，结束。</p>
</blockquote>
<p>可以看出其中最关键的一步就是<strong>计算两个类簇的相似度</strong>，这里有多种度量方法：</p>
<pre><code>* 单链接（single-linkage）:取类间最小距离。
</code></pre>
<p><img src="https://i.loli.net/2018/10/18/5bc8509ebb022.png" alt="23.png"></p>
<pre><code>* 全链接（complete-linkage）:取类间最大距离
</code></pre>
<p><img src="https://i.loli.net/2018/10/18/5bc8509eb2b30.png" alt="24.png"></p>
<pre><code>* 均链接（average-linkage）:取类间两两的平均距离
</code></pre>
<p><img src="https://i.loli.net/2018/10/18/5bc8509f089a7.png" alt="25.png"></p>
<p>很容易看出：<strong>单链接的包容性极强，稍微有点暧昧就当做是自己人了，全链接则是坚持到底，只要存在缺点就坚决不合并，均连接则是从全局出发顾全大局</strong>。层次聚类法的算法流程如下所示：</p>
<p><img src="https://i.loli.net/2018/10/18/5bc8509f9d4a0.png" alt="26.png"></p>
<blockquote>
<p>在此聚类算法就介绍完毕，分类&#x2F;聚类都是机器学习中最常见的任务，我实验室的大Boss也是靠着聚类起家，从此走上人生事业钱途…之巅峰，在书最后的阅读材料还看见Boss的名字，所以这章也是必读不可了…</p>
</blockquote>
]]></content>
  </entry>
  <entry>
    <title></title>
    <url>/2023/06/21/MachineLearning/Machine-learning-learning-notes-master/%E5%91%A8%E5%BF%97%E5%8D%8E%E3%80%8AMachine%20Learning%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(12)--%E9%99%8D%E7%BB%B4%E4%B8%8E%E5%BA%A6%E9%87%8F%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<p>上篇主要介绍了几种常用的聚类算法，首先从距离度量与性能评估出发，列举了常见的距离计算公式与聚类评价指标，接着分别讨论了K-Means、LVQ、高斯混合聚类、密度聚类以及层次聚类算法。K-Means与LVQ都试图以类簇中心作为原型指导聚类，其中K-Means通过EM算法不断迭代直至收敛，LVQ使用真实类标辅助聚类；高斯混合聚类采用高斯分布来描述类簇原型；密度聚类则是将一个核心对象所有密度可达的样本形成类簇，直到所有核心对象都遍历完；最后层次聚类是一种自底向上的树形聚类方法，不断合并最相近的两个小类簇。本篇将讨论机器学习常用的方法–降维与度量学习。</p>
<p>#<strong>11、降维与度量学习</strong></p>
<p>样本的特征数称为<strong>维数</strong>（dimensionality），当维数非常大时，也就是现在所说的“<strong>维数灾难</strong>”，具体表现在：在高维情形下，<strong>数据样本将变得十分稀疏</strong>，因为此时要满足训练样本为“<strong>密采样</strong>”的总体样本数目是一个触不可及的天文数字，谓可远观而不可亵玩焉…<strong>训练样本的稀疏使得其代表总体分布的能力大大减弱，从而消减了学习器的泛化能力</strong>；同时当维数很高时，<strong>计算距离也变得十分复杂</strong>，甚至连计算内积都不再容易，这也是为什么支持向量机（SVM）使用核函数<strong>“低维计算，高维表现”</strong>的原因。</p>
<p>缓解维数灾难的一个重要途径就是<strong>降维，即通过某种数学变换将原始高维空间转变到一个低维的子空间</strong>。在这个子空间中，样本的密度将大幅提高，同时距离计算也变得容易。这时也许会有疑问，这样降维之后不是会丢失原始数据的一部分信息吗？这是因为在很多实际的问题中，虽然训练数据是高维的，但是与学习任务相关也许仅仅是其中的一个低维子空间，也称为一个<strong>低维嵌入</strong>，例如：数据属性中存在噪声属性、相似属性或冗余属性等，<strong>对高维数据进行降维能在一定程度上达到提炼低维优质属性或降噪的效果</strong>。</p>
<p>##<strong>11.1 K近邻学习</strong></p>
<p>k近邻算法简称<strong>kNN（k-Nearest Neighbor）</strong>，是一种经典的监督学习方法，同时也实力担当入选数据挖掘十大算法。其工作机制十分简单粗暴：给定某个测试样本，kNN基于某种<strong>距离度量</strong>在训练集中找出与其距离最近的k个带有真实标记的训练样本，然后给基于这k个邻居的真实标记来进行预测，类似于前面集成学习中所讲到的基学习器结合策略：分类任务采用投票法，回归任务则采用平均法。接下来本篇主要就kNN分类进行讨论。</p>
<p><img src="https://i.loli.net/2018/10/18/5bc851a43873a.png" alt="1.png"></p>
<p>从上图【来自Wiki】中我们可以看到，图中有两种类型的样本，一类是蓝色正方形，另一类是红色三角形。而那个绿色圆形是我们待分类的样本。基于kNN算法的思路，我们很容易得到以下结论：</p>
<blockquote>
<p>如果K&#x3D;3，那么离绿色点最近的有2个红色三角形和1个蓝色的正方形，这3个点投票，于是绿色的这个待分类点属于红色的三角形。<br>如果K&#x3D;5，那么离绿色点最近的有2个红色三角形和3个蓝色的正方形，这5个点投票，于是绿色的这个待分类点属于蓝色的正方形。</p>
</blockquote>
<p>可以发现：<strong>kNN虽然是一种监督学习方法，但是它却没有显式的训练过程</strong>，而是当有新样本需要预测时，才来计算出最近的k个邻居，因此<strong>kNN是一种典型的懒惰学习方法</strong>，再来回想一下朴素贝叶斯的流程，训练的过程就是参数估计，因此朴素贝叶斯也可以懒惰式学习，此类技术在<strong>训练阶段开销为零</strong>，待收到测试样本后再进行计算。相应地我们称那些一有训练数据立马开工的算法为“<strong>急切学习</strong>”，可见前面我们学习的大部分算法都归属于急切学习。</p>
<p>很容易看出：<strong>kNN算法的核心在于k值的选取以及距离的度量</strong>。k值选取太小，模型很容易受到噪声数据的干扰，例如：极端地取k&#x3D;1，若待分类样本正好与一个噪声数据距离最近，就导致了分类错误；若k值太大， 则在更大的邻域内进行投票，此时模型的预测能力大大减弱，例如：极端取k&#x3D;训练样本数，就相当于模型根本没有学习，所有测试样本的预测结果都是一样的。<strong>一般地我们都通过交叉验证法来选取一个适当的k值</strong>。</p>
<p><img src="https://i.loli.net/2018/10/18/5bc851a47db9a.png" alt="2.png"></p>
<p>对于距离度量，<strong>不同的度量方法得到的k个近邻不尽相同，从而对最终的投票结果产生了影响</strong>，因此选择一个合适的距离度量方法也十分重要。在上一篇聚类算法中，在度量样本相似性时介绍了常用的几种距离计算方法，包括<strong>闵可夫斯基距离，曼哈顿距离，VDM</strong>等。在实际应用中，<strong>kNN的距离度量函数一般根据样本的特性来选择合适的距离度量，同时应对数据进行去量纲&#x2F;归一化处理来消除大量纲属性的强权政治影响</strong>。</p>
<p>##<strong>11.2 MDS算法</strong></p>
<p>不管是使用核函数升维还是对数据降维，我们都希望<strong>原始空间样本点之间的距离在新空间中基本保持不变</strong>，这样才不会使得原始空间样本之间的关系及总体分布发生较大的改变。<strong>“多维缩放”（MDS）</strong>正是基于这样的思想，<strong>MDS要求原始空间样本之间的距离在降维后的低维空间中得以保持</strong>。</p>
<p>假定m个样本在原始空间中任意两两样本之间的距离矩阵为D∈R(m*m)，我们的目标便是获得样本在低维空间中的表示Z∈R(d’*m , d’&lt; d)，且任意两个样本在低维空间中的欧式距离等于原始空间中的距离，即||zi-zj||&#x3D;Dist(ij)。因此接下来我们要做的就是根据已有的距离矩阵D来求解出降维后的坐标矩阵Z。</p>
<p><img src="https://i.loli.net/2018/10/18/5bc851a4b664e.png" alt="3.png"></p>
<p>令降维后的样本坐标矩阵Z被中心化，<strong>中心化是指将每个样本向量减去整个样本集的均值向量，故所有样本向量求和得到一个零向量</strong>。这样易知：矩阵B的每一列以及每一列求和均为0，因为提取公因子后都有一项为所有样本向量的和向量。</p>
<p><img src="https://i.loli.net/2018/10/18/5bc851a4a4ee2.png" alt="4.png"></p>
<p>根据上面矩阵B的特征，我们很容易得到等式（2）、（3）以及（4）：</p>
<p><img src="https://i.loli.net/2018/10/18/5bc851a4a777b.png" alt="5.png"></p>
<p>这时根据(1)–(4)式我们便可以计算出bij，即*<em>bij&#x3D;(1)-(2)</em>(1&#x2F;m)-(3)<em>(1&#x2F;m)+(4)</em>(1&#x2F;(m^2))**，再逐一地计算每个b(ij)，就得到了降维后低维空间中的内积矩阵B(B&#x3D;Z’*Z)，只需对B进行特征值分解便可以得到Z。MDS的算法流程如下图所示：</p>
<p><img src="https://i.loli.net/2018/10/18/5bc851a5340dd.png" alt="6.png"></p>
<p>##<strong>11.3 主成分分析（PCA）</strong></p>
<p>不同于MDS采用距离保持的方法，<strong>主成分分析（PCA）直接通过一个线性变换，将原始空间中的样本投影到新的低维空间中</strong>。简单来理解这一过程便是：<strong>PCA采用一组新的基来表示样本点，其中每一个基向量都是原来基向量的线性组合，通过使用尽可能少的新基向量来表出样本，从而达到降维的目的。</strong></p>
<p>假设使用d’个新基向量来表示原来样本，实质上是将样本投影到一个由d’个基向量确定的一个<strong>超平面</strong>上（<strong>即舍弃了一些维度</strong>），要用一个超平面对空间中所有高维样本进行恰当的表达，最理想的情形是：<strong>若这些样本点都能在超平面上表出且这些表出在超平面上都能够很好地分散开来</strong>。但是一般使用较原空间低一些维度的超平面来做到这两点十分不容易，因此我们退一步海阔天空，要求这个超平面应具有如下两个性质：</p>
<blockquote>
<p><strong>最近重构性</strong>：样本点到超平面的距离足够近，即尽可能在超平面附近；<br><strong>最大可分性</strong>：样本点在超平面上的投影尽可能地分散开来，即投影后的坐标具有区分性。</p>
</blockquote>
<p>这里十分神奇的是：<strong>最近重构性与最大可分性虽然从不同的出发点来定义优化问题中的目标函数，但最终这两种特性得到了完全相同的优化问题</strong>：</p>
<p><img src="https://i.loli.net/2018/10/18/5bc851a5213c1.png" alt="7.png"></p>
<p>接着使用拉格朗日乘子法求解上面的优化问题，得到：</p>
<p><img src="https://i.loli.net/2018/10/18/5bc851a4a102a.png" alt="8.png"></p>
<p>因此只需对协方差矩阵进行特征值分解即可求解出W，PCA算法的整个流程如下图所示：</p>
<p><img src="https://i.loli.net/2018/10/18/5bc851a540eb3.png" alt="9.png"></p>
<p>另一篇博客给出更通俗更详细的理解：<a href="http://blog.csdn.net/u011826404/article/details/57472730">主成分分析解析（基于最大方差理论）</a></p>
<p>##<strong>11.4 核化线性降维</strong></p>
<p>说起机器学习你中有我&#x2F;我中有你&#x2F;水乳相融…在这里能够得到很好的体现。正如SVM在处理非线性可分时，通过引入核函数将样本投影到高维特征空间，接着在高维空间再对样本点使用超平面划分。这里也是相同的问题：若我们的样本数据点本身就不是线性分布，那还如何使用一个超平面去近似表出呢？因此也就引入了核函数，<strong>即先将样本映射到高维空间，再在高维空间中使用线性降维的方法</strong>。下面主要介绍<strong>核化主成分分析（KPCA）</strong>的思想。</p>
<p>若核函数的形式已知，即我们知道如何将低维的坐标变换为高维坐标，这时我们只需先将数据映射到高维特征空间，再在高维空间中运用PCA即可。但是一般情况下，我们并不知道核函数具体的映射规则，例如：Sigmoid、高斯核等，我们只知道如何计算高维空间中的样本内积，这时就引出了KPCA的一个重要创新之处：<strong>即空间中的任一向量，都可以由该空间中的所有样本线性表示</strong>。证明过程也十分简单：</p>
<p><img src="https://i.loli.net/2018/10/18/5bc851a51bd2a.png" alt="10.png"></p>
<p>这样我们便可以将高维特征空间中的投影向量wi使用所有高维样本点线性表出，接着代入PCA的求解问题，得到：</p>
<p><img src="https://i.loli.net/2018/10/18/5bc851b74b083.png" alt="11.png"></p>
<p>化简到最后一步，发现结果十分的美妙，只需对核矩阵K进行特征分解，便可以得出投影向量wi对应的系数向量α，因此选取特征值前d’大对应的特征向量便是d’个系数向量。这时对于需要降维的样本点，只需按照以下步骤便可以求出其降维后的坐标。可以看出：KPCA在计算降维后的坐标表示时，需要与所有样本点计算核函数值并求和，因此该算法的计算开销十分大。</p>
<p><img src="https://i.loli.net/2018/10/18/5bc851b735754.png" alt="12.png"></p>
<p>##<strong>11.5 流形学习</strong></p>
<p><strong>流形学习（manifold learning）是一种借助拓扑流形概念的降维方法</strong>，<strong>流形是指在局部与欧式空间同胚的空间</strong>，即在局部与欧式空间具有相同的性质，能用欧氏距离计算样本之间的距离。这样即使高维空间的分布十分复杂，但是在局部上依然满足欧式空间的性质，基于流形学习的降维正是这种<strong>“邻域保持”</strong>的思想。其中<strong>等度量映射（Isomap）试图在降维前后保持邻域内样本之间的距离，而局部线性嵌入（LLE）则是保持邻域内样本之间的线性关系</strong>，下面将分别对这两种著名的流行学习方法进行介绍。</p>
<p>###<strong>11.5.1 等度量映射（Isomap）</strong></p>
<p>等度量映射的基本出发点是：高维空间中的直线距离具有误导性，因为有时高维空间中的直线距离在低维空间中是不可达的。<strong>因此利用流形在局部上与欧式空间同胚的性质，可以使用近邻距离来逼近测地线距离</strong>，即对于一个样本点，它与近邻内的样本点之间是可达的，且距离使用欧式距离计算，这样整个样本空间就形成了一张近邻图，高维空间中两个样本之间的距离就转为最短路径问题。可采用著名的<strong>Dijkstra算法</strong>或<strong>Floyd算法</strong>计算最短距离，得到高维空间中任意两点之间的距离后便可以使用MDS算法来其计算低维空间中的坐标。</p>
<p><img src="https://i.loli.net/2018/10/18/5bc851b731a1e.png" alt="13.png"></p>
<p>从MDS算法的描述中我们可以知道：MDS先求出了低维空间的内积矩阵B，接着使用特征值分解计算出了样本在低维空间中的坐标，但是并没有给出通用的投影向量w，因此对于需要降维的新样本无从下手，书中给出的权宜之计是利用已知高&#x2F;低维坐标的样本作为训练集学习出一个“投影器”，便可以用高维坐标预测出低维坐标。Isomap算法流程如下图：</p>
<p><img src="https://i.loli.net/2018/10/18/5bc851b6c7e37.png" alt="14.png"></p>
<p>对于近邻图的构建，常用的有两种方法：<strong>一种是指定近邻点个数</strong>，像kNN一样选取k个最近的邻居；<strong>另一种是指定邻域半径</strong>，距离小于该阈值的被认为是它的近邻点。但两种方法均会出现下面的问题：</p>
<blockquote>
<p>若<strong>邻域范围指定过大，则会造成“短路问题”</strong>，即本身距离很远却成了近邻，将距离近的那些样本扼杀在摇篮。<br>若<strong>邻域范围指定过小，则会造成“断路问题”</strong>，即有些样本点无法可达了，整个世界村被划分为互不可达的小部落。</p>
</blockquote>
<p>###<strong>11.5.2 局部线性嵌入(LLE)</strong></p>
<p>不同于Isomap算法去保持邻域距离，LLE算法试图去保持邻域内的线性关系，假定样本xi的坐标可以通过它的邻域样本线性表出：</p>
<p><img src="https://i.loli.net/2018/10/18/5bc851b64236f.png" alt="15.png"></p>
<p><img src="https://i.loli.net/2018/10/18/5bc851b6a7b9a.png" alt="16.png"></p>
<p>LLE算法分为两步走，<strong>首先第一步根据近邻关系计算出所有样本的邻域重构系数w</strong>：</p>
<p><img src="https://i.loli.net/2018/10/18/5bc851b662815.png" alt="17.png"></p>
<p><strong>接着根据邻域重构系数不变，去求解低维坐标</strong>：</p>
<p><img src="https://i.loli.net/2018/10/18/5bc851b648b98.png" alt="18.png"></p>
<p>这样利用矩阵M，优化问题可以重写为：</p>
<p><img src="https://i.loli.net/2018/10/18/5bc851b6948d7.png" alt="19.png"></p>
<p>M特征值分解后最小的d’个特征值对应的特征向量组成Z，LLE算法的具体流程如下图所示：</p>
<p><img src="https://i.loli.net/2018/10/18/5bc851b757d8c.png" alt="20.png"></p>
<p>##<strong>11.6 度量学习</strong></p>
<p>本篇一开始就提到维数灾难，即在高维空间进行机器学习任务遇到样本稀疏、距离难计算等诸多的问题，因此前面讨论的降维方法都试图将原空间投影到一个合适的低维空间中，接着在低维空间进行学习任务从而产生较好的性能。事实上，不管高维空间还是低维空间都潜在对应着一个距离度量，那可不可以直接学习出一个距离度量来等效降维呢？例如：<strong>咋们就按照降维后的方式来进行距离的计算，这便是度量学习的初衷</strong>。</p>
<p><strong>首先要学习出距离度量必须先定义一个合适的距离度量形式</strong>。对两个样本xi与xj，它们之间的平方欧式距离为：</p>
<p><img src="https://i.loli.net/2018/10/18/5bc851d3ca3d5.png" alt="21.png"></p>
<p>若各个属性重要程度不一样即都有一个权重，则得到加权的平方欧式距离：</p>
<p><img src="https://i.loli.net/2018/10/18/5bc851d3d82c5.png" alt="22.png"></p>
<p>此时各个属性之间都是相互独立无关的，但现实中往往会存在属性之间有关联的情形，例如：身高和体重，一般人越高，体重也会重一些，他们之间存在较大的相关性。这样计算距离就不能分属性单独计算，于是就引入经典的<strong>马氏距离(Mahalanobis distance)</strong>:</p>
<p><img src="https://i.loli.net/2018/10/18/5bc851d3dc303.png" alt="23.png"></p>
<p><strong>标准的马氏距离中M是协方差矩阵的逆，马氏距离是一种考虑属性之间相关性且尺度无关（即无须去量纲）的距离度量</strong>。</p>
<p><img src="https://i.loli.net/2018/10/18/5bc851d3e17c0.png" alt="24.png"></p>
<p><strong>矩阵M也称为“度量矩阵”，为保证距离度量的非负性与对称性，M必须为(半)正定对称矩阵</strong>，这样就为度量学习定义好了距离度量的形式，换句话说：<strong>度量学习便是对度量矩阵进行学习</strong>。现在来回想一下前面我们接触的机器学习不难发现：<strong>机器学习算法几乎都是在优化目标函数，从而求解目标函数中的参数</strong>。同样对于度量学习，也需要设置一个优化目标，书中简要介绍了错误率和相似性两种优化目标，此处限于篇幅不进行展开。</p>
<p>在此，降维和度量学习就介绍完毕。<strong>降维是将原高维空间嵌入到一个合适的低维子空间中，接着在低维空间中进行学习任务；度量学习则是试图去学习出一个距离度量来等效降维的效果</strong>，两者都是为了解决维数灾难带来的诸多问题。也许大家最后心存疑惑，那kNN呢，为什么一开头就说了kNN算法，但是好像和后面没有半毛钱关系？正是因为在降维算法中，低维子空间的维数d’通常都由人为指定，因此我们需要使用一些低开销的学习器来选取合适的d’，<strong>kNN这家伙懒到家了根本无心学习，在训练阶段开销为零，测试阶段也只是遍历计算了距离，因此拿kNN来进行交叉验证就十分有优势了~同时降维后样本密度增大同时距离计算变易，更为kNN来展示它独特的十八般手艺提供了用武之地。</strong></p>
]]></content>
  </entry>
  <entry>
    <title></title>
    <url>/2023/06/21/MachineLearning/Machine-learning-learning-notes-master/%E5%91%A8%E5%BF%97%E5%8D%8E%E3%80%8AMachine%20Learning%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(10)--%E9%9B%86%E6%88%90%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<p>上篇主要介绍了鼎鼎大名的EM算法，从算法思想到数学公式推导（边际似然引入隐变量，Jensen不等式简化求导），EM算法实际上可以理解为一种坐标下降法，首先固定一个变量，接着求另外变量的最优解，通过其优美的“两步走”策略能较好地估计隐变量的值。本篇将继续讨论下一类经典算法–集成学习。</p>
<p>#<strong>9、集成学习</strong></p>
<p>顾名思义，集成学习（ensemble learning）指的是将多个学习器进行有效地结合，组建一个“学习器委员会”，其中每个学习器担任委员会成员并行使投票表决权，使得委员会最后的决定更能够四方造福普度众生<del>…</del>，即其泛化性能要能优于其中任何一个学习器。</p>
<p>##<strong>9.1 个体与集成</strong></p>
<p>集成学习的基本结构为：先产生一组个体学习器，再使用某种策略将它们结合在一起。集成模型如下图所示：</p>
<p><img src="https://i.loli.net/2018/10/18/5bc84d0c15683.png" alt="1.png"></p>
<p>在上图的集成模型中，若个体学习器都属于同一类别，例如都是决策树或都是神经网络，则称该集成为同质的（homogeneous）;若个体学习器包含多种类型的学习算法，例如既有决策树又有神经网络，则称该集成为异质的（heterogenous）。</p>
<blockquote>
<p><strong>同质集成</strong>：个体学习器称为“基学习器”（base learner），对应的学习算法为“基学习算法”（base learning algorithm）。<br><strong>异质集成</strong>：个体学习器称为“组件学习器”（component learner）或直称为“个体学习器”。</p>
</blockquote>
<p>上面我们已经提到要让集成起来的泛化性能比单个学习器都要好，虽说团结力量大但也有木桶短板理论调皮捣蛋，那如何做到呢？这就引出了集成学习的两个重要概念：<strong>准确性</strong>和<strong>多样性</strong>（diversity）。准确性指的是个体学习器不能太差，要有一定的准确度；多样性则是个体学习器之间的输出要具有差异性。通过下面的这三个例子可以很容易看出这一点，准确度较高，差异度也较高，可以较好地提升集成性能。</p>
<p><img src="https://i.loli.net/2018/10/18/5bc84d0d23e13.png" alt="2.png"></p>
<p>现在考虑二分类的简单情形，假设基分类器之间相互独立（能提供较高的差异度），且错误率相等为 ε，则可以将集成器的预测看做一个伯努利实验，易知当所有基分类器中不足一半预测正确的情况下，集成器预测错误，所以集成器的错误率可以计算为：</p>
<p><img src="https://i.loli.net/2018/10/18/5bc84d0cce0bb.png" alt="3.png"></p>
<p>此时，集成器错误率随着基分类器的个数的增加呈指数下降，但前提是基分类器之间相互独立，在实际情形中显然是不可能的，假设训练有A和B两个分类器，对于某个测试样本，显然满足：P（A&#x3D;1 | B&#x3D;1）&gt; P（A&#x3D;1），因为A和B为了解决相同的问题而训练，因此在预测新样本时存在着很大的联系。因此，<strong>个体学习器的“准确性”和“差异性”本身就是一对矛盾的变量</strong>，准确性高意味着牺牲多样性，所以产生“<strong>好而不同</strong>”的个体学习器正是集成学习研究的核心。现阶段有三种主流的集成学习方法：Boosting、Bagging以及随机森林（Random Forest），接下来将进行逐一介绍。</p>
<p>##<strong>9.2 Boosting</strong></p>
<p>Boosting是一种串行的工作机制，即个体学习器的训练存在依赖关系，必须一步一步序列化进行。其基本思想是：增加前一个基学习器在训练训练过程中预测错误样本的权重，使得后续基学习器更加关注这些打标错误的训练样本，尽可能纠正这些错误，一直向下串行直至产生需要的T个基学习器，Boosting最终对这T个学习器进行加权结合，产生学习器委员会。</p>
<p>Boosting族算法最著名、使用最为广泛的就是AdaBoost，因此下面主要是对AdaBoost算法进行介绍。AdaBoost使用的是<strong>指数损失函数</strong>，因此AdaBoost的权值与样本分布的更新都是围绕着最小化指数损失函数进行的。看到这里回想一下之前的机器学习算法，<strong>不难发现机器学习的大部分带参模型只是改变了最优化目标中的损失函数</strong>：如果是Square loss，那就是最小二乘了；如果是Hinge Loss，那就是著名的SVM了；如果是log-Loss，那就是Logistic Regression了。</p>
<p>定义基学习器的集成为加权结合，则有：</p>
<p><img src="https://i.loli.net/2018/10/18/5bc84d0ca2ca5.png" alt="4.png"></p>
<p>AdaBoost算法的指数损失函数定义为：</p>
<p><img src="https://i.loli.net/2018/10/18/5bc84d0d10461.png" alt="5.png"></p>
<p>具体说来，整个Adaboost 迭代算法分为3步：</p>
<ul>
<li>初始化训练数据的权值分布。如果有N个样本，则每一个训练样本最开始时都被赋予相同的权值：1&#x2F;N。</li>
<li>训练弱分类器。具体训练过程中，如果某个样本点已经被准确地分类，那么在构造下一个训练集中，它的权值就被降低；相反，如果某个样本点没有被准确地分类，那么它的权值就得到提高。然后，权值更新过的样本集被用于训练下一个分类器，整个训练过程如此迭代地进行下去。</li>
<li>将各个训练得到的弱分类器组合成强分类器。各个弱分类器的训练过程结束后，加大分类误差率小的弱分类器的权重，使其在最终的分类函数中起着较大的决定作用，而降低分类误差率大的弱分类器的权重，使其在最终的分类函数中起着较小的决定作用。</li>
</ul>
<p>整个AdaBoost的算法流程如下所示：</p>
<p><img src="https://i.loli.net/2018/10/18/5bc84d0d7c057.png" alt="6.png"></p>
<p>可以看出：<strong>AdaBoost的核心步骤就是计算基学习器权重和样本权重分布</strong>，那为何是上述的计算公式呢？这就涉及到了我们之前为什么说大部分带参机器学习算法只是改变了损失函数，就是因为<strong>大部分模型的参数都是通过最优化损失函数（可能还加个规则项）而计算（梯度下降，坐标下降等）得到</strong>，这里正是通过最优化指数损失函数从而得到这两个参数的计算公式，具体的推导过程此处不进行展开。</p>
<p>Boosting算法要求基学习器能对特定分布的数据进行学习，即每次都更新样本分布权重，这里书上提到了两种方法：“重赋权法”（re-weighting）和“重采样法”（re-sampling），书上的解释有些晦涩，这里进行展开一下：</p>
<blockquote>
<p><strong>重赋权法</strong> : 对每个样本附加一个权重，这时涉及到样本属性与标签的计算，都需要乘上一个权值。<br><strong>重采样法</strong> : 对于一些无法接受带权样本的及学习算法，适合用“重采样法”进行处理。方法大致过程是，根据各个样本的权重，对训练数据进行重采样，初始时样本权重一样，每个样本被采样到的概率一致，每次从N个原始的训练样本中按照权重有放回采样N个样本作为训练集，然后计算训练集错误率，然后调整权重，重复采样，集成多个基学习器。</p>
</blockquote>
<p>从偏差-方差分解来看：Boosting算法主要关注于降低偏差，每轮的迭代都关注于训练过程中预测错误的样本，将弱学习提升为强学习器。从AdaBoost的算法流程来看，标准的AdaBoost只适用于二分类问题。在此，当选为数据挖掘十大算法之一的AdaBoost介绍到这里，能够当选正是说明这个算法十分婀娜多姿，背后的数学证明和推导充分证明了这一点，限于篇幅不再继续展开。</p>
<p>##<strong>9.3 Bagging与Random Forest</strong></p>
<p>相比之下，Bagging与随机森林算法就简洁了许多，上面已经提到产生“好而不同”的个体学习器是集成学习研究的核心，即在保证基学习器准确性的同时增加基学习器之间的多样性。而这两种算法的基本思（tao）想（lu）都是通过“自助采样”的方法来增加多样性。</p>
<p>###<strong>9.3.1 Bagging</strong></p>
<p>Bagging是一种并行式的集成学习方法，即基学习器的训练之间没有前后顺序可以同时进行，Bagging使用“有放回”采样的方式选取训练集，对于包含m个样本的训练集，进行m次有放回的随机采样操作，从而得到m个样本的采样集，这样训练集中有接近36.8%的样本没有被采到。按照相同的方式重复进行，我们就可以采集到T个包含m个样本的数据集，从而训练出T个基学习器，最终对这T个基学习器的输出进行结合。</p>
<p><img src="https://i.loli.net/2018/10/18/5bc84d0ce62fc.png" alt="7.png"></p>
<p>Bagging算法的流程如下所示：</p>
<p><img src="https://i.loli.net/2018/10/18/5bc84d0d0e761.png" alt="8.png"></p>
<p>可以看出Bagging主要通过<strong>样本的扰动</strong>来增加基学习器之间的多样性，因此Bagging的基学习器应为那些对训练集十分敏感的不稳定学习算法，例如：神经网络与决策树等。从偏差-方差分解来看，Bagging算法主要关注于降低方差，即通过多次重复训练提高稳定性。不同于AdaBoost的是，Bagging可以十分简单地移植到多分类、回归等问题。总的说起来则是：<strong>AdaBoost关注于降低偏差，而Bagging关注于降低方差。</strong></p>
<p>###<strong>9.3.2 随机森林</strong></p>
<p>随机森林（Random Forest）是Bagging的一个拓展体，它的基学习器固定为决策树，多棵树也就组成了森林，而“随机”则在于选择划分属性的随机，随机森林在训练基学习器时，也采用有放回采样的方式添加样本扰动，同时它还引入了一种<strong>属性扰动</strong>，即在基决策树的训练过程中，在选择划分属性时，RF先从候选属性集中随机挑选出一个包含K个属性的子集，再从这个子集中选择最优划分属性，一般推荐K&#x3D;log2（d）。</p>
<p>这样随机森林中基学习器的多样性不仅来自样本扰动，还来自属性扰动，从而进一步提升了基学习器之间的差异度。相比决策树的Bagging集成，随机森林的起始性能较差（由于属性扰动，基决策树的准确度有所下降），但随着基学习器数目的增多，随机森林往往会收敛到更低的泛化误差。同时不同于Bagging中决策树从所有属性集中选择最优划分属性，随机森林只在属性集的一个子集中选择划分属性，因此训练效率更高。</p>
<p><img src="https://i.loli.net/2018/10/18/5bc84d0d7a4fd.png" alt="9.png"></p>
<p>##<strong>9.4 结合策略</strong></p>
<p>结合策略指的是在训练好基学习器后，如何将这些基学习器的输出结合起来产生集成模型的最终输出，下面将介绍一些常用的结合策略：</p>
<p>###<strong>9.4.1 平均法（回归问题）</strong></p>
<p><img src="https://i.loli.net/2018/10/18/5bc84d0d07983.png" alt="10.png"></p>
<p><img src="https://i.loli.net/2018/10/18/5bc84de1b74ff.png" alt="11.png"></p>
<p>易知简单平均法是加权平均法的一种特例，加权平均法可以认为是集成学习研究的基本出发点。由于各个基学习器的权值在训练中得出，<strong>一般而言，在个体学习器性能相差较大时宜使用加权平均法，在个体学习器性能相差较小时宜使用简单平均法</strong>。</p>
<p>###<strong>9.4.2 投票法（分类问题）</strong></p>
<p><img src="https://i.loli.net/2018/10/18/5bc84de2629c4.png" alt="12.png"></p>
<p><img src="https://i.loli.net/2018/10/18/5bc84de25a74b.png" alt="13.png"></p>
<p><img src="https://i.loli.net/2018/10/18/5bc84de1bacc4.png" alt="14.png"></p>
<p>绝对多数投票法（majority voting）提供了拒绝选项，这在可靠性要求很高的学习任务中是一个很好的机制。同时，对于分类任务，各个基学习器的输出值有两种类型，分别为类标记和类概率。</p>
<p><img src="https://i.loli.net/2018/10/18/5bc84de2768c1.png" alt="15.png"></p>
<p>一些在产生类别标记的同时也生成置信度的学习器，置信度可转化为类概率使用，<strong>一般基于类概率进行结合往往比基于类标记进行结合的效果更好</strong>，需要注意的是对于异质集成，其类概率不能直接进行比较，此时需要将类概率转化为类标记输出，然后再投票。</p>
<p>###<strong>9.4.3 学习法</strong></p>
<p>学习法是一种更高级的结合策略，即学习出一种“投票”的学习器，Stacking是学习法的典型代表。Stacking的基本思想是：首先训练出T个基学习器，对于一个样本它们会产生T个输出，将这T个基学习器的输出与该样本的真实标记作为新的样本，m个样本就会产生一个m*T的样本集，来训练一个新的“投票”学习器。投票学习器的输入属性与学习算法对Stacking集成的泛化性能有很大的影响，书中已经提到：<strong>投票学习器采用类概率作为输入属性，选用多响应线性回归（MLR）一般会产生较好的效果</strong>。</p>
<p><img src="https://i.loli.net/2018/10/18/5bc84de25cbaf.png" alt="16.png"></p>
<p>##<strong>9.5 多样性（diversity）</strong></p>
<p>在集成学习中，基学习器之间的多样性是影响集成器泛化性能的重要因素。因此增加多样性对于集成学习研究十分重要，一般的思路是在学习过程中引入随机性，常见的做法主要是对数据样本、输入属性、输出表示、算法参数进行扰动。</p>
<blockquote>
<p><strong>数据样本扰动</strong>，即利用具有差异的数据集来训练不同的基学习器。例如：有放回自助采样法，但此类做法只对那些不稳定学习算法十分有效，例如：决策树和神经网络等，训练集的稍微改变能导致学习器的显著变动。<br><strong>输入属性扰动</strong>，即随机选取原空间的一个子空间来训练基学习器。例如：随机森林，从初始属性集中抽取子集，再基于每个子集来训练基学习器。但若训练集只包含少量属性，则不宜使用属性扰动。<br><strong>输出表示扰动</strong>，此类做法可对训练样本的类标稍作变动，或对基学习器的输出进行转化。<br><strong>算法参数扰动</strong>，通过随机设置不同的参数，例如：神经网络中，随机初始化权重与随机设置隐含层节点数。</p>
</blockquote>
<p>在此，集成学习就介绍完毕，看到这里，大家也会发现集成学习实质上是一种通用框架，可以使用任何一种基学习器，从而改进单个学习器的泛化性能。据说数据挖掘竞赛KDDCup历年的冠军几乎都使用了集成学习，看来的确是个好东西~</p>
]]></content>
  </entry>
  <entry>
    <title></title>
    <url>/2023/06/21/MachineLearning/Machine-learning-learning-notes-master/%E5%91%A8%E5%BF%97%E5%8D%8E%E3%80%8AMachine%20Learning%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(14)--%E8%AE%A1%E7%AE%97%E5%AD%A6%E4%B9%A0%E7%90%86%E8%AE%BA/</url>
    <content><![CDATA[<p>上篇主要介绍了常用的特征选择方法及稀疏学习。首先从相关&#x2F;无关特征出发引出了特征选择的基本概念，接着分别介绍了子集搜索与评价、过滤式、包裹式以及嵌入式四种类型的特征选择方法。子集搜索与评价使用的是一种优中生优的贪婪算法，即每次从候选特征子集中选出最优子集；过滤式方法计算一个相关统计量来评判特征的重要程度；包裹式方法将学习器作为特征选择的评价准则；嵌入式方法则是通过L1正则项将特征选择融入到学习器参数优化的过程中。最后介绍了稀疏表示与压缩感知的核心思想：稀疏表示利用稀疏矩阵的优良性质，试图通过某种方法找到原始稠密矩阵的合适稀疏表示；压缩感知则试图利用可稀疏表示的欠采样信息来恢复全部信息。本篇将讨论一种为机器学习提供理论保证的学习方法–计算学习理论。</p>
<p>#<strong>13、计算学习理论</strong></p>
<p>计算学习理论（computational learning theory）是通过“计算”来研究机器学习的理论，简而言之，其目的是分析学习任务的本质，例如：<strong>在什么条件下可进行有效的学习，需要多少训练样本能获得较好的精度等，从而为机器学习算法提供理论保证</strong>。</p>
<p>首先我们回归初心，再来谈谈经验误差和泛化误差。假设给定训练集D，其中所有的训练样本都服从一个未知的分布T，且它们都是在总体分布T中独立采样得到，即<strong>独立同分布</strong>（independent and identically distributed，i.i.d.），在《贝叶斯分类器》中我们已经提到：独立同分布是很多统计学习算法的基础假设，例如最大似然法，贝叶斯分类器，高斯混合聚类等，简单来理解独立同分布：每个样本都是从总体分布中独立采样得到，而没有拖泥带水。例如现在要进行问卷调查，要从总体人群中随机采样，看到一个美女你高兴地走过去，结果她男票突然冒了出来，说道：you jump，i jump，于是你本来只想调查一个人结果被强行撒了一把狗粮得到两份问卷，这样这两份问卷就不能称为独立同分布了，因为它们的出现具有强相关性。</p>
<p>回归正题，<strong>泛化误差指的是学习器在总体上的预测误差，经验误差则是学习器在某个特定数据集D上的预测误差</strong>。在实际问题中，往往我们并不能得到总体且数据集D是通过独立同分布采样得到的，因此我们常常使用经验误差作为泛化误差的近似。</p>
<p><img src="https://i.loli.net/2018/10/18/5bc854f38d4fe.png" alt="1.png"></p>
<p>##<strong>13.1 PAC学习</strong></p>
<p>在高中课本中，我们将<strong>函数定义为：从自变量到因变量的一种映射；对于机器学习算法，学习器也正是为了寻找合适的映射规则</strong>，即如何从条件属性得到目标属性。从样本空间到标记空间存在着很多的映射，我们将每个映射称之为<strong>概念</strong>（concept），定义：</p>
<blockquote>
<p>若概念c对任何样本x满足c(x)&#x3D;y，则称c为<strong>目标概念</strong>，即最理想的映射，所有的目标概念构成的集合称为<strong>“概念类”</strong>；<br>给定学习算法，它所有可能映射&#x2F;概念的集合称为<strong>“假设空间”</strong>，其中单个的概念称为<strong>“假设”</strong>（hypothesis）；<br>若一个算法的假设空间包含目标概念，则称该数据集对该算法是<strong>可分</strong>（separable）的，亦称<strong>一致</strong>（consistent）的；<br>若一个算法的假设空间不包含目标概念，则称该数据集对该算法是<strong>不可分</strong>（non-separable）的，或称<strong>不一致</strong>（non-consistent）的。</p>
</blockquote>
<p>举个简单的例子：对于非线性分布的数据集，若使用一个线性分类器，则该线性分类器对应的假设空间就是空间中所有可能的超平面，显然假设空间不包含该数据集的目标概念，所以称数据集对该学习器是不可分的。给定一个数据集D，我们希望模型学得的假设h尽可能地与目标概念一致，这便是<strong>概率近似正确</strong> (Probably Approximately Correct，简称PAC)的来源，即以较大的概率学得模型满足误差的预设上限。</p>
<p><img src="https://i.loli.net/2018/10/18/5bc854f446f97.png" alt="2.png"></p>
<p><img src="https://i.loli.net/2018/10/18/5bc854f482d0b.png" alt="3.png"></p>
<p><img src="https://i.loli.net/2018/10/18/5bc854f47d006.png" alt="4.png"></p>
<p><img src="https://i.loli.net/2018/10/18/5bc854f46ad91.png" alt="5.png"></p>
<p>上述关于PAC的几个定义层层相扣：定义12.1表达的是对于某种学习算法，如果能以一个置信度学得假设满足泛化误差的预设上限，则称该算法能PAC辨识概念类，即该算法的输出假设已经十分地逼近目标概念。定义12.2则将样本数量考虑进来，当样本超过一定数量时，学习算法总是能PAC辨识概念类，则称概念类为PAC可学习的。定义12.3将学习器运行时间也考虑进来，若运行时间为多项式时间，则称PAC学习算法。</p>
<p>显然，PAC学习中的一个关键因素就是<strong>假设空间的复杂度</strong>，对于某个学习算法，<strong>若假设空间越大，则其中包含目标概念的可能性也越大，但同时找到某个具体概念的难度也越大</strong>，一般假设空间分为有限假设空间与无限假设空间。</p>
<p>##<strong>13.2 有限假设空间</strong></p>
<p>###<strong>13.2.1 可分情形</strong></p>
<p>可分或一致的情形指的是：<strong>目标概念包含在算法的假设空间中</strong>。对于目标概念，在训练集D中的经验误差一定为0，因此首先我们可以想到的是：不断地剔除那些出现预测错误的假设，直到找到经验误差为0的假设即为目标概念。但<strong>由于样本集有限，可能会出现多个假设在D上的经验误差都为0，因此问题转化为：需要多大规模的数据集D才能让学习算法以置信度的概率从这些经验误差都为0的假设中找到目标概念的有效近似</strong>。</p>
<p><img src="https://i.loli.net/2018/10/18/5bc854f484f30.png" alt="6.png"></p>
<p>通过上式可以得知：<strong>对于可分情形的有限假设空间，目标概念都是PAC可学习的，即当样本数量满足上述条件之后，在与训练集一致的假设中总是可以在1-σ概率下找到目标概念的有效近似。</strong></p>
<p>###<strong>13.2.2 不可分情形</strong></p>
<p>不可分或不一致的情形指的是：<strong>目标概念不存在于假设空间中</strong>，这时我们就不能像可分情形时那样从假设空间中寻找目标概念的近似。但<strong>当假设空间给定时，必然存一个假设的泛化误差最小，若能找出此假设的有效近似也不失为一个好的目标，这便是不可知学习(agnostic learning)的来源。</strong></p>
<p><img src="https://i.loli.net/2018/10/18/5bc854f485f2e.png" alt="7.png"></p>
<p>这时候便要用到<strong>Hoeffding不等式</strong>：</p>
<p><img src="https://i.loli.net/2018/10/18/5bc854f46970a.png" alt="8.png"></p>
<p>对于假设空间中的所有假设，出现泛化误差与经验误差之差大于e的概率和为：</p>
<p><img src="https://i.loli.net/2018/10/18/5bc854f4114fd.png" alt="9.png"></p>
<p>因此，可令不等式的右边小于（等于）σ，便可以求出满足泛化误差与经验误差相差小于e所需的最少样本数，同时也可以求出泛化误差界。</p>
<p><img src="https://i.loli.net/2018/10/18/5bc854f440a02.png" alt="10.png"></p>
<p>##<strong>13.3 VC维</strong></p>
<p>现实中的学习任务通常都是无限假设空间，例如d维实数域空间中所有的超平面等，因此要对此种情形进行可学习研究，需要度量<strong>假设空间的复杂度</strong>。这便是<strong>VC维</strong>（Vapnik-Chervonenkis dimension）的来源。在介绍VC维之前，需要引入两个概念：</p>
<blockquote>
<p><strong>增长函数</strong>：对于给定数据集D，假设空间中的每个假设都能对数据集的样本赋予标记，因此一个假设对应着一种打标结果，不同假设对D的打标结果可能是相同的，也可能是不同的。随着样本数量m的增大，假设空间对样本集D的打标结果也会增多，增长函数则表示假设空间对m个样本的数据集D打标的最大可能结果数，因此<strong>增长函数描述了假设空间的表示能力与复杂度。</strong></p>
<p><img src="https://i.loli.net/2018/10/18/5bc855ba970cd.png" alt="11.png"></p>
</blockquote>
<blockquote>
<p><strong>打散</strong>：例如对二分类问题来说，m个样本最多有2^m个可能结果，每种可能结果称为一种<strong>“对分”</strong>，若假设空间能实现数据集D的所有对分，则称数据集能被该假设空间打散。</p>
</blockquote>
<p><strong>因此尽管假设空间是无限的，但它对特定数据集打标的不同结果数是有限的，假设空间的VC维正是它能打散的最大数据集大小</strong>。通常这样来计算假设空间的VC维：若存在大小为d的数据集能被假设空间打散，但不存在任何大小为d+1的数据集能被假设空间打散，则其VC维为d。</p>
<p><img src="https://i.loli.net/2018/10/18/5bc855bb20c1e.png" alt="12.png"></p>
<p>同时书中给出了假设空间VC维与增长函数的两个关系：</p>
<p><img src="https://i.loli.net/2018/10/18/5bc855ba83eb8.png" alt="13.png"></p>
<p>直观来理解（1）式也十分容易： 首先假设空间的VC维是d，说明当m&lt;&#x3D;d时，增长函数与2^m相等，例如：当m&#x3D;d时，右边的组合数求和刚好等于2^d；而当m&#x3D;d+1时，右边等于2^(d+1)-1，十分符合VC维的定义，同时也可以使用数学归纳法证明；（2）式则是由（1）式直接推导得出。</p>
<p>在有限假设空间中，根据Hoeffding不等式便可以推导得出学习算法的泛化误差界；但在无限假设空间中，由于假设空间的大小无法计算，只能通过增长函数来描述其复杂度，因此无限假设空间中的泛化误差界需要引入增长函数。</p>
<p><img src="https://i.loli.net/2018/10/18/5bc855babc890.png" alt="14.png"></p>
<p><img src="https://i.loli.net/2018/10/18/5bc855ba5b2c3.png" alt="15.png"></p>
<p>上式给出了基于VC维的泛化误差界，同时也可以计算出满足条件需要的样本数（样本复杂度）。若学习算法满足<strong>经验风险最小化原则（ERM）</strong>，即学习算法的输出假设h在数据集D上的经验误差最小，可证明：<strong>任何VC维有限的假设空间都是（不可知）PAC可学习的，换而言之：若假设空间的最小泛化误差为0即目标概念包含在假设空间中，则是PAC可学习，若最小泛化误差不为0，则称为不可知PAC可学习。</strong></p>
<p>##<strong>13.4 稳定性</strong></p>
<p>稳定性考察的是当算法的输入发生变化时，输出是否会随之发生较大的变化，输入的数据集D有以下两种变化：</p>
<p><img src="https://i.loli.net/2018/10/18/5bc855badc5a8.png" alt="16.png"></p>
<p>若对数据集中的任何样本z，满足：</p>
<p><img src="https://i.loli.net/2018/10/18/5bc855ba59b06.png" alt="17.png"></p>
<p>即原学习器和剔除一个样本后生成的学习器对z的损失之差保持β稳定，称学习器关于损失函数满足<strong>β-均匀稳定性</strong>。同时若损失函数有上界，即原学习器对任何样本的损失函数不超过M，则有如下定理：</p>
<p><img src="https://i.loli.net/2018/10/18/5bc855babe7c3.png" alt="18.png"></p>
<p>事实上，<strong>若学习算法符合经验风险最小化原则（ERM）且满足β-均匀稳定性，则假设空间是可学习的</strong>。稳定性通过损失函数与假设空间的可学习联系在了一起，区别在于：假设空间关注的是经验误差与泛化误差，需要考虑到所有可能的假设；而稳定性只关注当前的输出假设。</p>
<p>在此，计算学习理论就介绍完毕，一看这个名字就知道这一章比较偏底层理论了，最终还是咬着牙看完了它，这里引用一段小文字来梳理一下现在的心情：“孤岂欲卿治经为博士邪？但当涉猎，见往事耳”，就当扩充知识体系吧~</p>
]]></content>
  </entry>
  <entry>
    <title></title>
    <url>/2023/06/21/MachineLearning/Machine-learning-learning-notes-master/%E5%91%A8%E5%BF%97%E5%8D%8E%E3%80%8AMachine%20Learning%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(13)--%E7%89%B9%E5%BE%81%E9%80%89%E6%8B%A9%E4%B8%8E%E7%A8%80%E7%96%8F%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<p>上篇主要介绍了经典的降维方法与度量学习，首先从“维数灾难”导致的样本稀疏以及距离难计算两大难题出发，引出了降维的概念，即通过某种数学变换将原始高维空间转变到一个低维的子空间，接着分别介绍了kNN、MDS、PCA、KPCA以及两种经典的流形学习方法，k近邻算法的核心在于k值的选取以及距离的度量，MDS要求原始空间样本之间的距离在降维后的低维空间中得以保持，主成分分析试图找到一个低维超平面来表出原空间样本点，核化主成分分析先将样本点映射到高维空间，再在高维空间中使用线性降维的方法，从而解决了原空间样本非线性分布的情形，基于流形学习的降维则是一种“邻域保持”的思想，最后度量学习试图去学习出一个距离度量来等效降维的效果。本篇将讨论另一种常用方法–特征选择与稀疏学习。</p>
<p>#<strong>12、特征选择与稀疏学习</strong></p>
<p>最近在看论文的过程中，发现对于数据集行和列的叫法颇有不同，故在介绍本篇之前，决定先将最常用的术语罗列一二，以后再见到了不管它脚扑朔还是眼迷离就能一眼识破真身了~对于数据集中的一个对象及组成对象的零件元素：</p>
<blockquote>
<p>统计学家常称它们为<strong>观测</strong>（<strong>observation</strong>）和<strong>变量</strong>（<strong>variable</strong>）；<br>数据库分析师则称其为<strong>记录</strong>（<strong>record</strong>）和<strong>字段</strong>（<strong>field</strong>）；<br>数据挖掘&#x2F;机器学习学科的研究者则习惯把它们叫做<strong>样本</strong>&#x2F;<strong>示例</strong>（<strong>example</strong>&#x2F;<strong>instance</strong>）和<strong>属性</strong>&#x2F;<strong>特征</strong>（<strong>attribute</strong>&#x2F;<strong>feature</strong>）。</p>
</blockquote>
<p>回归正题，在机器学习中特征选择是一个重要的“<strong>数据预处理</strong>”（<strong>data</strong> <strong>preprocessing</strong>）过程，即试图从数据集的所有特征中挑选出与当前学习任务相关的特征子集，接着再利用数据子集来训练学习器；稀疏学习则是围绕着稀疏矩阵的优良性质，来完成相应的学习任务。</p>
<p>##<strong>12.1 子集搜索与评价</strong></p>
<p>一般地，我们可以用很多属性&#x2F;特征来描述一个示例，例如对于一个人可以用性别、身高、体重、年龄、学历、专业、是否吃货等属性来描述，那现在想要训练出一个学习器来预测人的收入。根据生活经验易知：并不是所有的特征都与学习任务相关，例如年龄&#x2F;学历&#x2F;专业可能很大程度上影响了收入，身高&#x2F;体重这些外貌属性也有较小的可能性影响收入，但像是否是一个地地道道的吃货这种属性就八杆子打不着了。因此我们只需要那些与学习任务紧密相关的特征，<strong>特征选择便是从给定的特征集合中选出相关特征子集的过程</strong>。</p>
<p>与上篇中降维技术有着异曲同工之处的是，特征选择也可以有效地解决维数灾难的难题。具体而言：<strong>降维从一定程度起到了提炼优质低维属性和降噪的效果，特征选择则是直接剔除那些与学习任务无关的属性而选择出最佳特征子集</strong>。若直接遍历所有特征子集，显然当维数过多时遭遇指数爆炸就行不通了；若采取从候选特征子集中不断迭代生成更优候选子集的方法，则时间复杂度大大减小。这时就涉及到了两个关键环节：<strong>1.如何生成候选子集；2.如何评价候选子集的好坏</strong>，这便是早期特征选择的常用方法。书本上介绍了贪心算法，分为三种策略：</p>
<blockquote>
<p><strong>前向搜索</strong>：初始将每个特征当做一个候选特征子集，然后从当前所有的候选子集中选择出最佳的特征子集；接着在上一轮选出的特征子集中添加一个新的特征，同样地选出最佳特征子集；最后直至选不出比上一轮更好的特征子集。<br><strong>后向搜索</strong>：初始将所有特征作为一个候选特征子集；接着尝试去掉上一轮特征子集中的一个特征并选出当前最优的特征子集；最后直到选不出比上一轮更好的特征子集。<br><strong>双向搜索</strong>：将前向搜索与后向搜索结合起来，即在每一轮中既有添加操作也有剔除操作。</p>
</blockquote>
<p>对于特征子集的评价，书中给出了一些想法及基于信息熵的方法。假设数据集的属性皆为离散属性，这样给定一个特征子集，便可以通过这个特征子集的取值将数据集合划分为V个子集。例如：A1&#x3D;{男,女}，A2&#x3D;{本科,硕士}就可以将原数据集划分为2*2&#x3D;4个子集，其中每个子集的取值完全相同。这时我们就可以像决策树选择划分属性那样，通过计算信息增益来评价该属性子集的好坏。</p>
<p><img src="https://i.loli.net/2018/10/18/5bc853eca1a43.png" alt="1.png"></p>
<p>此时，信息增益越大表示该属性子集包含有助于分类的特征越多，使用上述这种<strong>子集搜索与子集评价相结合的机制，便可以得到特征选择方法</strong>。值得一提的是若将前向搜索策略与信息增益结合在一起，与前面我们讲到的ID3决策树十分地相似。事实上，决策树也可以用于特征选择，树节点划分属性组成的集合便是选择出的特征子集。</p>
<p>##<strong>12.2 过滤式选择（Relief）</strong></p>
<p>过滤式方法是一种将特征选择与学习器训练相分离的特征选择技术，即首先将相关特征挑选出来，再使用选择出的数据子集来训练学习器。Relief是其中著名的代表性算法，它使用一个“<strong>相关统计量</strong>”来度量特征的重要性，该统计量是一个向量，其中每个分量代表着相应特征的重要性，因此我们最终可以根据这个统计量各个分量的大小来选择出合适的特征子集。</p>
<p>易知Relief算法的核心在于如何计算出该相关统计量。对于数据集中的每个样例xi，Relief首先找出与xi同类别的最近邻与不同类别的最近邻，分别称为<strong>猜中近邻（near-hit）</strong>与<strong>猜错近邻（near-miss）</strong>，接着便可以分别计算出相关统计量中的每个分量。对于j分量：</p>
<p><img src="https://i.loli.net/2018/10/18/5bc853ec70c88.png" alt="2.png"></p>
<p>直观上理解：对于猜中近邻，两者j属性的距离越小越好，对于猜错近邻，j属性距离越大越好。更一般地，若xi为离散属性，diff取海明距离，即相同取0，不同取1；若xi为连续属性，则diff为曼哈顿距离，即取差的绝对值。分别计算每个分量，最终取平均便得到了整个相关统计量。</p>
<p>标准的Relief算法只用于二分类问题，后续产生的拓展变体Relief-F则解决了多分类问题。对于j分量，新的计算公式如下：</p>
<p><img src="https://i.loli.net/2018/10/18/5bc853ec93042.png" alt="3.png"></p>
<p>其中pl表示第l类样本在数据集中所占的比例，易知两者的不同之处在于：<strong>标准Relief 只有一个猜错近邻，而Relief-F有多个猜错近邻</strong>。</p>
<p>##<strong>12.3 包裹式选择（LVW）</strong></p>
<p>与过滤式选择不同的是，包裹式选择将后续的学习器也考虑进来作为特征选择的评价准则。因此包裹式选择可以看作是为某种学习器<strong>量身定做</strong>的特征选择方法，由于在每一轮迭代中，包裹式选择都需要训练学习器，因此在获得较好性能的同时也产生了较大的开销。下面主要介绍一种经典的包裹式特征选择方法 –LVW（Las Vegas Wrapper），它在拉斯维加斯框架下使用随机策略来进行特征子集的搜索。拉斯维加斯？怎么听起来那么耳熟，不是那个声名显赫的赌场吗？歪果仁真会玩。怀着好奇科普一下，结果又顺带了一个赌场：</p>
<blockquote>
<p><strong>蒙特卡罗算法</strong>：采样越多，越近似最优解，一定会给出解，但给出的解不一定是正确解；<br><strong>拉斯维加斯算法</strong>：采样越多，越有机会找到最优解，不一定会给出解，且给出的解一定是正确解。</p>
</blockquote>
<p>举个例子，假如筐里有100个苹果，让我每次闭眼拿1个，挑出最大的。于是我随机拿1个，再随机拿1个跟它比，留下大的，再随机拿1个……我每拿一次，留下的苹果都至少不比上次的小。拿的次数越多，挑出的苹果就越大，但我除非拿100次，否则无法肯定挑出了最大的。这个挑苹果的算法，就属于蒙特卡罗算法——尽量找较好的，但不保证是最好的。</p>
<p>而拉斯维加斯算法，则是另一种情况。假如有一把锁，给我100把钥匙，只有1把是对的。于是我每次随机拿1把钥匙去试，打不开就再换1把。我试的次数越多，打开（正确解）的机会就越大，但在打开之前，那些错的钥匙都是没有用的。这个试钥匙的算法，就是拉斯维加斯的——尽量找最好的，但不保证能找到。</p>
<p>LVW算法的具体流程如下所示，其中比较特别的是停止条件参数T的设置，即在每一轮寻找最优特征子集的过程中，若随机T次仍没找到，算法就会停止，从而保证了算法运行时间的可行性。</p>
<p><img src="https://i.loli.net/2018/10/18/5bc853ed5e08e.png" alt="4.png"></p>
<p>##<strong>12.4 嵌入式选择与正则化</strong></p>
<p>前面提到了的两种特征选择方法：<strong>过滤式中特征选择与后续学习器完全分离，包裹式则是使用学习器作为特征选择的评价准则；嵌入式是一种将特征选择与学习器训练完全融合的特征选择方法，即将特征选择融入学习器的优化过程中</strong>。在之前《经验风险与结构风险》中已经提到：经验风险指的是模型与训练数据的契合度，结构风险则是模型的复杂程度，机器学习的核心任务就是：<strong>在模型简单的基础上保证模型的契合度</strong>。例如：岭回归就是加上了L2范数的最小二乘法，有效地解决了奇异矩阵、过拟合等诸多问题，下面的嵌入式特征选择则是在损失函数后加上了L1范数。</p>
<p><img src="https://i.loli.net/2018/10/18/5bc853ec8b203.png" alt="5.png"></p>
<p>L1范数美名又约<strong>Lasso Regularization</strong>，指的是向量中每个元素的绝对值之和，这样在优化目标函数的过程中，就会使得w尽可能地小，在一定程度上起到了防止过拟合的作用，同时与L2范数（Ridge Regularization ）不同的是，L1范数会使得部分w变为0， 从而达到了特征选择的效果。</p>
<p>总的来说：<strong>L1范数会趋向产生少量的特征，其他特征的权值都是0；L2会选择更多的特征，这些特征的权值都会接近于0</strong>。这样L1范数在特征选择上就十分有用，而L2范数则具备较强的控制过拟合能力。可以从下面两个方面来理解：</p>
<p>（1）<strong>下降速度</strong>：L1范数按照绝对值函数来下降，L2范数按照二次函数来下降。因此在0附近，L1范数的下降速度大于L2范数，故L1范数能很快地下降到0，而L2范数在0附近的下降速度非常慢，因此较大可能收敛在0的附近。</p>
<p><img src="https://i.loli.net/2018/10/18/5bc853ed0aaf5.png" alt="6.png"></p>
<p>（2）<strong>空间限制</strong>：L1范数与L2范数都试图在最小化损失函数的同时，让权值W也尽可能地小。我们可以将原优化问题看做为下面的问题，即让后面的规则则都小于某个阈值。这样从图中可以看出：L1范数相比L2范数更容易得到稀疏解。</p>
<p><img src="https://i.loli.net/2018/10/18/5bc853ecc223e.png" alt="7.png"></p>
<p><img src="https://i.loli.net/2018/10/18/5bc853ed51aa1.png" alt="8.png"></p>
<p>##<strong>12.5 稀疏表示与字典学习</strong></p>
<p>当样本数据是一个稀疏矩阵时，对学习任务来说会有不少的好处，例如很多问题变得线性可分，储存更为高效等。这便是稀疏表示与字典学习的基本出发点。稀疏矩阵即矩阵的每一行&#x2F;列中都包含了大量的零元素，且这些零元素没有出现在同一行&#x2F;列，对于一个给定的稠密矩阵，若我们能<strong>通过某种方法找到其合适的稀疏表示</strong>，则可以使得学习任务更加简单高效，我们称之为<strong>稀疏编码（sparse coding）</strong>或<strong>字典学习（dictionary learning）</strong>。</p>
<p>给定一个数据集，字典学习&#x2F;稀疏编码指的便是通过一个字典将原数据转化为稀疏表示，因此最终的目标就是求得字典矩阵B及稀疏表示α，书中使用变量交替优化的策略能较好地求得解，深感陷进去短时间无法自拔，故先不进行深入…</p>
<p><img src="https://i.loli.net/2018/10/18/5bc853ed0ca43.png" alt="9.png"></p>
<p>##<strong>12.6 压缩感知</strong></p>
<p>压缩感知在前些年也是风风火火，与特征选择、稀疏表示不同的是：它关注的是通过欠采样信息来恢复全部信息。在实际问题中，为了方便传输和存储，我们一般将数字信息进行压缩，这样就有可能损失部分信息，如何根据已有的信息来重构出全部信号，这便是压缩感知的来历，压缩感知的前提是已知的信息具有稀疏表示。下面是关于压缩感知的一些背景：</p>
<p><img src="https://i.loli.net/2018/10/18/5bc853ed431c6.png" alt="10.png"></p>
<p>在此，特征选择与稀疏学习就介绍完毕。在很多实际情形中，选了好的特征比选了好的模型更为重要，这也是为什么厉害的大牛能够很快地得出一些结论的原因，谓：吾昨晚夜观天象，星象云是否吃货乃无用也~</p>
]]></content>
  </entry>
  <entry>
    <title></title>
    <url>/2023/06/21/MachineLearning/Machine-learning-learning-notes-master/%E5%91%A8%E5%BF%97%E5%8D%8E%E3%80%8AMachine%20Learning%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(16)--%E6%A6%82%E7%8E%87%E5%9B%BE%E6%A8%A1%E5%9E%8B/</url>
    <content><![CDATA[<p>上篇主要介绍了半监督学习，首先从如何利用未标记样本所蕴含的分布信息出发，引入了半监督学习的基本概念，即训练数据同时包含有标记样本和未标记样本的学习方法；接着分别介绍了几种常见的半监督学习方法：生成式方法基于对数据分布的假设，利用未标记样本隐含的分布信息，使得对模型参数的估计更加准确；TSVM给未标记样本赋予伪标记，并通过不断调整易出错样本的标记得到最终输出；基于分歧的方法结合了集成学习的思想，通过多个学习器在不同视图上的协作，有效利用了未标记样本数据 ；最后半监督聚类则是借助已有的监督信息来辅助聚类的过程，带约束k-均值算法需检测当前样本划分是否满足约束关系，带标记k-均值算法则利用有标记样本指定初始类中心。本篇将讨论一种基于图的学习算法–概率图模型。</p>
<p>#<strong>15、概率图模型</strong></p>
<p>现在再来谈谈机器学习的核心价值观，可以更通俗地理解为：<strong>根据一些已观察到的证据来推断未知</strong>，更具哲学性地可以阐述为：未来的发展总是遵循着历史的规律。其中<strong>基于概率的模型将学习任务归结为计算变量的概率分布</strong>，正如之前已经提到的：生成式模型先对联合分布进行建模，从而再来求解后验概率，例如：贝叶斯分类器先对联合分布进行最大似然估计，从而便可以计算类条件概率；判别式模型则是直接对条件分布进行建模。</p>
<p><strong>概率图模型</strong>（probabilistic graphical model）是一类用<strong>图结构</strong>来表达各属性之间相关关系的概率模型，一般而言：<strong>图中的一个结点表示一个或一组随机变量，结点之间的边则表示变量间的相关关系</strong>，从而形成了一张“<strong>变量关系图</strong>”。若使用有向的边来表达变量之间的依赖关系，这样的有向关系图称为<strong>贝叶斯网</strong>（Bayesian nerwork）或有向图模型；若使用无向边，则称为<strong>马尔可夫网</strong>（Markov network）或无向图模型。</p>
<p>##<strong>15.1 隐马尔可夫模型(HMM)</strong></p>
<p>隐马尔可夫模型（Hidden Markov Model，简称HMM）是结构最简单的一种贝叶斯网，在语音识别与自然语言处理领域上有着广泛的应用。HMM中的变量分为两组：<strong>状态变量</strong>与<strong>观测变量</strong>，其中状态变量一般是未知的，因此又称为“<strong>隐变量</strong>”，观测变量则是已知的输出值。在隐马尔可夫模型中，变量之间的依赖关系遵循如下两个规则：</p>
<blockquote>
<p><strong>1. 观测变量的取值仅依赖于状态变量</strong>；<br><strong>2. 下一个状态的取值仅依赖于当前状态</strong>，通俗来讲：<strong>现在决定未来，未来与过去无关</strong>，这就是著名的<strong>马尔可夫性</strong>。</p>
</blockquote>
<p><img src="https://s1.ax1x.com/2018/10/18/iwYPmR.png" alt="iwYPmR.png"></p>
<p>基于上述变量之间的依赖关系，我们很容易写出隐马尔可夫模型中所有变量的联合概率分布：</p>
<p><img src="https://s1.ax1x.com/2018/10/18/iwY9X9.png" alt="iwY9X9.png"></p>
<p>易知：<strong>欲确定一个HMM模型需要以下三组参数</strong>：</p>
<p><img src="https://s1.ax1x.com/2018/10/18/iwYi01.png" alt="iwYi01.png"></p>
<p>当确定了一个HMM模型的三个参数后，便按照下面的规则来生成观测值序列：</p>
<p><img src="https://s1.ax1x.com/2018/10/18/iwYFTx.png" alt="iwYFTx.png"></p>
<p>在实际应用中，HMM模型的发力点主要体现在下述三个问题上：</p>
<p><img src="https://s1.ax1x.com/2018/10/18/iwYEtK.png" alt="iwYEtK.png"></p>
<p>###<strong>15.1.1 HMM评估问题</strong></p>
<p>HMM评估问题指的是：<strong>给定了模型的三个参数与观测值序列，求该观测值序列出现的概率</strong>。例如：对于赌场问题，便可以依据骰子掷出的结果序列来计算该结果序列出现的可能性，若小概率的事件发生了则可认为赌场的骰子有作弊的可能。解决该问题使用的是<strong>前向算法</strong>，即步步为营，自底向上的方式逐步增加序列的长度，直到获得目标概率值。在前向算法中，定义了一个<strong>前向变量</strong>，即给定观察值序列且t时刻的状态为Si的概率：</p>
<p><img src="https://s1.ax1x.com/2018/10/18/iwYVfO.png" alt="iwYVfO.png"></p>
<p>基于前向变量，很容易得到该问题的递推关系及终止条件：</p>
<p><img src="https://s1.ax1x.com/2018/10/18/iwYAk6.png" alt="iwYAk6.png"></p>
<p>因此可使用动态规划法，从最小的子问题开始，通过填表格的形式一步一步计算出目标结果。</p>
<p>###<strong>15.1.2 HMM解码问题</strong></p>
<p>HMM解码问题指的是：<strong>给定了模型的三个参数与观测值序列，求可能性最大的状态序列</strong>。例如：在语音识别问题中，人说话形成的数字信号对应着观测值序列，对应的具体文字则是状态序列，从数字信号转化为文字正是对应着根据观测值序列推断最有可能的状态值序列。解决该问题使用的是<strong>Viterbi算法</strong>，与前向算法十分类似地，Viterbi算法定义了一个<strong>Viterbi变量</strong>，也是采用动态规划的方法，自底向上逐步求解。</p>
<p><img src="https://s1.ax1x.com/2018/10/18/iwYepD.png" alt="iwYepD.png"></p>
<p>###<strong>15.1.3 HMM学习问题</strong></p>
<p>HMM学习问题指的是：<strong>给定观测值序列，如何调整模型的参数使得该序列出现的概率最大</strong>。这便转化成了机器学习问题，即从给定的观测值序列中学习出一个HMM模型，<strong>该问题正是EM算法的经典案例之一</strong>。其思想也十分简单：对于给定的观测值序列，如果我们能够按照该序列潜在的规律来调整模型的三个参数，则可以使得该序列出现的可能性最大。假设状态值序列也已知，则很容易计算出与该序列最契合的模型参数：</p>
<p><img src="https://s1.ax1x.com/2018/10/18/iwYm1e.png" alt="iwYm1e.png"></p>
<p>但一般状态值序列都是不可观测的，且<strong>即使给定观测值序列与模型参数，状态序列仍然遭遇组合爆炸</strong>。因此上面这种简单的统计方法就行不通了，若将状态值序列看作为隐变量，这时便可以考虑使用EM算法来对该问题进行求解：</p>
<p>【1】首先对HMM模型的三个参数进行随机初始化；<br>【2】根据模型的参数与观测值序列，计算t时刻状态为i且t+1时刻状态为j的概率以及t时刻状态为i的概率。</p>
<p><img src="https://s1.ax1x.com/2018/10/18/iwYn6H.png" alt="iwYn6H.png"><br><img src="https://s1.ax1x.com/2018/10/18/iwYdns.png" alt="iwYdns.png"></p>
<p>【3】接着便可以对模型的三个参数进行重新估计：</p>
<p><img src="https://s1.ax1x.com/2018/10/18/iwYY9S.png" alt="iwYY9S.png"></p>
<p>【4】重复步骤2-3，直至三个参数值收敛，便得到了最终的HMM模型。</p>
<p>##<strong>15.2 马尔可夫随机场（MRF）</strong></p>
<p>马尔可夫随机场（Markov Random Field）是一种典型的马尔可夫网，即使用无向边来表达变量间的依赖关系。在马尔可夫随机场中，对于关系图中的一个子集，<strong>若任意两结点间都有边连接，则称该子集为一个团；若再加一个结点便不能形成团，则称该子集为极大团</strong>。MRF使用<strong>势函数</strong>来定义多个变量的概率分布函数，其中<strong>每个（极大）团对应一个势函数</strong>，一般团中的变量关系也体现在它所对应的极大团中，因此常常基于极大团来定义变量的联合概率分布函数。具体而言，若所有变量构成的极大团的集合为C，则MRF的联合概率函数可以定义为：</p>
<p><img src="https://s1.ax1x.com/2018/10/18/iwYGh8.png" alt="iwYGh8.png"></p>
<p>对于条件独立性，<strong>马尔可夫随机场通过分离集来实现条件独立</strong>，若A结点集必须经过C结点集才能到达B结点集，则称C为分离集。书上给出了一个简单情形下的条件独立证明过程，十分贴切易懂，此处不再展开。基于分离集的概念，得到了MRF的三个性质：</p>
<blockquote>
<p><strong>全局马尔可夫性</strong>：给定两个变量子集的分离集，则这两个变量子集条件独立。<br><strong>局部马尔可夫性</strong>：给定某变量的邻接变量，则该变量与其它变量条件独立。<br><strong>成对马尔可夫性</strong>：给定所有其他变量，两个非邻接变量条件独立。</p>
</blockquote>
<p><img src="https://s1.ax1x.com/2018/10/18/iwY07q.png" alt="iwY07q.png"></p>
<p>对于MRF中的势函数，势函数主要用于描述团中变量之间的相关关系，且要求为非负函数，直观来看：势函数需要在偏好的变量取值上函数值较大，例如：若x1与x2成正相关，则需要将这种关系反映在势函数的函数值中。一般我们常使用指数函数来定义势函数：</p>
<p><img src="https://s1.ax1x.com/2018/10/18/iwY8tf.png" alt="iwY8tf.png"></p>
<p>##<strong>15.3 条件随机场（CRF）</strong></p>
<p>前面所讲到的<strong>隐马尔可夫模型和马尔可夫随机场都属于生成式模型，即对联合概率进行建模，条件随机场则是对条件分布进行建模</strong>。CRF试图在给定观测值序列后，对状态序列的概率分布进行建模，即P(y | x)。直观上看：CRF与HMM的解码问题十分类似，都是在给定观测值序列后，研究状态序列可能的取值。CRF可以有多种结构，只需保证状态序列满足马尔可夫性即可，一般我们常使用的是<strong>链式条件随机场</strong>：</p>
<p><img src="https://s1.ax1x.com/2018/10/18/iwYt1g.png" alt="iwYt1g.png"></p>
<p>与马尔可夫随机场定义联合概率类似地，CRF也通过团以及势函数的概念来定义条件概率P(y | x)。在给定观测值序列的条件下，链式条件随机场主要包含两种团结构：单个状态团及相邻状态团，通过引入两类特征函数便可以定义出目标条件概率：</p>
<p><img src="https://s1.ax1x.com/2018/10/18/iwYNcQ.png" alt="iwYNcQ.png"></p>
<p>以词性标注为例，如何判断给出的一个标注序列靠谱不靠谱呢？<strong>转移特征函数主要判定两个相邻的标注是否合理</strong>，例如：动词+动词显然语法不通；<strong>状态特征函数则判定观测值与对应的标注是否合理</strong>，例如： ly结尾的词–&gt;副词较合理。因此我们可以定义一个特征函数集合，用这个特征函数集合来为一个标注序列打分，并据此选出最靠谱的标注序列。也就是说，每一个特征函数（对应一种规则）都可以用来为一个标注序列评分，把集合中所有特征函数对同一个标注序列的评分综合起来，就是这个标注序列最终的评分值。可以看出：<strong>特征函数是一些经验的特性</strong>。</p>
<p>##<strong>15.4 学习与推断</strong></p>
<p>对于生成式模型，通常我们都是先对变量的联合概率分布进行建模，接着再求出目标变量的<strong>边际分布</strong>（marginal distribution），那如何从联合概率得到边际分布呢？这便是学习与推断。下面主要介绍两种精确推断的方法：<strong>变量消去</strong>与<strong>信念传播</strong>。</p>
<p>###<strong>15.4.1 变量消去</strong></p>
<p>变量消去利用条件独立性来消减计算目标概率值所需的计算量，它通过运用<strong>乘法与加法的分配率</strong>，将对变量的积的求和问题转化为对部分变量交替进行求积与求和的问题，从而将每次的<strong>运算控制在局部</strong>，达到简化运算的目的。</p>
<p><img src="https://s1.ax1x.com/2018/10/18/iwYUXj.png" alt="iwYUXj.png"><br><img src="https://s1.ax1x.com/2018/10/18/iwYwBn.png" alt="iwYwBn.png"></p>
<p>###<strong>15.4.2 信念传播</strong></p>
<p>若将变量求和操作看作是一种消息的传递过程，信念传播可以理解成：<strong>一个节点在接收到所有其它节点的消息后才向另一个节点发送消息</strong>，同时当前节点的边际概率正比于他所接收的消息的乘积：</p>
<p><img src="https://s1.ax1x.com/2018/10/18/iwYDA0.png" alt="iwYDA0.png"></p>
<p>因此只需要经过下面两个步骤，便可以完成所有的消息传递过程。利用动态规划法的思想记录传递过程中的所有消息，当计算某个结点的边际概率分布时，只需直接取出传到该结点的消息即可，从而避免了计算多个边际分布时的冗余计算问题。</p>
<blockquote>
<p>1.指定一个根节点，从所有的叶节点开始向根节点传递消息，直到根节点收到所有邻接结点的消息<strong>（从叶到根）</strong>；<br>2.从根节点开始向叶节点传递消息，直到所有叶节点均收到消息<strong>（从根到叶）</strong>。</p>
</blockquote>
<p><img src="https://s1.ax1x.com/2018/10/18/iwYgc4.png" alt="iwYgc4.png"></p>
<p>##<strong>15.5 LDA话题模型</strong></p>
<p>话题模型主要用于处理文本类数据，其中<strong>隐狄利克雷分配模型</strong>（Latent Dirichlet Allocation，简称LDA）是话题模型的杰出代表。在话题模型中，有以下几个基本概念：词（word）、文档（document）、话题（topic）。</p>
<blockquote>
<p><strong>词</strong>：最基本的离散单元；<br><strong>文档</strong>：由一组词组成，词在文档中不计顺序；<br><strong>话题</strong>：由一组特定的词组成，这组词具有较强的相关关系。</p>
</blockquote>
<p>在现实任务中，一般我们可以得出一个文档的词频分布，但不知道该文档对应着哪些话题，LDA话题模型正是为了解决这个问题。具体来说：<strong>LDA认为每篇文档包含多个话题，且其中每一个词都对应着一个话题</strong>。因此可以假设文档是通过如下方式生成：</p>
<p><img src="https://s1.ax1x.com/2018/10/18/iwY2jJ.png" alt="iwY2jJ.png"></p>
<p>这样一个文档中的所有词都可以认为是通过话题模型来生成的，当已知一个文档的词频分布后（即一个N维向量，N为词库大小），则可以认为：<strong>每一个词频元素都对应着一个话题，而话题对应的词频分布则影响着该词频元素的大小</strong>。因此很容易写出LDA模型对应的联合概率函数：</p>
<p><img src="https://s1.ax1x.com/2018/10/18/iwYc3F.png" alt="iwYc3F.png"><br><img src="https://s1.ax1x.com/2018/10/18/iwYWu9.png" alt="iwYWu9.png"></p>
<p>从上图可以看出，LDA的三个表示层被三种颜色表示出来：</p>
<blockquote>
<p><strong>corpus-level（红色）：</strong> α和β表示语料级别的参数，也就是每个文档都一样，因此生成过程只采样一次。<br><strong>document-level（橙色）：</strong> θ是文档级别的变量，每个文档对应一个θ。<br><strong>word-level（绿色）：</strong> z和w都是单词级别变量，z由θ生成，w由z和β共同生成，一个单词w对应一个主题z。</p>
</blockquote>
<p>通过上面对LDA生成模型的讨论，可以知道<strong>LDA模型主要是想从给定的输入语料中学习训练出两个控制参数α和β</strong>，当学习出了这两个控制参数就确定了模型，便可以用来生成文档。其中α和β分别对应以下各个信息：</p>
<blockquote>
<p><strong>α</strong>：分布p(θ)需要一个向量参数，即Dirichlet分布的参数，用于生成一个主题θ向量；<br><strong>β</strong>：各个主题对应的单词概率分布矩阵p(w|z)。</p>
</blockquote>
<p>把w当做观察变量，θ和z当做隐藏变量，就可以通过EM算法学习出α和β，求解过程中遇到后验概率p(θ,z|w)无法直接求解，需要找一个似然函数下界来近似求解，原作者使用基于分解（factorization）假设的变分法（varialtional inference）进行计算，用到了EM算法。每次E-step输入α和β，计算似然函数，M-step最大化这个似然函数，算出α和β，不断迭代直到收敛。</p>
<p>在此，概率图模型就介绍完毕。上周受到协同训练的启发，让实验的小伙伴做了一个HMM的slides，结果扩充了好多知识，所以完成这篇笔记还是花费了不少功夫，还刚好赶上实验室没空调回到解放前的日子，可谓汗流之作…</p>
]]></content>
  </entry>
  <entry>
    <title></title>
    <url>/2023/06/21/MachineLearning/Machine-learning-learning-notes-master/%E5%91%A8%E5%BF%97%E5%8D%8E%E3%80%8AMachine%20Learning%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(17)--%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<p>上篇主要介绍了概率图模型，首先从生成式模型与判别式模型的定义出发，引出了概率图模型的基本概念，即利用图结构来表达变量之间的依赖关系；接着分别介绍了隐马尔可夫模型、马尔可夫随机场、条件随机场、精确推断方法以及LDA话题模型：HMM主要围绕着评估&#x2F;解码&#x2F;学习这三个实际问题展开论述；MRF基于团和势函数的概念来定义联合概率分布；CRF引入两种特征函数对状态序列进行评价打分；变量消去与信念传播在给定联合概率分布后计算特定变量的边际分布；LDA话题模型则试图去推断给定文档所蕴含的话题分布。本篇将介绍最后一种学习算法–强化学习。</p>
<p>#<strong>16、强化学习</strong></p>
<p><strong>强化学习</strong>（Reinforcement Learning，简称<strong>RL</strong>）是机器学习的一个重要分支，前段时间人机大战的主角AlphaGo正是以强化学习为核心技术。在强化学习中，包含两种基本的元素：<strong>状态</strong>与<strong>动作</strong>，<strong>在某个状态下执行某种动作，这便是一种策略</strong>，学习器要做的就是通过不断地探索学习，从而获得一个好的策略。例如：在围棋中，一种落棋的局面就是一种状态，若能知道每种局面下的最优落子动作，那就攻无不克&#x2F;百战不殆了~</p>
<p>若将状态看作为属性，动作看作为标记，易知：<strong>监督学习和强化学习都是在试图寻找一个映射，从已知属性&#x2F;状态推断出标记&#x2F;动作</strong>，这样强化学习中的策略相当于监督学习中的分类&#x2F;回归器。但在实际问题中，<strong>强化学习并没有监督学习那样的标记信息</strong>，通常都是在<strong>尝试动作后才能获得结果</strong>，因此强化学习是通过反馈的结果信息不断调整之前的策略，从而算法能够学习到：在什么样的状态下选择什么样的动作可以获得最好的结果。</p>
<p>##<strong>16.1 基本要素</strong></p>
<p>强化学习任务通常使用<strong>马尔可夫决策过程</strong>（Markov Decision Process，简称<strong>MDP</strong>）来描述，具体而言：机器处在一个环境中，每个状态为机器对当前环境的感知；机器只能通过动作来影响环境，当机器执行一个动作后，会使得环境按某种概率转移到另一个状态；同时，环境会根据潜在的奖赏函数反馈给机器一个奖赏。综合而言，强化学习主要包含四个要素：状态、动作、转移概率以及奖赏函数。</p>
<blockquote>
<p><strong>状态（X）</strong>：机器对环境的感知，所有可能的状态称为状态空间；<br><strong>动作（A）</strong>：机器所采取的动作，所有能采取的动作构成动作空间；<br><strong>转移概率（P）</strong>：当执行某个动作后，当前状态会以某种概率转移到另一个状态；<br><strong>奖赏函数（R）</strong>：在状态转移的同时，环境给反馈给机器一个奖赏。</p>
</blockquote>
<p><img src="https://s1.ax1x.com/2018/10/18/iwYOud.png" alt="iwYOud.png"></p>
<p>因此，<strong>强化学习的主要任务就是通过在环境中不断地尝试，根据尝试获得的反馈信息调整策略，最终生成一个较好的策略π，机器根据这个策略便能知道在什么状态下应该执行什么动作</strong>。常见的策略表示方法有以下两种：</p>
<blockquote>
<p><strong>确定性策略</strong>：π（x）&#x3D;a，即在状态x下执行a动作；<br><strong>随机性策略</strong>：P&#x3D;π（x,a），即在状态x下执行a动作的概率。</p>
</blockquote>
<p><strong>一个策略的优劣取决于长期执行这一策略后的累积奖赏</strong>，换句话说：可以使用累积奖赏来评估策略的好坏，最优策略则表示在初始状态下一直执行该策略后，最后的累积奖赏值最高。长期累积奖赏通常使用下述两种计算方法：</p>
<p><img src="https://s1.ax1x.com/2018/10/18/iwYH3D.png" alt="iwYH3D.png"></p>
<p>##<strong>16.2 K摇摆赌博机</strong></p>
<p>首先我们考虑强化学习最简单的情形：仅考虑一步操作，即在状态x下只需执行一次动作a便能观察到奖赏结果。易知：欲最大化单步奖赏，我们需要知道每个动作带来的期望奖赏值，这样便能选择奖赏值最大的动作来执行。若每个动作的奖赏值为确定值，则只需要将每个动作尝试一遍即可，但大多数情形下，一个动作的奖赏值来源于一个概率分布，因此需要进行多次的尝试。</p>
<p>单步强化学习实质上是<strong>K-摇臂赌博机</strong>（K-armed bandit）的原型，一般我们<strong>尝试动作的次数是有限的</strong>，那如何利用有限的次数进行有效地探索呢？这里有两种基本的想法：</p>
<blockquote>
<p><strong>仅探索法</strong>：将尝试的机会平均分给每一个动作，即轮流执行，最终将每个动作的平均奖赏作为期望奖赏的近似值。<br><strong>仅利用法</strong>：将尝试的机会分给当前平均奖赏值最大的动作，隐含着让一部分人先富起来的思想。</p>
</blockquote>
<p>可以看出：上述<strong>两种方法是相互矛盾的</strong>，仅探索法能较好地估算每个动作的期望奖赏，但是没能根据当前的反馈结果调整尝试策略；仅利用法在每次尝试之后都更新尝试策略，符合强化学习的思（tao）维（lu），但容易找不到最优动作。因此需要在这两者之间进行折中。</p>
<p>###<strong>16.2.1 ε-贪心</strong></p>
<p><strong>ε-贪心法基于一个概率来对探索和利用进行折中</strong>，具体而言：在每次尝试时，以ε的概率进行探索，即以均匀概率随机选择一个动作；以1-ε的概率进行利用，即选择当前最优的动作。ε-贪心法只需记录每个动作的当前平均奖赏值与被选中的次数，便可以增量式更新。</p>
<p><img src="https://s1.ax1x.com/2018/10/18/iwYzUP.png" alt="iwYzUP.png"></p>
<p>###<strong>16.2.2 Softmax</strong></p>
<p><strong>Softmax算法则基于当前每个动作的平均奖赏值来对探索和利用进行折中，Softmax函数将一组值转化为一组概率</strong>，值越大对应的概率也越高，因此当前平均奖赏值越高的动作被选中的几率也越大。Softmax函数如下所示：</p>
<p><img src="https://s1.ax1x.com/2018/10/18/iwYbge.png" alt="iwYbge.png"><br><img src="https://s1.ax1x.com/2018/10/18/iwYqjH.png" alt="iwYqjH.png"></p>
<p>##<strong>16.3 有模型学习</strong></p>
<p>若学习任务中的四个要素都已知，即状态空间、动作空间、转移概率以及奖赏函数都已经给出，这样的情形称为“<strong>有模型学习</strong>”。假设状态空间和动作空间均为有限，即均为离散值，这样我们不用通过尝试便可以对某个策略进行评估。</p>
<p>###<strong>16.3.1 策略评估</strong></p>
<p>前面提到：<strong>在模型已知的前提下，我们可以对任意策略的进行评估</strong>（后续会给出演算过程）。一般常使用以下两种值函数来评估某个策略的优劣：</p>
<blockquote>
<p><strong>状态值函数（V）</strong>：V（x），即从状态x出发，使用π策略所带来的累积奖赏；<br><strong>状态-动作值函数（Q）</strong>：Q（x,a），即从状态x出发，执行动作a后再使用π策略所带来的累积奖赏。</p>
</blockquote>
<p>根据累积奖赏的定义，我们可以引入T步累积奖赏与r折扣累积奖赏：</p>
<p><img src="https://s1.ax1x.com/2018/10/18/iwYjHI.png" alt="iwYjHI.png"><br><img src="https://s1.ax1x.com/2018/10/18/iwYXDA.png" alt="iwYXDA.png"></p>
<p>由于MDP具有马尔可夫性，即现在决定未来，将来和过去无关，我们很容易找到值函数的递归关系：</p>
<p><img src="https://s1.ax1x.com/2018/10/18/iwtS4f.png" alt="iwtS4f.png"></p>
<p>类似地，对于r折扣累积奖赏可以得到：</p>
<p><img src="https://s1.ax1x.com/2018/10/18/iwYxEt.png" alt="iwYxEt.png"></p>
<p>易知：<strong>当模型已知时，策略的评估问题转化为一种动态规划问题</strong>，即以填表格的形式自底向上，先求解每个状态的单步累积奖赏，再求解每个状态的两步累积奖赏，一直迭代逐步求解出每个状态的T步累积奖赏。算法流程如下所示：</p>
<p><img src="https://s1.ax1x.com/2018/10/18/iwt9C8.png" alt="iwt9C8.png"></p>
<p>对于状态-动作值函数，只需通过简单的转化便可得到：</p>
<p><img src="https://s1.ax1x.com/2018/10/18/iwt3r9.png" alt="iwt3r9.png"></p>
<p>###<strong>16.3.2 策略改进</strong></p>
<p>理想的策略应能使得每个状态的累积奖赏之和最大，简单来理解就是：不管处于什么状态，只要通过该策略执行动作，总能得到较好的结果。因此对于给定的某个策略，我们需要对其进行改进，从而得到<strong>最优的值函数</strong>。</p>
<p><img src="https://s1.ax1x.com/2018/10/18/iwtm5V.png" alt="iwtm5V.png"><br><img src="https://s1.ax1x.com/2018/10/18/iwtZEq.png" alt="iwtZEq.png"></p>
<p>最优Bellman等式改进策略的方式为：<strong>将策略选择的动作改为当前最优的动作</strong>，而不是像之前那样对每种可能的动作进行求和。易知：选择当前最优动作相当于将所有的概率都赋给累积奖赏值最大的动作，因此每次改进都会使得值函数单调递增。</p>
<p><img src="https://s1.ax1x.com/2018/10/18/iwtEbn.png" alt="iwtEbn.png"></p>
<p>将策略评估与策略改进结合起来，我们便得到了生成最优策略的方法：先给定一个随机策略，现对该策略进行评估，然后再改进，接着再评估&#x2F;改进一直到策略收敛、不再发生改变。这便是策略迭代算法，算法流程如下所示：</p>
<p><img src="https://s1.ax1x.com/2018/10/18/iwteU0.png" alt="iwteU0.png"></p>
<p>可以看出：策略迭代法在每次改进策略后都要对策略进行重新评估，因此比较耗时。若从最优化值函数的角度出发，即先迭代得到最优的值函数，再来计算如何改变策略，这便是值迭代算法，算法流程如下所示：</p>
<p><img src="https://s1.ax1x.com/2018/10/18/iwtuCT.png" alt="iwtuCT.png"></p>
<p>##<strong>16.4 蒙特卡罗强化学习</strong></p>
<p>在现实的强化学习任务中，<strong>环境的转移函数与奖赏函数往往很难得知</strong>，因此我们需要考虑在不依赖于环境参数的条件下建立强化学习模型，这便是<strong>免模型学习</strong>。蒙特卡罗强化学习便是其中的一种经典方法。</p>
<p>由于模型参数未知，状态值函数不能像之前那样进行全概率展开，从而运用动态规划法求解。一种直接的方法便是通过采样来对策略进行评估&#x2F;估算其值函数，<strong>蒙特卡罗强化学习正是基于采样来估计状态-动作值函数</strong>：对采样轨迹中的每一对状态-动作，记录其后的奖赏值之和，作为该状态-动作的一次累积奖赏，通过多次采样后，使用累积奖赏的平均作为状态-动作值的估计，并<strong>引入ε-贪心策略保证采样的多样性</strong>。</p>
<p><img src="https://s1.ax1x.com/2018/10/18/iwt1KJ.png" alt="iwt1KJ.png"></p>
<p>在上面的算法流程中，被评估和被改进的都是同一个策略，因此称为<strong>同策略蒙特卡罗强化学习算法</strong>。引入ε-贪心仅是为了便于采样评估，而在使用策略时并不需要ε-贪心，那能否仅在评估时使用ε-贪心策略，而在改进时使用原始策略呢？这便是<strong>异策略蒙特卡罗强化学习算法</strong>。</p>
<p><img src="https://s1.ax1x.com/2018/10/18/iwtK8U.png" alt="iwtK8U.png"></p>
<p>##<strong>16.5 AlphaGo原理浅析</strong></p>
<p>本篇一开始便提到强化学习是AlphaGo的核心技术之一，刚好借着这个东风将AlphaGo的工作原理了解一番。正如人类下棋那般“<strong>手下一步棋，心想三步棋</strong>”，Alphago也正是这个思想，<strong>当处于一个状态时，机器会暗地里进行多次的尝试&#x2F;采样，并基于反馈回来的结果信息改进估值函数，从而最终通过增强版的估值函数来选择最优的落子动作。</strong></p>
<p>其中便涉及到了三个主要的问题：<strong>（1）如何确定估值函数（2）如何进行采样（3）如何基于反馈信息改进估值函数</strong>，这正对应着AlphaGo的三大核心模块：<strong>深度学习</strong>、<strong>蒙特卡罗搜索树</strong>、<strong>强化学习</strong>。</p>
<blockquote>
<p><strong>1.深度学习（拟合估值函数）</strong></p>
</blockquote>
<p>由于围棋的状态空间巨大，像蒙特卡罗强化学习那样通过采样来确定值函数就行不通了。在围棋中，<strong>状态值函数可以看作为一种局面函数，状态-动作值函数可以看作一种策略函数</strong>，若我们能获得这两个估值函数，便可以根据这两个函数来完成：(1)衡量当前局面的价值；(2)选择当前最优的动作。那如何精确地估计这两个估值函数呢？<strong>这就用到了深度学习，通过大量的对弈数据自动学习出特征，从而拟合出估值函数。</strong></p>
<blockquote>
<p><strong>2.蒙特卡罗搜索树（采样）</strong></p>
</blockquote>
<p>蒙特卡罗树是一种经典的搜索框架，它通过反复地采样模拟对局来探索状态空间。具体表现在：从当前状态开始，利用策略函数尽可能选择当前最优的动作，同时也引入随机性来减小估值错误带来的负面影响，从而模拟棋局运行，使得棋盘达到终局或一定步数后停止。</p>
<p><img src="https://s1.ax1x.com/2018/10/18/iwtM2F.png" alt="iwtM2F.png"></p>
<blockquote>
<p><strong>3.强化学习（调整估值函数）</strong></p>
</blockquote>
<p>在使用蒙特卡罗搜索树进行多次采样后，每次采样都会反馈后续的局面信息（利用局面函数进行评价），根据反馈回来的结果信息自动调整两个估值函数的参数，这便是强化学习的核心思想，最后基于改进后的策略函数选择出当前最优的落子动作。</p>
<p><img src="https://s1.ax1x.com/2018/10/18/iwtQv4.png" alt="iwtQv4.png"></p>
<p>在此，强化学习就介绍完毕。同时也意味着大口小口地啃完了这个西瓜，十分记得去年双11之后立下这个Flag，现在回想起来，大半年的时间里在嚼瓜上还是花费了不少功夫。有人说：当你阐述的能让别人看懂才算是真的理解，有人说：在写的过程中能发现那些只看书发现不了的东西，自己最初的想法十分简单：当健忘症发作的时候，如果能看到之前按照自己思路写下的文字，回忆便会汹涌澎湃一些~</p>
<p>最后，感谢自己这大半年以来的坚持~Get busy living, or get busy dying!</p>
]]></content>
  </entry>
  <entry>
    <title></title>
    <url>/2023/06/21/MachineLearning/Machine-learning-learning-notes-master/%E5%91%A8%E5%BF%97%E5%8D%8E%E3%80%8AMachine%20Learning%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(15)--%E5%8D%8A%E7%9B%91%E7%9D%A3%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<p>上篇主要介绍了机器学习的理论基础，首先从独立同分布引入泛化误差与经验误差，接着介绍了PAC可学习的基本概念，即以较大的概率学习出与目标概念近似的假设（泛化误差满足预设上限），对于有限假设空间：（1）可分情形时，假设空间都是PAC可学习的，即当样本满足一定的数量之后，总是可以在与训练集一致的假设中找出目标概念的近似；（2）不可分情形时，假设空间都是不可知PAC可学习的，即以较大概率学习出与当前假设空间中泛化误差最小的假设的有效近似（Hoeffding不等式）。对于无限假设空间，通过增长函数与VC维来描述其复杂度，若学习算法满足经验风险最小化原则，则任何VC维有限的假设空间都是（不可知）PAC可学习的，同时也给出了泛化误差界与样本复杂度。稳定性则考察的是输入发生变化时输出的波动，稳定性通过损失函数与假设空间的可学习理论联系在了一起。本篇将讨论一种介于监督与非监督学习之间的学习算法–半监督学习。</p>
<p>#<strong>14、半监督学习</strong></p>
<p>前面我们一直围绕的都是监督学习与无监督学习，监督学习指的是训练样本包含标记信息的学习任务，例如：常见的分类与回归算法；无监督学习则是训练样本不包含标记信息的学习任务，例如：聚类算法。在实际生活中，常常会出现一部分样本有标记和较多样本无标记的情形，例如：做网页推荐时需要让用户标记出感兴趣的网页，但是少有用户愿意花时间来提供标记。若直接丢弃掉无标记样本集，使用传统的监督学习方法，常常会由于训练样本的不充足，使得其刻画总体分布的能力减弱，从而影响了学习器泛化性能。那如何利用未标记的样本数据呢？</p>
<p>一种简单的做法是通过专家知识对这些未标记的样本进行打标，但随之而来的就是巨大的人力耗费。若我们先使用有标记的样本数据集训练出一个学习器，再基于该学习器对未标记的样本进行预测，从中<strong>挑选出不确定性高或分类置信度低的样本来咨询专家并进行打标</strong>，最后使用扩充后的训练集重新训练学习器，这样便能大幅度降低标记成本，这便是<strong>主动学习</strong>（active learning），其目标是<strong>使用尽量少的&#x2F;有价值的咨询来获得更好的性能</strong>。</p>
<p>显然，<strong>主动学习需要与外界进行交互&#x2F;查询&#x2F;打标，其本质上仍然属于一种监督学习</strong>。事实上，无标记样本虽未包含标记信息，但它们与有标记样本一样都是从总体中独立同分布采样得到，因此<strong>它们所包含的数据分布信息对学习器的训练大有裨益</strong>。如何让学习过程不依赖外界的咨询交互，自动利用未标记样本所包含的分布信息的方法便是<strong>半监督学习</strong>（semi-supervised learning），<strong>即训练集同时包含有标记样本数据和未标记样本数据</strong>。</p>
<p><img src="https://i.loli.net/2018/10/18/5bc856e39801d.png" alt="1.png"></p>
<p>此外，半监督学习还可以进一步划分为<strong>纯半监督学习</strong>和<strong>直推学习</strong>，两者的区别在于：前者假定训练数据集中的未标记数据并非待预测数据，而后者假定学习过程中的未标记数据就是待预测数据。主动学习、纯半监督学习以及直推学习三者的概念如下图所示：</p>
<p><img src="https://s1.ax1x.com/2018/10/18/iwJFJS.png" alt="iwJFJS.png"></p>
<p>##<strong>14.1 生成式方法</strong></p>
<p><strong>生成式方法</strong>（generative methods）是基于生成式模型的方法，即先对联合分布P（x,c）建模，从而进一步求解 P（c | x），<strong>此类方法假定样本数据服从一个潜在的分布，因此需要充分可靠的先验知识</strong>。例如：前面已经接触到的贝叶斯分类器与高斯混合聚类，都属于生成式模型。现假定总体是一个高斯混合分布，即由多个高斯分布组合形成，从而一个子高斯分布就代表一个类簇（类别）。高斯混合分布的概率密度函数如下所示：</p>
<p><img src="https://i.loli.net/2018/10/18/5bc856e3b82dc.png" alt="3.png"></p>
<p>不失一般性，假设类簇与真实的类别按照顺序一一对应，即第i个类簇对应第i个高斯混合成分。与高斯混合聚类类似地，这里的主要任务也是估计出各个高斯混合成分的参数以及混合系数，不同的是：对于有标记样本，不再是可能属于每一个类簇，而是只能属于真实类标对应的特定类簇。</p>
<p><img src="https://i.loli.net/2018/10/18/5bc856e431d30.png" alt="4.png"></p>
<p>直观上来看，<strong>基于半监督的高斯混合模型有机地整合了贝叶斯分类器与高斯混合聚类的核心思想</strong>，有效地利用了未标记样本数据隐含的分布信息，从而使得参数的估计更加准确。同样地，这里也要召唤出之前的EM大法进行求解，首先对各个高斯混合成分的参数及混合系数进行随机初始化，计算出各个PM（即γji，第i个样本属于j类，有标记样本则直接属于特定类），再最大化似然函数（即LL（D）分别对α、u和∑求偏导 ），对参数进行迭代更新。</p>
<p><img src="https://i.loli.net/2018/10/18/5bc856e43ff08.png" alt="5.png"></p>
<p>当参数迭代更新收敛后，对于待预测样本x，便可以像贝叶斯分类器那样计算出样本属于每个类簇的后验概率，接着找出概率最大的即可：</p>
<p><img src="https://i.loli.net/2018/10/18/5bc856e3dfb1c.png" alt="6.png"></p>
<p>可以看出：基于生成式模型的方法十分依赖于对潜在数据分布的假设，即假设的分布要能和真实分布相吻合，否则利用未标记的样本数据反倒会在错误的道路上渐行渐远，从而降低学习器的泛化性能。因此，<strong>此类方法要求极强的领域知识和掐指观天的本领</strong>。</p>
<p>##<strong>14.2 半监督SVM</strong></p>
<p>监督学习中的SVM试图找到一个划分超平面，使得两侧支持向量之间的间隔最大，即“<strong>最大划分间隔</strong>”思想。对于半监督学习，S3VM则考虑超平面需穿过数据低密度的区域。TSVM是半监督支持向量机中的最著名代表，其核心思想是：尝试为未标记样本找到合适的标记指派，使得超平面划分后的间隔最大化。TSVM采用局部搜索的策略来进行迭代求解，即首先使用有标记样本集训练出一个初始SVM，接着使用该学习器对未标记样本进行打标，这样所有样本都有了标记，并基于这些有标记的样本重新训练SVM，之后再寻找易出错样本不断调整。整个算法流程如下所示：</p>
<p><img src="https://i.loli.net/2018/10/18/5bc856e427830.png" alt="7.png"></p>
<p><img src="https://s1.ax1x.com/2018/10/18/iwJZss.png" alt="iwJZss.png"></p>
<p>##<strong>14.3 基于分歧的方法</strong></p>
<p>基于分歧的方法通过多个学习器之间的<strong>分歧（disagreement）&#x2F;多样性（diversity）</strong>来利用未标记样本数据，协同训练就是其中的一种经典方法。<strong>协同训练最初是针对于多视图（multi-view）数据而设计的，多视图数据指的是样本对象具有多个属性集，每个属性集则对应一个试图</strong>。例如：电影数据中就包含画面类属性和声音类属性，这样画面类属性的集合就对应着一个视图。首先引入两个关于视图的重要性质：</p>
<blockquote>
<p><strong>相容性</strong>：即使用单个视图数据训练出的学习器的输出空间是一致的。例如都是{好，坏}、{+1,-1}等。<br><strong>互补性</strong>：即不同视图所提供的信息是互补&#x2F;相辅相成的，实质上这里体现的就是集成学习的思想。</p>
</blockquote>
<p>协同训练正是很好地利用了多视图数据的“<strong>相容互补性</strong>”，其基本的思想是：首先基于有标记样本数据在每个视图上都训练一个初始分类器，然后让每个分类器去挑选分类置信度最高的样本并赋予标记，并将带有伪标记的样本数据传给另一个分类器去学习，从而<strong>你依我侬&#x2F;共同进步</strong>。</p>
<p><img src="https://s1.ax1x.com/2018/10/18/iwJVMj.png" alt="iwJVMj.png"><br><img src="https://s1.ax1x.com/2018/10/18/iwJeLn.png" alt="iwJeLn.png"></p>
<p>##<strong>14.4 半监督聚类</strong></p>
<p>前面提到的几种方法都是借助无标记样本数据来辅助监督学习的训练过程，从而使得学习更加充分&#x2F;泛化性能得到提升；半监督聚类则是借助已有的监督信息来辅助聚类的过程。一般而言，监督信息大致有两种类型：</p>
<blockquote>
<p><strong>必连与勿连约束</strong>：必连指的是两个样本必须在同一个类簇，勿连则是必不在同一个类簇。<br><strong>标记信息</strong>：少量的样本带有真实的标记。</p>
</blockquote>
<p>下面主要介绍两种基于半监督的K-Means聚类算法：第一种是数据集包含一些必连与勿连关系，另外一种则是包含少量带有标记的样本。两种算法的基本思想都十分的简单：对于带有约束关系的k-均值算法，在迭代过程中对每个样本划分类簇时，需要<strong>检测当前划分是否满足约束关系</strong>，若不满足则会将该样本划分到距离次小对应的类簇中，再继续检测是否满足约束关系，直到完成所有样本的划分。算法流程如下图所示：</p>
<p><img src="https://s1.ax1x.com/2018/10/18/iwJAzQ.png" alt="iwJAzQ.png"></p>
<p>对于带有少量标记样本的k-均值算法，则可以<strong>利用这些有标记样本进行类中心的指定，同时在对样本进行划分时，不需要改变这些有标记样本的簇隶属关系</strong>，直接将其划分到对应类簇即可。算法流程如下所示：</p>
<p><img src="https://s1.ax1x.com/2018/10/18/iwJkRg.png" alt="iwJkRg.png"></p>
<p>在此，半监督学习就介绍完毕。十分有趣的是：半监督学习将前面许多知识模块联系在了一起，足以体现了作者编排的用心。结合本篇的新知识再来回想之前自己做过的一些研究，发现还是蹚了一些浑水，也许越是觉得过去的自己傻，越就是好的兆头吧~</p>
]]></content>
  </entry>
  <entry>
    <title>西瓜书2.5</title>
    <url>/2023/06/21/MachineLearning/Machine-learning-learning-notes-master/%E5%91%A8%E5%BF%97%E5%8D%8E%E3%80%8AMachine%20Learning%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(2)--%E6%80%A7%E8%83%BD%E5%BA%A6%E9%87%8F/</url>
    <content><![CDATA[<p>本篇主要是对第二章剩余知识的理解，包括：性能度量、比较检验和偏差与方差。在上一篇中，我们解决了评估学习器泛化性能的方法，即用测试集的“测试误差”作为“泛化误差”的近似，当我们划分好训练&#x2F;测试集后，那如何计算“测试误差”呢？这就是性能度量，例如：均方差，错误率等，即“测试误差”的一个评价标准。有了评估方法和性能度量，就可以计算出学习器的“测试误差”，但由于“测试误差”受到很多因素的影响，例如：算法随机性或测试集本身的选择，那如何对两个或多个学习器的性能度量结果做比较呢？这就是比较检验。最后偏差与方差是解释学习器泛化性能的一种重要工具。写到后面发现冗长之后读起来十分没有快感，故本篇主要知识点为性能度量。</p>
<p><strong>2.5 性能度量</strong></p>
<p>性能度量（performance measure）是衡量模型泛化能力的评价标准，在对比不同模型的能力时，使用不同的性能度量往往会导致不同的评判结果。本节除2.5.1外，其它主要介绍分类模型的性能度量。</p>
<p><strong>2.5.1 最常见的性能度量</strong></p>
<p>在回归任务中，即预测连续值的问题，最常用的性能度量是“均方误差”（mean squared error）,很多的经典算法都是采用了MSE作为评价函数，想必大家都十分熟悉。</p>
<p><img src="https://i.loli.net/2018/10/17/5bc71daf76276.png" alt="1.png"></p>
<p>在分类任务中，即预测离散值的问题，最常用的是错误率和精度，错误率是分类错误的样本数占样本总数的比例，精度则是分类正确的样本数占样本总数的比例，易知：错误率+精度&#x3D;1。</p>
<p><img src="https://i.loli.net/2018/10/17/5bc71daf4c704.png" alt="2.png"></p>
<p><img src="https://i.loli.net/2018/10/17/5bc71daf6fb84.png" alt="3.png"></p>
<p><strong>2.5.2 查准率&#x2F;查全率&#x2F;F1</strong></p>
<p>错误率和精度虽然常用，但不能满足所有的需求，例如：在推荐系统中，我们只关心推送给用户的内容用户是否感兴趣（即查准率），或者说所有用户感兴趣的内容我们推送出来了多少（即查全率）。因此，使用查准&#x2F;查全率更适合描述这类问题。对于二分类问题，分类结果混淆矩阵与查准&#x2F;查全率定义如下：</p>
<p><img src="https://i.loli.net/2018/10/17/5bc71daf885a4.png" alt="4.png"></p>
<p>初次接触时，FN与FP很难正确的理解，按照惯性思维容易把FN理解成：False-&gt;Negtive，即将错的预测为错的，这样FN和TN就反了，后来找到一张图，描述得很详细，为方便理解，把这张图也贴在了下边：</p>
<p><img src="https://i.loli.net/2018/10/17/5bc71daf871a6.png" alt="5.png"></p>
<p>正如天下没有免费的午餐，查准率和查全率是一对矛盾的度量。例如我们想让推送的内容尽可能用户全都感兴趣，那只能推送我们把握高的内容，这样就漏掉了一些用户感兴趣的内容，查全率就低了；如果想让用户感兴趣的内容都被推送，那只有将所有内容都推送上，宁可错杀一千，不可放过一个，这样查准率就很低了。</p>
<p>“P-R曲线”正是描述查准&#x2F;查全率变化的曲线，P-R曲线定义如下：根据学习器的预测结果（一般为一个实值或概率）对测试样本进行排序，将最可能是“正例”的样本排在前面，最不可能是“正例”的排在后面，按此顺序逐个把样本作为“正例”进行预测，每次计算出当前的P值和R值，如下图所示：</p>
<p><img src="https://i.loli.net/2018/10/17/5bc71dafc4411.png" alt="6.png"></p>
<p>P-R曲线如何评估呢？若一个学习器A的P-R曲线被另一个学习器B的P-R曲线完全包住，则称：B的性能优于A。若A和B的曲线发生了交叉，则谁的曲线下的面积大，谁的性能更优。但一般来说，曲线下的面积是很难进行估算的，所以衍生出了“平衡点”（Break-Event Point，简称BEP），即当P&#x3D;R时的取值，平衡点的取值越高，性能更优。</p>
<p>P和R指标有时会出现矛盾的情况，这样就需要综合考虑他们，最常见的方法就是F-Measure，又称F-Score。F-Measure是P和R的加权调和平均，即：</p>
<p><img src="https://i.loli.net/2018/10/17/5bc71daf40ff6.png" alt="7.png"></p>
<p><img src="https://i.loli.net/2018/10/17/5bc71daf75407.png" alt="8.png"></p>
<p>特别地，当β&#x3D;1时，也就是常见的F1度量，是P和R的调和平均，当F1较高时，模型的性能越好。</p>
<p><img src="https://i.loli.net/2018/10/17/5bc71daf20885.png" alt="9.png"></p>
<p><img src="https://i.loli.net/2018/10/17/5bc71daf4b90a.png" alt="10.png"></p>
<p>有时候我们会有多个二分类混淆矩阵，例如：多次训练或者在多个数据集上训练，那么估算全局性能的方法有两种，分为宏观和微观。简单理解，宏观就是先算出每个混淆矩阵的P值和R值，然后取得平均P值macro-P和平均R值macro-R，在算出Fβ或F1，而微观则是计算出混淆矩阵的平均TP、FP、TN、FN，接着进行计算P、R，进而求出Fβ或F1。</p>
<p><img src="https://i.loli.net/2018/10/17/5bc71ed70230e.png" alt="11.png"></p>
<p><strong>2.5.3 ROC与AUC</strong></p>
<p>如上所述：学习器对测试样本的评估结果一般为一个实值或概率，设定一个阈值，大于阈值为正例，小于阈值为负例，因此这个实值的好坏直接决定了学习器的泛化性能，若将这些实值排序，则排序的好坏决定了学习器的性能高低。ROC曲线正是从这个角度出发来研究学习器的泛化性能，ROC曲线与P-R曲线十分类似，都是按照排序的顺序逐一按照正例预测，不同的是ROC曲线以“真正例率”（True Positive Rate，简称TPR）为横轴，纵轴为“假正例率”（False Positive Rate，简称FPR），ROC偏重研究基于测试样本评估值的排序好坏。</p>
<p><img src="https://i.loli.net/2018/10/17/5bc71ed6bee91.png" alt="12.png"></p>
<p><img src="https://i.loli.net/2018/10/17/5bc71ed75cefe.png" alt="13.png"></p>
<p>简单分析图像，可以得知：当FN&#x3D;0时，TN也必须0，反之也成立，我们可以画一个队列，试着使用不同的截断点（即阈值）去分割队列，来分析曲线的形状，（0,0）表示将所有的样本预测为负例，（1,1）则表示将所有的样本预测为正例，（0,1）表示正例全部出现在负例之前的理想情况，（1,0）则表示负例全部出现在正例之前的最差情况。限于篇幅，这里不再论述。</p>
<p>现实中的任务通常都是有限个测试样本，因此只能绘制出近似ROC曲线。绘制方法：首先根据测试样本的评估值对测试样本排序，接着按照以下规则进行绘制。</p>
<p><img src="https://i.loli.net/2018/10/17/5bc71ed740a24.png" alt="14.png"></p>
<p>同样地，进行模型的性能比较时，若一个学习器A的ROC曲线被另一个学习器B的ROC曲线完全包住，则称B的性能优于A。若A和B的曲线发生了交叉，则谁的曲线下的面积大，谁的性能更优。ROC曲线下的面积定义为AUC（Area Uder ROC Curve），不同于P-R的是，这里的AUC是可估算的，即AOC曲线下每一个小矩形的面积之和。易知：AUC越大，证明排序的质量越好，AUC为1时，证明所有正例排在了负例的前面，AUC为0时，所有的负例排在了正例的前面。</p>
<p><img src="https://i.loli.net/2018/10/17/5bc71ed6e2c57.png" alt="15.png"></p>
<p><strong>2.5.4 代价敏感错误率与代价曲线</strong></p>
<p>上面的方法中，将学习器的犯错同等对待，但在现实生活中，将正例预测成假例与将假例预测成正例的代价常常是不一样的，例如：将无疾病–&gt;有疾病只是增多了检查，但有疾病–&gt;无疾病却是增加了生命危险。以二分类为例，由此引入了“代价矩阵”（cost matrix）。</p>
<p><img src="https://i.loli.net/2018/10/17/5bc71ed6ed582.png" alt="16.png"></p>
<p>在非均等错误代价下，我们希望的是最小化“总体代价”，这样“代价敏感”的错误率（2.5.1节介绍）为：</p>
<p><img src="https://i.loli.net/2018/10/17/5bc71ed70bebe.png" alt="17.png"></p>
<p>同样对于ROC曲线，在非均等错误代价下，演变成了“代价曲线”，代价曲线横轴是取值在[0,1]之间的正例概率代价，式中p表示正例的概率，纵轴是取值为[0,1]的归一化代价。</p>
<p><img src="https://i.loli.net/2018/10/17/5bc71ed6e952e.png" alt="18.png"></p>
<p><img src="https://i.loli.net/2018/10/17/5bc71ed6eee7b.png" alt="19.png"></p>
<p>代价曲线的绘制很简单：设ROC曲线上一点的坐标为(TPR，FPR) ，则可相应计算出FNR，然后在代价平面上绘制一条从(0，FPR) 到(1，FNR) 的线段，线段下的面积即表示了该条件下的期望总体代价；如此将ROC 曲线土的每个点转化为代价平面上的一条线段，然后取所有线段的下界，围成的面积即为在所有条件下学习器的期望总体代价，如图所示：</p>
<p><img src="https://i.loli.net/2018/10/17/5bc71ed716e0d.png" alt="20.png"></p>
<p>在此模型的性能度量方法就介绍完了，以前一直以为均方误差和精准度就可以了，现在才发现天空如此广阔~</p>
]]></content>
      <categories>
        <category>AI</category>
        <category>note</category>
      </categories>
      <tags>
        <tag>ML</tag>
      </tags>
  </entry>
  <entry>
    <title>西瓜书2.6 2.7</title>
    <url>/2023/06/21/MachineLearning/Machine-learning-learning-notes-master/%E5%91%A8%E5%BF%97%E5%8D%8E%E3%80%8AMachine%20Learning%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(3)--%E5%81%87%E8%AE%BE%E6%A3%80%E9%AA%8C&amp;%E6%96%B9%E5%B7%AE&amp;%E5%81%8F%E5%B7%AE/</url>
    <content><![CDATA[<p>在上两篇中，我们介绍了多种常见的评估方法和性能度量标准，这样我们就可以根据数据集以及模型任务的特征，选择出最合适的评估和性能度量方法来计算出学习器的“测试误差“。但由于“测试误差”受到很多因素的影响，例如：算法随机性(例如常见的K-Means)或测试集本身的选择，使得同一模型每次得到的结果不尽相同，同时测试误差是作为泛化误差的近似，并不能代表学习器真实的泛化性能，那如何对单个或多个学习器在不同或相同测试集上的性能度量结果做比较呢？这就是比较检验。最后偏差与方差是解释学习器泛化性能的一种重要工具。本篇延续上一篇的内容，主要讨论了比较检验、方差与偏差。</p>
<p>##<strong>2.6 比较检验</strong></p>
<p>在比较学习器泛化性能的过程中，统计假设检验（hypothesis test）为学习器性能比较提供了重要依据，即若A在某测试集上的性能优于B，那A学习器比B好的把握有多大。 为方便论述，本篇中都是以“错误率”作为性能度量的标准。</p>
<p>###<strong>2.6.1 假设检验</strong></p>
<p>“假设”指的是对样本总体的分布或已知分布中某个参数值的一种猜想，例如：假设总体服从泊松分布，或假设正态总体的期望u&#x3D;u0。回到本篇中，我们可以通过测试获得测试错误率，但直观上测试错误率和泛化错误率相差不会太远，因此可以通过测试错误率来推测泛化错误率的分布，这就是一种假设检验。</p>
<p><img src="https://i.loli.net/2018/10/17/5bc7211aed8e3.png" alt="1.png"></p>
<p><img src="https://i.loli.net/2018/10/17/5bc7211a5817d.png" alt="2.png"></p>
<p><img src="https://i.loli.net/2018/10/17/5bc7211a336b5.png" alt="3.png"></p>
<p>###<strong>2.6.2 交叉验证t检验</strong></p>
<p><img src="https://i.loli.net/2018/10/17/5bc7211a68ef9.png" alt="4.png"></p>
<p>###<strong>2.6.3 McNemar检验</strong></p>
<p>MaNemar主要用于二分类问题，与成对t检验一样也是用于比较两个学习器的性能大小。主要思想是：若两学习器的性能相同，则A预测正确B预测错误数应等于B预测错误A预测正确数，即e01&#x3D;e10，且|e01-e10|服从N（1，e01+e10）分布。</p>
<p><img src="https://i.loli.net/2018/10/17/5bc7211a2c7f9.png" alt="5.png"></p>
<p>因此，如下所示的变量服从自由度为1的卡方分布，即服从标准正态分布N（0,1）的随机变量的平方和，下式只有一个变量，故自由度为1，检验的方法同上：做出假设–&gt;求出满足显著度的临界点–&gt;给出拒绝域–&gt;验证假设。</p>
<p><img src="https://i.loli.net/2018/10/17/5bc7211a34e96.png" alt="6.png"></p>
<p>###<strong>2.6.4 Friedman检验与Nemenyi后续检验</strong></p>
<p>上述的三种检验都只能在一组数据集上，F检验则可以在多组数据集进行多个学习器性能的比较，基本思想是在同一组数据集上，根据测试结果（例：测试错误率）对学习器的性能进行排序，赋予序值1,2,3…，相同则平分序值，如下图所示：</p>
<p><img src="https://i.loli.net/2018/10/17/5bc7211a2db45.png" alt="7.png"></p>
<p>若学习器的性能相同，则它们的平均序值应该相同，且第i个算法的平均序值ri服从正态分布N（（k+1）&#x2F;2，（k+1）(k-1)&#x2F;12），则有：</p>
<p><img src="https://i.loli.net/2018/10/17/5bc7211a45349.png" alt="8.png"></p>
<p><img src="https://i.loli.net/2018/10/17/5bc7211a2684c.png" alt="9.png"></p>
<p>服从自由度为k-1和(k-1)(N-1)的F分布。下面是F检验常用的临界值：</p>
<p><img src="https://i.loli.net/2018/10/17/5bc7211a7e3f0.png" alt="10.png"></p>
<p>若“H0：所有算法的性能相同”这个假设被拒绝，则需要进行后续检验，来得到具体的算法之间的差异。常用的就是Nemenyi后续检验。Nemenyi检验计算出平均序值差别的临界值域，下表是常用的qa值，若两个算法的平均序值差超出了临界值域CD，则相应的置信度1-α拒绝“两个算法性能相同”的假设。</p>
<p><img src="https://i.loli.net/2018/10/17/5bc722232932b.png" alt="11.png"></p>
<p><img src="https://i.loli.net/2018/10/17/5bc7222348519.png" alt="12.png"></p>
<p>##<strong>2.7 偏差与方差</strong></p>
<p>偏差-方差分解是解释学习器泛化性能的重要工具。在学习算法中，偏差指的是预测的期望值与真实值的偏差，方差则是每一次预测值与预测值得期望之间的差均方。实际上，偏差体现了学习器预测的准确度，而方差体现了学习器预测的稳定性。通过对泛化误差的进行分解，可以得到：</p>
<ul>
<li><strong>期望泛化误差&#x3D;方差+偏差</strong>	</li>
<li><strong>偏差刻画学习器的拟合能力</strong></li>
<li><strong>方差体现学习器的稳定性</strong></li>
</ul>
<p>易知：方差和偏差具有矛盾性，这就是常说的偏差-方差窘境（bias-variance dilamma），随着训练程度的提升，期望预测值与真实值之间的差异越来越小，即偏差越来越小，但是另一方面，随着训练程度加大，学习算法对数据集的波动越来越敏感，方差值越来越大。换句话说：在欠拟合时，偏差主导泛化误差，而训练到一定程度后，偏差越来越小，方差主导了泛化误差。因此训练也不要贪杯，适度辄止。</p>
<p><img src="https://i.loli.net/2018/10/17/5bc722234b09f.png" alt="13.png"></p>
]]></content>
      <categories>
        <category>AI</category>
        <category>note</category>
      </categories>
      <tags>
        <tag>ML</tag>
      </tags>
  </entry>
  <entry>
    <title>西瓜书</title>
    <url>/2023/06/21/MachineLearning/Machine-learning-learning-notes-master/%E5%91%A8%E5%BF%97%E5%8D%8E%E3%80%8AMachine%20Learning%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(5)--%E5%86%B3%E7%AD%96%E6%A0%91/</url>
    <content><![CDATA[<p>上篇主要介绍和讨论了线性模型。首先从最简单的最小二乘法开始，讨论输入属性有一个和多个的情形，接着通过广义线性模型延伸开来，将预测连续值的回归问题转化为分类问题，从而引入了对数几率回归，最后线性判别分析LDA将样本点进行投影，多分类问题实质上通过划分的方法转化为多个二分类问题进行求解。本篇将讨论另一种被广泛使用的分类算法–决策树（Decision Tree）。</p>
<p>#<strong>4、决策树</strong></p>
<p>##<strong>4.1 决策树基本概念</strong></p>
<p>顾名思义，决策树是基于树结构来进行决策的，在网上看到一个例子十分有趣，放在这里正好合适。现想象一位捉急的母亲想要给自己的女娃介绍一个男朋友，于是有了下面的对话：</p>
<hr>
<pre><code>  女儿：多大年纪了？
  母亲：26。
  女儿：长的帅不帅？
  母亲：挺帅的。
  女儿：收入高不？
  母亲：不算很高，中等情况。
  女儿：是公务员不？
  母亲：是，在税务局上班呢。
  女儿：那好，我去见见。
</code></pre>
<hr>
<p>这个女孩的挑剔过程就是一个典型的决策树，即相当于通过年龄、长相、收入和是否公务员将男童鞋分为两个类别：见和不见。假设这个女孩对男人的要求是：30岁以下、长相中等以上并且是高收入者或中等以上收入的公务员，那么使用下图就能很好地表示女孩的决策逻辑（即一颗决策树）。</p>
<p><img src="https://i.loli.net/2018/10/17/5bc728ec84a77.png" alt="1.png"></p>
<p>在上图的决策树中，决策过程的每一次判定都是对某一属性的“测试”，决策最终结论则对应最终的判定结果。一般一颗决策树包含：一个根节点、若干个内部节点和若干个叶子节点，易知：</p>
<pre><code>* 每个非叶节点表示一个特征属性测试。
* 每个分支代表这个特征属性在某个值域上的输出。
* 每个叶子节点存放一个类别。
* 每个节点包含的样本集合通过属性测试被划分到子节点中，根节点包含样本全集。
</code></pre>
<p>##<strong>4.2 决策树的构造</strong></p>
<p>决策树的构造是一个递归的过程，有三种情形会导致递归返回：(1) 当前结点包含的样本全属于同一类别，这时直接将该节点标记为叶节点，并设为相应的类别；(2) 当前属性集为空，或是所有样本在所有属性上取值相同，无法划分，这时将该节点标记为叶节点，并将其类别设为该节点所含样本最多的类别；(3) 当前结点包含的样本集合为空，不能划分，这时也将该节点标记为叶节点，并将其类别设为父节点中所含样本最多的类别。算法的基本流程如下图所示：</p>
<p><img src="https://i.loli.net/2018/10/17/5bc728ecc27fe.png" alt="2.png"></p>
<p>可以看出：决策树学习的关键在于如何选择划分属性，不同的划分属性得出不同的分支结构，从而影响整颗决策树的性能。属性划分的目标是让各个划分出来的子节点尽可能地“纯”，即属于同一类别。因此下面便是介绍量化纯度的具体方法，决策树最常用的算法有三种：ID3，C4.5和CART。</p>
<p>###<strong>4.2.1 ID3算法</strong></p>
<p>ID3算法使用信息增益为准则来选择划分属性，“信息熵”(information entropy)是度量样本结合纯度的常用指标，假定当前样本集合D中第k类样本所占比例为pk，则样本集合D的信息熵定义为：</p>
<p><img src="https://i.loli.net/2018/10/17/5bc728ec515a5.png" alt="3.png"></p>
<p>假定通过属性划分样本集D，产生了V个分支节点，v表示其中第v个分支节点，易知：分支节点包含的样本数越多，表示该分支节点的影响力越大。故可以计算出划分后相比原始数据集D获得的“信息增益”（information gain）。</p>
<p><img src="https://i.loli.net/2018/10/17/5bc728ec3e067.png" alt="4.png"></p>
<p>信息增益越大，表示使用该属性划分样本集D的效果越好，因此ID3算法在递归过程中，每次选择最大信息增益的属性作为当前的划分属性。</p>
<p>###<strong>4.2.2 C4.5算法</strong></p>
<p>ID3算法存在一个问题，就是偏向于取值数目较多的属性，例如：如果存在一个唯一标识，这样样本集D将会被划分为|D|个分支，每个分支只有一个样本，这样划分后的信息熵为零，十分纯净，但是对分类毫无用处。因此C4.5算法使用了“增益率”（gain ratio）来选择划分属性，来避免这个问题带来的困扰。首先使用ID3算法计算出信息增益高于平均水平的候选属性，接着C4.5计算这些候选属性的增益率，增益率定义为：</p>
<p><img src="https://i.loli.net/2018/10/17/5bc728ec69647.png" alt="5.png"></p>
<p>###<strong>4.2.3 CART算法</strong></p>
<p>CART决策树使用“基尼指数”（Gini index）来选择划分属性，基尼指数反映的是从样本集D中随机抽取两个样本，其类别标记不一致的概率，因此Gini(D)越小越好，基尼指数定义如下：</p>
<p><img src="https://i.loli.net/2018/10/17/5bc728ec5a2ff.png" alt="6.png"></p>
<p>进而，使用属性α划分后的基尼指数为：</p>
<p><img src="https://i.loli.net/2018/10/17/5bc728ec62eaf.png" alt="7.png"></p>
<p>##<strong>4.3 剪枝处理</strong></p>
<p>从决策树的构造流程中我们可以直观地看出：不管怎么样的训练集，决策树总是能很好地将各个类别分离开来，这时就会遇到之前提到过的问题：过拟合（overfitting），即太依赖于训练样本。剪枝（pruning）则是决策树算法对付过拟合的主要手段，剪枝的策略有两种如下：</p>
<pre><code>* 预剪枝（prepruning）：在构造的过程中先评估，再考虑是否分支。
* 后剪枝（post-pruning）：在构造好一颗完整的决策树后，自底向上，评估分支的必要性。
</code></pre>
<p>评估指的是性能度量，即决策树的泛化性能。之前提到：可以使用测试集作为学习器泛化性能的近似，因此可以将数据集划分为训练集和测试集。预剪枝表示在构造数的过程中，对一个节点考虑是否分支时，首先计算决策树不分支时在测试集上的性能，再计算分支之后的性能，若分支对性能没有提升，则选择不分支（即剪枝）。后剪枝则表示在构造好一颗完整的决策树后，从最下面的节点开始，考虑该节点分支对模型的性能是否有提升，若无则剪枝，即将该节点标记为叶子节点，类别标记为其包含样本最多的类别。</p>
<p><img src="https://i.loli.net/2018/10/17/5bc728ec80d34.png" alt="8.png"></p>
<p><img src="https://i.loli.net/2018/10/17/5bc728ec9e330.png" alt="9.png"></p>
<p><img src="https://i.loli.net/2018/10/17/5bc728ec9d497.png" alt="10.png"></p>
<p>上图分别表示不剪枝处理的决策树、预剪枝决策树和后剪枝决策树。预剪枝处理使得决策树的很多分支被剪掉，因此大大降低了训练时间开销，同时降低了过拟合的风险，但另一方面由于剪枝同时剪掉了当前节点后续子节点的分支，因此预剪枝“贪心”的本质阻止了分支的展开，在一定程度上带来了欠拟合的风险。而后剪枝则通常保留了更多的分支，因此采用后剪枝策略的决策树性能往往优于预剪枝，但其自底向上遍历了所有节点，并计算性能，训练时间开销相比预剪枝大大提升。</p>
<p>##<strong>4.4 连续值与缺失值处理</strong></p>
<p>对于连续值的属性，若每个取值作为一个分支则显得不可行，因此需要进行离散化处理，常用的方法为二分法，基本思想为：给定样本集D与连续属性α，二分法试图找到一个划分点t将样本集D在属性α上分为≤t与＞t。</p>
<pre><code>* 首先将α的所有取值按升序排列，所有相邻属性的均值作为候选划分点（n-1个，n为α所有的取值数目）。
* 计算每一个划分点划分集合D（即划分为两个分支）后的信息增益。
* 选择最大信息增益的划分点作为最优划分点。
</code></pre>
<p><img src="https://i.loli.net/2018/10/17/5bc72a0968fad.png" alt="11.png"></p>
<p>现实中常会遇到不完整的样本，即某些属性值缺失。有时若简单采取剔除，则会造成大量的信息浪费，因此在属性值缺失的情况下需要解决两个问题：（1）如何选择划分属性。（2）给定划分属性，若某样本在该属性上缺失值，如何划分到具体的分支上。假定为样本集中的每一个样本都赋予一个权重，根节点中的权重初始化为1，则定义：</p>
<p><img src="https://i.loli.net/2018/10/17/5bc72a098f3be.png" alt="12.png"></p>
<p>对于（1）：通过在样本集D中选取在属性α上没有缺失值的样本子集，计算在该样本子集上的信息增益，最终的信息增益等于该样本子集划分后信息增益乘以样本子集占样本集的比重。即：</p>
<p><img src="https://i.loli.net/2018/10/17/5bc72a096ccc3.png" alt="13.png"></p>
<p>对于（2）：若该样本子集在属性α上的值缺失，则将该样本以不同的权重（即每个分支所含样本比例）划入到所有分支节点中。该样本在分支节点中的权重变为：</p>
<p><img src="https://i.loli.net/2018/10/17/5bc72a093ed3c.png" alt="14.png"></p>
<p>​    </p>
]]></content>
      <categories>
        <category>AI</category>
        <category>note</category>
      </categories>
      <tags>
        <tag>ML</tag>
      </tags>
  </entry>
  <entry>
    <title>西瓜书3.1 3.2 3.3 3.4 3.5</title>
    <url>/2023/06/21/MachineLearning/Machine-learning-learning-notes-master/%E5%91%A8%E5%BF%97%E5%8D%8E%E3%80%8AMachine%20Learning%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(4)--%E7%BA%BF%E6%80%A7%E6%A8%A1%E5%9E%8B/</url>
    <content><![CDATA[<p>笔记的前一部分主要是对机器学习预备知识的概括，包括机器学习的定义&#x2F;术语、学习器性能的评估&#x2F;度量以及比较，本篇之后将主要对具体的学习算法进行理解总结，本篇则主要是第3章的内容–线性模型。</p>
<p>#<strong>3、线性模型</strong></p>
<p>谈及线性模型，其实我们很早就已经与它打过交道，还记得高中数学必修3课本中那个顽皮的“最小二乘法”吗？这就是线性模型的经典算法之一：根据给定的（x，y）点对，求出一条与这些点拟合效果最好的直线y&#x3D;ax+b，之前我们利用下面的公式便可以计算出拟合直线的系数a,b（3.1中给出了具体的计算过程），从而对于一个新的x，可以预测它所对应的y值。前面我们提到：在机器学习的术语中，当预测值为连续值时，称为“回归问题”，离散值时为“分类问题”。本篇先从线性回归任务开始，接着讨论分类和多分类问题。</p>
<p><img src="https://i.loli.net/2018/10/17/5bc722b068e48.png" alt="1.png"></p>
<p>##<strong>3.1 线性回归</strong></p>
<p>线性回归问题就是试图学到一个线性模型尽可能准确地预测新样本的输出值，例如：通过历年的人口数据预测2017年人口数量。在这类问题中，往往我们会先得到一系列的有标记数据，例如：2000–&gt;13亿…2016–&gt;15亿，这时输入的属性只有一个，即年份；也有输入多属性的情形，假设我们预测一个人的收入，这时输入的属性值就不止一个了，例如：（学历，年龄，性别，颜值，身高，体重）–&gt;15k。</p>
<p>有时这些输入的属性值并不能直接被我们的学习模型所用，需要进行相应的处理，对于连续值的属性，一般都可以被学习器所用，有时会根据具体的情形作相应的预处理，例如：归一化等；对于离散值的属性，可作下面的处理：</p>
<ul>
<li><p>若属性值之间存在“序关系”，则可以将其转化为连续值，例如：身高属性分为“高”“中等”“矮”，可转化为数值：{1， 0.5， 0}。</p>
</li>
<li><p>若属性值之间不存在“序关系”，则通常将其转化为向量的形式，例如：性别属性分为“男”“女”，可转化为二维向量：{（1，0），（0，1）}。</p>
</li>
</ul>
<p>（1）当输入属性只有一个的时候，就是最简单的情形，也就是我们高中时最熟悉的“最小二乘法”（Euclidean distance），首先计算出每个样本预测值与真实值之间的误差并求和，通过最小化均方误差MSE，使用求偏导等于零的方法计算出拟合直线y&#x3D;wx+b的两个参数w和b，计算过程如下图所示：</p>
<p><img src="https://i.loli.net/2018/10/17/5bc722b0ccec4.png" alt="2.png"></p>
<p>（2）当输入属性有多个的时候，例如对于一个样本有d个属性{（x1,x2…xd）,y}，则y&#x3D;wx+b需要写成：</p>
<p><img src="https://i.loli.net/2018/10/17/5bc72567b8bcd.png" alt="0.png"></p>
<p>通常对于多元问题，常常使用矩阵的形式来表示数据。在本问题中，将具有m个样本的数据集表示成矩阵X，将系数w与b合并成一个列向量，这样每个样本的预测值以及所有样本的均方误差最小化就可以写成下面的形式：</p>
<p><img src="https://i.loli.net/2018/10/17/5bc722b0ad8f7.png" alt="3.png"></p>
<p><img src="https://i.loli.net/2018/10/17/5bc722b0af652.png" alt="4.png"></p>
<p><img src="https://i.loli.net/2018/10/17/5bc722b090543.png" alt="5.png"></p>
<p>同样地，我们使用最小二乘法对w和b进行估计，令均方误差的求导等于0，需要注意的是，当一个矩阵的行列式不等于0时，我们才可能对其求逆，因此对于下式，我们需要考虑矩阵（X的转置*X）的行列式是否为0，若不为0，则可以求出其解，若为0，则需要使用其它的方法进行计算，书中提到了引入正则化，此处不进行深入。</p>
<p><img src="https://i.loli.net/2018/10/17/5bc722b0cde33.png" alt="6.png"></p>
<p>另一方面，有时像上面这种原始的线性回归可能并不能满足需求，例如：y值并不是线性变化，而是在指数尺度上变化。这时我们可以采用线性模型来逼近y的衍生物，例如lny，这时衍生的线性模型如下所示，实际上就是相当于将指数曲线投影在一条直线上，如下图所示：</p>
<p><img src="https://i.loli.net/2018/10/17/5bc722b103cbf.png" alt="7.png"></p>
<p>更一般地，考虑所有y的衍生物的情形，就得到了“广义的线性模型”（generalized linear model），其中，g（*）称为联系函数（link function）。</p>
<p><img src="https://i.loli.net/2018/10/17/5bc722b0a2841.png" alt="8.png"></p>
<p>##<strong>3.2 线性几率回归</strong></p>
<p>回归就是通过输入的属性值得到一个预测值，利用上述广义线性模型的特征，是否可以通过一个联系函数，将预测值转化为离散值从而进行分类呢？线性几率回归正是研究这样的问题。对数几率引入了一个对数几率函数（logistic function）,将预测值投影到0-1之间，从而将线性回归问题转化为二分类问题。</p>
<p><img src="https://i.loli.net/2018/10/17/5bc722b0c7748.png" alt="9.png"></p>
<p><img src="https://i.loli.net/2018/10/17/5bc722b0a655d.png" alt="10.png"></p>
<p>若将y看做样本为正例的概率，（1-y）看做样本为反例的概率，则上式实际上使用线性回归模型的预测结果器逼近真实标记的对数几率。因此这个模型称为“对数几率回归”（logistic regression），也有一些书籍称之为“逻辑回归”。下面使用最大似然估计的方法来计算出w和b两个参数的取值，下面只列出求解的思路，不列出具体的计算过程。</p>
<p><img src="https://i.loli.net/2018/10/17/5bc723b824f0c.png" alt="11.png"></p>
<p><img src="https://i.loli.net/2018/10/17/5bc723b817961.png" alt="12.png"></p>
<p>##<strong>3.3 线性判别分析</strong></p>
<p>线性判别分析（Linear Discriminant Analysis，简称LDA）,其基本思想是：将训练样本投影到一条直线上，使得同类的样例尽可能近，不同类的样例尽可能远。如图所示：</p>
<p><img src="https://i.loli.net/2018/10/17/5bc723b863ebb.png" alt="13.png"><img src="https://i.loli.net/2018/10/17/5bc723b85bfa9.png" alt="14.png"></p>
<p>想让同类样本点的投影点尽可能接近，不同类样本点投影之间尽可能远，即：让各类的协方差之和尽可能小，不用类之间中心的距离尽可能大。基于这样的考虑，LDA定义了两个散度矩阵。</p>
<ul>
<li>类内散度矩阵（within-class scatter matrix）</li>
</ul>
<p><img src="https://i.loli.net/2018/10/17/5bc723b8156e1.png" alt="15.png"></p>
<ul>
<li>类间散度矩阵(between-class scaltter matrix)</li>
</ul>
<p><img src="https://i.loli.net/2018/10/17/5bc723b7e9db3.png" alt="16.png"></p>
<p>因此得到了LDA的最大化目标：“广义瑞利商”（generalized Rayleigh quotient）。</p>
<p><img src="https://i.loli.net/2018/10/17/5bc723b7e8a61.png" alt="17.png"></p>
<p>从而分类问题转化为最优化求解w的问题，当求解出w后，对新的样本进行分类时，只需将该样本点投影到这条直线上，根据与各个类别的中心值进行比较，从而判定出新样本与哪个类别距离最近。求解w的方法如下所示，使用的方法为λ乘子。</p>
<p><img src="https://i.loli.net/2018/10/17/5bc723b83d5e0.png" alt="18.png"></p>
<p>若将w看做一个投影矩阵，类似PCA的思想，则LDA可将样本投影到N-1维空间（N为类簇数），投影的过程使用了类别信息（标记信息），因此LDA也常被视为一种经典的监督降维技术。<br>​<br>##<strong>3.4 多分类学习</strong></p>
<p>现实中我们经常遇到不只两个类别的分类问题，即多分类问题，在这种情形下，我们常常运用“拆分”的策略，通过多个二分类学习器来解决多分类问题，即将多分类问题拆解为多个二分类问题，训练出多个二分类学习器，最后将多个分类结果进行集成得出结论。最为经典的拆分策略有三种：“一对一”（OvO）、“一对其余”（OvR）和“多对多”（MvM），核心思想与示意图如下所示。</p>
<ul>
<li><p>OvO：给定数据集D，假定其中有N个真实类别，将这N个类别进行两两配对（一个正类&#x2F;一个反类），从而产生N（N-1）&#x2F;2个二分类学习器，在测试阶段，将新样本放入所有的二分类学习器中测试，得出N（N-1）个结果，最终通过投票产生最终的分类结果。</p>
</li>
<li><p>OvM：给定数据集D，假定其中有N个真实类别，每次取出一个类作为正类，剩余的所有类别作为一个新的反类，从而产生N个二分类学习器，在测试阶段，得出N个结果，若仅有一个学习器预测为正类，则对应的类标作为最终分类结果。</p>
</li>
<li><p>MvM：给定数据集D，假定其中有N个真实类别，每次取若干个类作为正类，若干个类作为反类（通过ECOC码给出，编码），若进行了M次划分，则生成了M个二分类学习器，在测试阶段（解码），得出M个结果组成一个新的码，最终通过计算海明&#x2F;欧式距离选择距离最小的类别作为最终分类结果。</p>
</li>
</ul>
<p><img src="https://i.loli.net/2018/10/17/5bc723b862bfb.png" alt="19.png"></p>
<p><img src="https://i.loli.net/2018/10/17/5bc723b8300d5.png" alt="20.png"></p>
<p>##<strong>3.5 类别不平衡问题</strong></p>
<p>类别不平衡（class-imbanlance）就是指分类问题中不同类别的训练样本相差悬殊的情况，例如正例有900个，而反例只有100个，这个时候我们就需要进行相应的处理来平衡这个问题。常见的做法有三种：</p>
<ol>
<li>在训练样本较多的类别中进行“欠采样”（undersampling）,比如从正例中采出100个，常见的算法有：EasyEnsemble。</li>
<li>在训练样本较少的类别中进行“过采样”（oversampling）,例如通过对反例中的数据进行插值，来产生额外的反例，常见的算法有SMOTE。</li>
<li>直接基于原数据集进行学习，对预测值进行“再缩放”处理。其中再缩放也是代价敏感学习的基础。<img src="https://i.loli.net/2018/10/17/5bc726fe87ae2.png" alt="21.png"></li>
</ol>
<p>​<br>​      </p>
]]></content>
      <categories>
        <category>AI</category>
        <category>note</category>
      </categories>
      <tags>
        <tag>ML</tag>
      </tags>
  </entry>
  <entry>
    <title>西瓜书</title>
    <url>/2023/06/21/MachineLearning/Machine-learning-learning-notes-master/%E5%91%A8%E5%BF%97%E5%8D%8E%E3%80%8AMachine%20Learning%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(6)--%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/</url>
    <content><![CDATA[<p>上篇主要讨论了决策树算法。首先从决策树的基本概念出发，引出决策树基于树形结构进行决策，进一步介绍了构造决策树的递归流程以及其递归终止条件，在递归的过程中，划分属性的选择起到了关键作用，因此紧接着讨论了三种评估属性划分效果的经典算法，介绍了剪枝策略来解决原生决策树容易产生的过拟合问题，最后简述了属性连续值&#x2F;缺失值的处理方法。本篇将讨论现阶段十分热门的另一个经典监督学习算法–神经网络（neural network）。</p>
<p>#<strong>5、神经网络</strong></p>
<p>在机器学习中，神经网络一般指的是“神经网络学习”，是机器学习与神经网络两个学科的交叉部分。所谓神经网络，目前用得最广泛的一个定义是“神经网络是由具有适应性的简单单元组成的广泛并行互连的网络，它的组织能够模拟生物神经系统对真实世界物体所做出的交互反应”。</p>
<p>##<strong>5.1 神经元模型</strong></p>
<p>神经网络中最基本的单元是神经元模型（neuron）。在生物神经网络的原始机制中，每个神经元通常都有多个树突（dendrite），一个轴突（axon）和一个细胞体（cell body），树突短而多分支，轴突长而只有一个；在功能上，树突用于传入其它神经元传递的神经冲动，而轴突用于将神经冲动传出到其它神经元，当树突或细胞体传入的神经冲动使得神经元兴奋时，该神经元就会通过轴突向其它神经元传递兴奋。神经元的生物学结构如下图所示，不得不说高中的生化知识大学忘得可是真干净…</p>
<p><img src="https://i.loli.net/2018/10/17/5bc72cbb6cc11.png" alt="1.png"></p>
<p>一直沿用至今的“M-P神经元模型”正是对这一结构进行了抽象，也称“阈值逻辑单元“，其中树突对应于输入部分，每个神经元收到n个其他神经元传递过来的输入信号，这些信号通过带权重的连接传递给细胞体，这些权重又称为连接权（connection weight）。细胞体分为两部分，前一部分计算总输入值（即输入信号的加权和，或者说累积电平），后一部分先计算总输入值与该神经元阈值的差值，然后通过激活函数（activation function）的处理，产生输出从轴突传送给其它神经元。M-P神经元模型如下图所示：</p>
<p><img src="https://i.loli.net/2018/10/17/5bc72cbb7be44.png" alt="2.png"></p>
<p>与线性分类十分相似，神经元模型最理想的激活函数也是阶跃函数，即将神经元输入值与阈值的差值映射为输出值1或0，若差值大于零输出1，对应兴奋；若差值小于零则输出0，对应抑制。但阶跃函数不连续，不光滑，故在M-P神经元模型中，也采用Sigmoid函数来近似， Sigmoid函数将较大范围内变化的输入值挤压到 (0,1) 输出值范围内，所以也称为挤压函数（squashing function）。</p>
<p><img src="https://i.loli.net/2018/10/17/5bc72cbb40dc5.png" alt="3.png"></p>
<p>将多个神经元按一定的层次结构连接起来，就得到了神经网络。它是一种包含多个参数的模型，比方说10个神经元两两连接，则有100个参数需要学习（每个神经元有9个连接权以及1个阈值），若将每个神经元都看作一个函数，则整个神经网络就是由这些函数相互嵌套而成。</p>
<p>##<strong>5.2 感知机与多层网络</strong></p>
<p>感知机（Perceptron）是由两层神经元组成的一个简单模型，但只有输出层是M-P神经元，即只有输出层神经元进行激活函数处理，也称为功能神经元（functional neuron）；输入层只是接受外界信号（样本属性）并传递给输出层（输入层的神经元个数等于样本的属性数目），而没有激活函数。这样一来，感知机与之前线性模型中的对数几率回归的思想基本是一样的，都是通过对属性加权与另一个常数求和，再使用sigmoid函数将这个输出值压缩到0-1之间，从而解决分类问题。不同的是感知机的输出层应该可以有多个神经元，从而可以实现多分类问题，同时两个模型所用的参数估计方法十分不同。</p>
<p>给定训练集，则感知机的n+1个参数（n个权重+1个阈值）都可以通过学习得到。阈值Θ可以看作一个输入值固定为-1的哑结点的权重ωn+1，即假设有一个固定输入xn+1&#x3D;-1的输入层神经元，其对应的权重为ωn+1，这样就把权重和阈值统一为权重的学习了。简单感知机的结构如下图所示：</p>
<p><img src="https://i.loli.net/2018/10/17/5bc72cbb3fdf0.png" alt="4.png"></p>
<p>感知机权重的学习规则如下：对于训练样本（x，y），当该样本进入感知机学习后，会产生一个输出值，若该输出值与样本的真实标记不一致，则感知机会对权重进行调整，若激活函数为阶跃函数，则调整的方法为（基于梯度下降法）：</p>
<p><img src="https://i.loli.net/2018/10/17/5bc72cbb3ba63.png" alt="5.png"></p>
<p>其中 η∈（0，1）称为学习率，可以看出感知机是通过逐个样本输入来更新权重，首先设定好初始权重（一般为随机），逐个地输入样本数据，若输出值与真实标记相同则继续输入下一个样本，若不一致则更新权重，然后再重新逐个检验，直到每个样本数据的输出值都与真实标记相同。容易看出：感知机模型总是能将训练数据的每一个样本都预测正确，和决策树模型总是能将所有训练数据都分开一样，感知机模型很容易产生过拟合问题。</p>
<p>由于感知机模型只有一层功能神经元，因此其功能十分有限，只能处理线性可分的问题，对于这类问题，感知机的学习过程一定会收敛（converge），因此总是可以求出适当的权值。但是对于像书上提到的异或问题，只通过一层功能神经元往往不能解决，因此要解决非线性可分问题，需要考虑使用多层功能神经元，即神经网络。多层神经网络的拓扑结构如下图所示：</p>
<p><img src="https://i.loli.net/2018/10/17/5bc72cbb58ec6.png" alt="6.png"></p>
<p>在神经网络中，输入层与输出层之间的层称为隐含层或隐层（hidden layer），隐层和输出层的神经元都是具有激活函数的功能神经元。只需包含一个隐层便可以称为多层神经网络，常用的神经网络称为“多层前馈神经网络”（multi-layer feedforward neural network），该结构满足以下几个特点：</p>
<pre><code>* 每层神经元与下一层神经元之间完全互连
* 神经元之间不存在同层连接
* 神经元之间不存在跨层连接
</code></pre>
<p><img src="https://i.loli.net/2018/10/17/5bc72cbb47ff8.png" alt="7.png"></p>
<p>根据上面的特点可以得知：这里的“前馈”指的是网络拓扑结构中不存在环或回路，而不是指该网络只能向前传播而不能向后传播（下节中的BP神经网络正是基于前馈神经网络而增加了反馈调节机制）。神经网络的学习过程就是根据训练数据来调整神经元之间的“连接权”以及每个神经元的阈值，换句话说：神经网络所学习到的东西都蕴含在网络的连接权与阈值中。</p>
<p>##<strong>5.3 BP神经网络算法</strong></p>
<p>由上面可以得知：神经网络的学习主要蕴含在权重和阈值中，多层网络使用上面简单感知机的权重调整规则显然不够用了，BP神经网络算法即误差逆传播算法（error BackPropagation）正是为学习多层前馈神经网络而设计，BP神经网络算法是迄今为止最成功的的神经网络学习算法。</p>
<p>一般而言，只需包含一个足够多神经元的隐层，就能以任意精度逼近任意复杂度的连续函数[Hornik et al.,1989]，故下面以训练单隐层的前馈神经网络为例，介绍BP神经网络的算法思想。</p>
<p><img src="https://i.loli.net/2018/10/17/5bc72cbb92ff5.png" alt="8.png"></p>
<p>上图为一个单隐层前馈神经网络的拓扑结构，BP神经网络算法也使用梯度下降法（gradient descent），以单个样本的均方误差的负梯度方向对权重进行调节。可以看出：BP算法首先将误差反向传播给隐层神经元，调节隐层到输出层的连接权重与输出层神经元的阈值；接着根据隐含层神经元的均方误差，来调节输入层到隐含层的连接权值与隐含层神经元的阈值。BP算法基本的推导过程与感知机的推导过程原理是相同的，下面给出调整隐含层到输出层的权重调整规则的推导过程：</p>
<p><img src="https://i.loli.net/2018/10/17/5bc72cbb86229.png" alt="9.png"></p>
<p>学习率η∈（0，1）控制着沿反梯度方向下降的步长，若步长太大则下降太快容易产生震荡，若步长太小则收敛速度太慢，一般地常把η设置为0.1，有时更新权重时会将输出层与隐含层设置为不同的学习率。BP算法的基本流程如下所示：</p>
<p><img src="https://i.loli.net/2018/10/17/5bc72cbb59e99.png" alt="10.png"></p>
<p>BP算法的更新规则是基于每个样本的预测值与真实类标的均方误差来进行权值调节，即BP算法每次更新只针对于单个样例。需要注意的是：BP算法的最终目标是要最小化整个训练集D上的累积误差，即：</p>
<p><img src="https://i.loli.net/2018/10/17/5bc72ce222a96.png" alt="11.png"></p>
<p>如果基于累积误差最小化的更新规则，则得到了累积误差逆传播算法（accumulated error backpropagation），即每次读取全部的数据集一遍，进行一轮学习，从而基于当前的累积误差进行权值调整，因此参数更新的频率相比标准BP算法低了很多，但在很多任务中，尤其是在数据量很大的时候，往往标准BP算法会获得较好的结果。另外对于如何设置隐层神经元个数的问题，至今仍然没有好的解决方案，常使用“试错法”进行调整。</p>
<p>前面提到，BP神经网络强大的学习能力常常容易造成过拟合问题，有以下两种策略来缓解BP网络的过拟合问题：</p>
<ul>
<li>早停：将数据分为训练集与测试集，训练集用于学习，测试集用于评估性能，若在训练过程中，训练集的累积误差降低，而测试集的累积误差升高，则停止训练。</li>
<li>引入正则化（regularization）：基本思想是在累积误差函数中增加一个用于描述网络复杂度的部分，例如所有权值与阈值的平方和，其中λ∈（0,1）用于对累积经验误差与网络复杂度这两项进行折中，常通过交叉验证法来估计。</li>
</ul>
<p><img src="https://i.loli.net/2018/10/17/5bc72ce227ff1.png" alt="12.png"></p>
<p>##<strong>5.4 全局最小与局部最小</strong></p>
<p>模型学习的过程实质上就是一个寻找最优参数的过程，例如BP算法试图通过最速下降来寻找使得累积经验误差最小的权值与阈值，在谈到最优时，一般会提到局部极小（local minimum）和全局最小（global minimum）。</p>
<pre><code>* 局部极小解：参数空间中的某个点，其邻域点的误差函数值均不小于该点的误差函数值。
* 全局最小解：参数空间中的某个点，所有其他点的误差函数值均不小于该点的误差函数值。
</code></pre>
<p><img src="https://i.loli.net/2018/10/17/5bc72ce2803dc.png" alt="13.png"></p>
<p>要成为局部极小点，只要满足该点在参数空间中的梯度为零。局部极小可以有多个，而全局最小只有一个。全局最小一定是局部极小，但局部最小却不一定是全局最小。显然在很多机器学习算法中，都试图找到目标函数的全局最小。梯度下降法的主要思想就是沿着负梯度方向去搜索最优解，负梯度方向是函数值下降最快的方向，若迭代到某处的梯度为0，则表示达到一个局部最小，参数更新停止。因此在现实任务中，通常使用以下策略尽可能地去接近全局最小。</p>
<pre><code>* 以多组不同参数值初始化多个神经网络，按标准方法训练，迭代停止后，取其中误差最小的解作为最终参数。
* 使用“模拟退火”技术，这里不做具体介绍。
* 使用随机梯度下降，即在计算梯度时加入了随机因素，使得在局部最小时，计算的梯度仍可能不为0，从而迭代可以继续进行。
</code></pre>
<p>##<strong>5.5 深度学习</strong></p>
<p>理论上，参数越多，模型复杂度就越高，容量（capability）就越大，从而能完成更复杂的学习任务。深度学习（deep learning）正是一种极其复杂而强大的模型。</p>
<p>怎么增大模型复杂度呢？两个办法，一是增加隐层的数目，二是增加隐层神经元的数目。前者更有效一些，因为它不仅增加了功能神经元的数量，还增加了激活函数嵌套的层数。但是对于多隐层神经网络，经典算法如标准BP算法往往会在误差逆传播时发散（diverge），无法收敛达到稳定状态。</p>
<p>那要怎么有效地训练多隐层神经网络呢？一般来说有以下两种方法：</p>
<ul>
<li><p>无监督逐层训练（unsupervised layer-wise training）：每次训练一层隐节点，把上一层隐节点的输出当作输入来训练，本层隐结点训练好后，输出再作为下一层的输入来训练，这称为预训练（pre-training）。全部预训练完成后，再对整个网络进行微调（fine-tuning）训练。一个典型例子就是深度信念网络（deep belief network，简称DBN）。这种做法其实可以视为把大量的参数进行分组，先找出每组较好的设置，再基于这些局部最优的结果来训练全局最优。</p>
</li>
<li><p>权共享（weight sharing）：令同一层神经元使用完全相同的连接权，典型的例子是卷积神经网络（Convolutional Neural Network，简称CNN）。这样做可以大大减少需要训练的参数数目。</p>
</li>
</ul>
<p><img src="https://i.loli.net/2018/10/17/5bc72ce28d756.png" alt="14.png"></p>
<p>深度学习可以理解为一种特征学习（feature learning）或者表示学习（representation learning），无论是DBN还是CNN，都是通过多个隐层来把与输出目标联系不大的初始输入转化为与输出目标更加密切的表示，使原来只通过单层映射难以完成的任务变为可能。即通过多层处理，逐渐将初始的“低层”特征表示转化为“高层”特征表示，从而使得最后可以用简单的模型来完成复杂的学习任务。</p>
<p>传统任务中，样本的特征需要人类专家来设计，这称为特征工程（feature engineering）。特征好坏对泛化性能有至关重要的影响。而深度学习为全自动数据分析带来了可能，可以自动产生更好的特征。</p>
]]></content>
      <categories>
        <category>AI</category>
        <category>note</category>
      </categories>
      <tags>
        <tag>ML</tag>
      </tags>
  </entry>
  <entry>
    <title>西瓜书</title>
    <url>/2023/06/21/MachineLearning/Machine-learning-learning-notes-master/%E5%91%A8%E5%BF%97%E5%8D%8E%E3%80%8AMachine%20Learning%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(8)--%E8%B4%9D%E5%8F%B6%E6%96%AF%E5%88%86%E7%B1%BB%E5%99%A8/</url>
    <content><![CDATA[<p>上篇主要介绍和讨论了支持向量机。从最初的分类函数，通过最大化分类间隔，max(1&#x2F;||w||)，min(1&#x2F;2||w||^2)，凸二次规划，朗格朗日函数，对偶问题，一直到最后的SMO算法求解，都为寻找一个最优解。接着引入核函数将低维空间映射到高维特征空间，解决了非线性可分的情形。最后介绍了软间隔支持向量机，解决了outlier挤歪超平面的问题。本篇将讨论一个经典的统计学习算法–<strong>贝叶斯分类器</strong>。</p>
<p>#<strong>7、贝叶斯分类器</strong></p>
<p>贝叶斯分类器是一种概率框架下的统计学习分类器，对分类任务而言，假设在相关概率都已知的情况下，贝叶斯分类器考虑如何基于这些概率为样本判定最优的类标。在开始介绍贝叶斯决策论之前，我们首先来回顾下概率论委员会常委–贝叶斯公式。</p>
<p><img src="https://i.loli.net/2018/10/18/5bc83fd7a2575.png" alt="1.png"></p>
<p>##<strong>7.1 贝叶斯决策论</strong></p>
<p>若将上述定义中样本空间的划分Bi看做为类标，A看做为一个新的样本，则很容易将条件概率理解为样本A是类别Bi的概率。在机器学习训练模型的过程中，往往我们都试图去优化一个风险函数，因此在概率框架下我们也可以为贝叶斯定义“<strong>条件风险</strong>”（conditional risk）。</p>
<p><img src="https://i.loli.net/2018/10/18/5bc83fd15db94.png" alt="2.png"></p>
<p>我们的任务就是寻找一个判定准则最小化所有样本的条件风险总和，因此就有了<strong>贝叶斯判定准则</strong>（Bayes decision rule）:为最小化总体风险，只需在每个样本上选择那个使得条件风险最小的类标。</p>
<p><img src="https://i.loli.net/2018/10/18/5bc83fd308600.png" alt="3.png"></p>
<p>若损失函数λ取0-1损失，则有：</p>
<p><img src="https://i.loli.net/2018/10/18/5bc83fd37c502.png" alt="4.png"></p>
<p>即对于每个样本x，选择其后验概率P（c | x）最大所对应的类标，能使得总体风险函数最小，从而将原问题转化为估计后验概率P（c | x）。一般这里有两种策略来对后验概率进行估计：</p>
<pre><code>* 判别式模型：直接对 P（c | x）进行建模求解。例我们前面所介绍的决策树、神经网络、SVM都是属于判别式模型。
* 生成式模型：通过先对联合分布P（x,c）建模，从而进一步求解 P（c | x）。
</code></pre>
<p>贝叶斯分类器就属于生成式模型，基于贝叶斯公式对后验概率P（c | x） 进行一项神奇的变换，巴拉拉能量…. P（c | x）变身：</p>
<p><img src="https://i.loli.net/2018/10/18/5bc83fd501ad3.png" alt="5.png"></p>
<p>对于给定的样本x，P（x）与类标无关，P（c）称为类先验概率，p（x | c ）称为类条件概率。这时估计后验概率P（c | x）就变成为估计类先验概率和类条件概率的问题。对于先验概率和后验概率，在看这章之前也是模糊了我好久，这里普及一下它们的基本概念。</p>
<pre><code>* 先验概率： 根据以往经验和分析得到的概率。
* 后验概率：后验概率是基于新的信息，修正原来的先验概率后所获得的更接近实际情况的概率估计。
</code></pre>
<p>实际上先验概率就是在没有任何结果出来的情况下估计的概率，而后验概率则是在有一定依据后的重新估计，直观意义上后验概率就是条件概率。下面直接上Wiki上的一个例子，简单粗暴快速完事…</p>
<p><img src="https://i.loli.net/2018/10/18/5bc83fd799610.png" alt="6.png"></p>
<p>回归正题，对于类先验概率P（c），p（c）就是样本空间中各类样本所占的比例，根据大数定理（当样本足够多时，频率趋于稳定等于其概率），这样当训练样本充足时，p(c)可以使用各类出现的频率来代替。因此只剩下类条件概率p（x | c ），它表达的意思是在类别c中出现x的概率，它涉及到属性的联合概率问题，若只有一个离散属性还好，当属性多时采用频率估计起来就十分困难，因此这里一般采用极大似然法进行估计。</p>
<p>##<strong>7.2 极大似然法</strong></p>
<p>极大似然估计（Maximum Likelihood Estimation，简称MLE），是一种根据数据采样来估计概率分布的经典方法。常用的策略是先假定总体具有某种确定的概率分布，再基于训练样本对概率分布的参数进行估计。运用到类条件概率p（x | c ）中，假设p（x | c ）服从一个参数为θ的分布，问题就变为根据已知的训练样本来估计θ。极大似然法的核心思想就是：估计出的参数使得已知样本出现的概率最大，即使得训练数据的似然最大。</p>
<p><img src="https://i.loli.net/2018/10/18/5bc83fd70fb73.png" alt="7.png"></p>
<p>所以，贝叶斯分类器的训练过程就是参数估计。总结最大似然法估计参数的过程，一般分为以下四个步骤：</p>
<pre><code>* 1.写出似然函数；
* 2.对似然函数取对数，并整理；
* 3.求导数，令偏导数为0，得到似然方程组；
* 4.解似然方程组，得到所有参数即为所求。
</code></pre>
<p>例如：假设样本属性都是连续值，p（x | c ）服从一个多维高斯分布，则通过MLE计算出的参数刚好分别为：</p>
<p><img src="https://i.loli.net/2018/10/18/5bc83fd705729.png" alt="8.png"></p>
<p>上述结果看起来十分合乎实际，但是采用最大似然法估计参数的效果很大程度上依赖于作出的假设是否合理，是否符合潜在的真实数据分布。这就需要大量的经验知识，搞统计越来越值钱也是这个道理，大牛们掐指一算比我们搬砖几天更有效果。</p>
<p>##<strong>7.3 朴素贝叶斯分类器</strong></p>
<p>不难看出：原始的贝叶斯分类器最大的问题在于联合概率密度函数的估计，首先需要根据经验来假设联合概率分布，其次当属性很多时，训练样本往往覆盖不够，参数的估计会出现很大的偏差。为了避免这个问题，朴素贝叶斯分类器（naive Bayes classifier）采用了“属性条件独立性假设”，即样本数据的所有属性之间相互独立。这样类条件概率p（x | c ）可以改写为：</p>
<p><img src="https://i.loli.net/2018/10/18/5bc83fd55e102.png" alt="9.png"></p>
<p>这样，为每个样本估计类条件概率变成为每个样本的每个属性估计类条件概率。</p>
<p><img src="https://i.loli.net/2018/10/18/5bc83fd6678cd.png" alt="10.png"></p>
<p>相比原始贝叶斯分类器，朴素贝叶斯分类器基于单个的属性计算类条件概率更加容易操作，需要注意的是：若某个属性值在训练集中和某个类别没有一起出现过，这样会抹掉其它的属性信息，因为该样本的类条件概率被计算为0。因此在估计概率值时，常常用进行平滑（smoothing）处理，拉普拉斯修正（Laplacian correction）就是其中的一种经典方法，具体计算方法如下：</p>
<p><img src="https://i.loli.net/2018/10/18/5bc83fe54aaed.png" alt="11.png"></p>
<p>当训练集越大时，拉普拉斯修正引入的影响越来越小。对于贝叶斯分类器，模型的训练就是参数估计，因此可以事先将所有的概率储存好，当有新样本需要判定时，直接查表计算即可。</p>
<p>针对朴素贝叶斯，人们觉得它too sample，sometimes too naive！因此又提出了半朴素的贝叶斯分类器，具体有SPODE、TAN、贝叶斯网络等来刻画属性之间的依赖关系，此处不进行深入，等哪天和贝叶斯邂逅了再回来讨论。在此鼎鼎大名的贝叶斯介绍完毕，下一篇将介绍这一章剩下的内容–EM算法，朴素贝叶斯和EM算法同为数据挖掘的十大经典算法，想着还是单独介绍吧~</p>
]]></content>
      <categories>
        <category>AI</category>
        <category>note</category>
      </categories>
      <tags>
        <tag>ML</tag>
      </tags>
  </entry>
  <entry>
    <title>西瓜书</title>
    <url>/2023/06/21/MachineLearning/Machine-learning-learning-notes-master/%E5%91%A8%E5%BF%97%E5%8D%8E%E3%80%8AMachine%20Learning%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(9)--EM%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<p>上篇主要介绍了贝叶斯分类器，从贝叶斯公式到贝叶斯决策论，再到通过极大似然法估计类条件概率，贝叶斯分类器的训练就是参数估计的过程。朴素贝叶斯则是“属性条件独立性假设”下的特例，它避免了假设属性联合分布过于经验性和训练集不足引起参数估计较大偏差两个大问题，最后介绍的拉普拉斯修正将概率值进行平滑处理。本篇将介绍另一个当选为数据挖掘十大算法之一的<strong>EM算法</strong>。</p>
<p>#<strong>8、EM算法</strong></p>
<p>EM（Expectation-Maximization）算法是一种常用的估计参数隐变量的利器，也称为“期望最大算法”，是数据挖掘的十大经典算法之一。EM算法主要应用于训练集样本不完整即存在隐变量时的情形（例如某个属性值未知），通过其独特的“两步走”策略能较好地估计出隐变量的值。</p>
<p>##<strong>8.1 EM算法思想</strong></p>
<p>EM是一种迭代式的方法，它的基本思想就是：若样本服从的分布参数θ已知，则可以根据已观测到的训练样本推断出隐变量Z的期望值（E步），若Z的值已知则运用最大似然法估计出新的θ值（M步）。重复这个过程直到Z和θ值不再发生变化。</p>
<p>简单来讲：假设我们想估计A和B这两个参数，在开始状态下二者都是未知的，但如果知道了A的信息就可以得到B的信息，反过来知道了B也就得到了A。可以考虑首先赋予A某种初值，以此得到B的估计值，然后从B的当前值出发，重新估计A的取值，这个过程一直持续到收敛为止。</p>
<p><img src="https://i.loli.net/2018/10/18/5bc843bf53eb2.png" alt="1.png"></p>
<p>现在再来回想聚类的代表算法K-Means：【首先随机选择类中心&#x3D;&gt;将样本点划分到类簇中&#x3D;&gt;重新计算类中心&#x3D;&gt;不断迭代直至收敛】，不难发现这个过程和EM迭代的方法极其相似，事实上，若将样本的类别看做为“隐变量”（latent variable）Z，类中心看作样本的分布参数θ，K-Means就是通过EM算法来进行迭代的，与我们这里不同的是，K-Means的目标是最小化样本点到其对应类中心的距离和，上述为极大化似然函数。</p>
<p>##<strong>8.2 EM算法数学推导</strong></p>
<p>在上篇极大似然法中，当样本属性值都已知时，我们很容易通过极大化对数似然，接着对每个参数求偏导计算出参数的值。但当存在隐变量时，就无法直接求解，此时我们通常最大化已观察数据的对数“边际似然”（marginal likelihood）。</p>
<p><img src="https://i.loli.net/2018/10/18/5bc843bfd84d2.png" alt="2.png"></p>
<p>这时候，通过边缘似然将隐变量Z引入进来，对于参数估计，现在与最大似然不同的只是似然函数式中多了一个未知的变量Z，也就是说我们的目标是找到适合的θ和Z让L(θ)最大，这样我们也可以分别对未知的θ和Z求偏导，再令其等于0。</p>
<p>然而观察上式可以发现，和的对数（ln(x1+x2+x3)）求导十分复杂，那能否通过变换上式得到一种求导简单的新表达式呢？这时候 Jensen不等式就派上用场了，先回顾一下高等数学凸函数的内容：</p>
<p><strong>Jensen’s inequality</strong>：过一个凸函数上任意两点所作割线一定在这两点间的函数图象的上方。理解起来也十分简单，对于凸函数f(x)’’&gt;0，即曲线的变化率是越来越大单调递增的，所以函数越到后面增长越厉害，这样在一个区间下，函数的均值就会大一些了。</p>
<p><img src="https://i.loli.net/2018/10/18/5bc843c064c72.png" alt="3.png"></p>
<p>因为ln(*)函数为凹函数，故可以将上式“和的对数”变为“对数的和”，这样就很容易求导了。</p>
<p><img src="https://i.loli.net/2018/10/18/5bc843c3490ad.png" alt="4.png"></p>
<p>接着求解Qi和θ：首先固定θ（初始值），通过求解Qi使得J（θ，Q）在θ处与L（θ）相等，即求出L（θ）的下界；然后再固定Qi，调整θ，最大化下界J（θ，Q）。不断重复两个步骤直到稳定。通过jensen不等式的性质，Qi的计算公式实际上就是后验概率：</p>
<p><img src="https://i.loli.net/2018/10/18/5bc843c21276c.png" alt="5.png"></p>
<p>通过数学公式的推导，简单来理解这一过程：固定θ计算Q的过程就是在建立L（θ）的下界，即通过jenson不等式得到的下界（E步）；固定Q计算θ则是使得下界极大化（M步），从而不断推高边缘似然L（θ）。从而循序渐进地计算出L（θ）取得极大值时隐变量Z的估计值。</p>
<p>EM算法也可以看作一种“坐标下降法”，首先固定一个值，对另外一个值求极值，不断重复直到收敛。这时候也许大家就有疑问，问什么不直接这两个家伙求偏导用梯度下降呢？这时候就是坐标下降的优势，有些特殊的函数，例如曲线函数z&#x3D;y^2+x^2+x^2y+xy+…，无法直接求导，这时如果先固定其中的一个变量，再对另一个变量求极值，则变得可行。</p>
<p><img src="https://i.loli.net/2018/10/18/5bc843c34e7ff.png" alt="6.png"></p>
<p>##<strong>8.3 EM算法流程</strong></p>
<p>看完数学推导，算法的流程也就十分简单了，这里有两个版本，版本一来自西瓜书，周天使的介绍十分简洁；版本二来自于大牛的博客。结合着数学推导，自认为版本二更具有逻辑性，两者唯一的区别就在于版本二多出了红框的部分，这里我也没得到答案，欢迎骚扰讨论~</p>
<p><strong>版本一：</strong></p>
<p><img src="https://i.loli.net/2018/10/18/5bc843c0e19db.png" alt="7.png"></p>
<p><strong>版本二：</strong></p>
<p><img src="https://i.loli.net/2018/10/18/5bc843c34775b.png" alt="8.png"></p>
]]></content>
      <categories>
        <category>AI</category>
        <category>note</category>
      </categories>
      <tags>
        <tag>ML</tag>
      </tags>
  </entry>
  <entry>
    <title>西瓜书</title>
    <url>/2023/06/21/MachineLearning/Machine-learning-learning-notes-master/%E5%91%A8%E5%BF%97%E5%8D%8E%E3%80%8AMachine%20Learning%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(7)--%E6%94%AF%E6%8C%81%E5%90%91%E9%87%8F%E6%9C%BA/</url>
    <content><![CDATA[<p>上篇主要介绍了神经网络。首先从生物学神经元出发，引出了它的数学抽象模型–MP神经元以及由两层神经元组成的感知机模型，并基于梯度下降的方法描述了感知机模型的权值调整规则。由于简单的感知机不能处理线性不可分的情形，因此接着引入了含隐层的前馈型神经网络，BP神经网络则是其中最为成功的一种学习方法，它使用误差逆传播的方法来逐层调节连接权。最后简单介绍了局部&#x2F;全局最小以及目前十分火热的深度学习的概念。本篇围绕的核心则是曾经一度取代过神经网络的另一种监督学习算法–<strong>支持向量机</strong>（Support Vector Machine），简称<strong>SVM</strong>。</p>
<p>#<strong>6、支持向量机</strong></p>
<p>支持向量机是一种经典的二分类模型，基本模型定义为特征空间中最大间隔的线性分类器，其学习的优化目标便是间隔最大化，因此支持向量机本身可以转化为一个凸二次规划求解的问题。</p>
<p>##<strong>6.1 函数间隔与几何间隔</strong></p>
<p>对于二分类学习，假设现在的数据是线性可分的，这时分类学习最基本的想法就是找到一个合适的超平面，该超平面能够将不同类别的样本分开，类似二维平面使用ax+by+c&#x3D;0来表示，超平面实际上表示的就是高维的平面，如下图所示：</p>
<p><img src="https://i.loli.net/2018/10/17/5bc72f6a2ec8a.png" alt="1.png"></p>
<p>对数据点进行划分时，易知：当超平面距离与它最近的数据点的间隔越大，分类的鲁棒性越好，即当新的数据点加入时，超平面对这些点的适应性最强，出错的可能性最小。因此需要让所选择的超平面能够最大化这个间隔Gap（如下图所示）， 常用的间隔定义有两种，一种称之为函数间隔，一种为几何间隔，下面将分别介绍这两种间隔，并对SVM为什么会选用几何间隔做了一些阐述。</p>
<p><img src="https://i.loli.net/2018/10/17/5bc72f6a06d5a.png" alt="2.png"></p>
<p>###<strong>6.1.1 函数间隔</strong></p>
<p>在超平面w’x+b&#x3D;0确定的情况下，|w’x*+b|能够代表点x<em>距离超平面的远近，易知：当w’x</em>+b&gt;0时，表示x<em>在超平面的一侧（正类，类标为1），而当w’x</em>+b&lt;0时，则表示x<em>在超平面的另外一侧（负类，类别为-1），因此（w’x</em>+b）y* 的正负性恰能表示数据点x*是否被分类正确。于是便引出了<strong>函数间隔</strong>的定义（functional margin）:</p>
<p><img src="https://i.loli.net/2018/10/17/5bc72f690a14b.png" alt="3.png"></p>
<p>而超平面（w,b）关于所有样本点（Xi，Yi）的函数间隔最小值则为超平面在训练数据集T上的函数间隔：</p>
<p><img src="https://i.loli.net/2018/10/17/5bc72f690ac26.png" alt="4.png"></p>
<p>可以看出：这样定义的函数间隔在处理SVM上会有问题，当超平面的两个参数w和b同比例改变时，函数间隔也会跟着改变，但是实际上超平面还是原来的超平面，并没有变化。例如：w1x1+w2x2+w3x3+b&#x3D;0其实等价于2w1x1+2w2x2+2w3x3+2b&#x3D;0，但计算的函数间隔却翻了一倍。从而引出了能真正度量点到超平面距离的概念–几何间隔（geometrical margin）。</p>
<p>###<strong>6.1.2 几何间隔</strong></p>
<p><strong>几何间隔</strong>代表的则是数据点到超平面的真实距离，对于超平面w’x+b&#x3D;0，w代表的是该超平面的法向量，设x<em>为超平面外一点x在法向量w方向上的投影点，x与超平面的距离为r，则有x</em>&#x3D;x-r(w&#x2F;||w||)，又x<em>在超平面上，即w’x</em>+b&#x3D;0，代入即可得：</p>
<p><img src="https://i.loli.net/2018/10/17/5bc72f697d499.png" alt="5.png"></p>
<p>为了得到r的绝对值，令r呈上其对应的类别y，即可得到几何间隔的定义：</p>
<p><img src="https://i.loli.net/2018/10/17/5bc72f696fd10.png" alt="6.png"></p>
<p>从上述函数间隔与几何间隔的定义可以看出：实质上函数间隔就是|w’x+b|，而几何间隔就是点到超平面的距离。</p>
<p>##<strong>6.2 最大间隔与支持向量</strong></p>
<p>通过前面的分析可知：函数间隔不适合用来最大化间隔，因此这里我们要找的最大间隔指的是几何间隔，于是最大间隔分类器的目标函数定义为：</p>
<p><img src="https://i.loli.net/2018/10/17/5bc72f69af163.png" alt="7.png"></p>
<p>一般地，我们令r^为1（这样做的目的是为了方便推导和目标函数的优化），从而上述目标函数转化为：</p>
<p><img src="https://i.loli.net/2018/10/17/5bc72f697bb1d.png" alt="8.png"></p>
<p>对于y(w’x+b)&#x3D;1的数据点，即下图中位于w’x+b&#x3D;1或w’x+b&#x3D;-1上的数据点，我们称之为<strong>支持向量</strong>（support vector），易知：对于所有的支持向量，它们恰好满足y*(w’x*+b)&#x3D;1，而所有不是支持向量的点，有y*(w’x*+b)&gt;1。</p>
<p><img src="https://i.loli.net/2018/10/17/5bc72f6a838c4.png" alt="9.png"></p>
<p>##<strong>6.3 从原始优化问题到对偶问题</strong></p>
<p>对于上述得到的目标函数，求1&#x2F;||w||的最大值相当于求||w||^2的最小值，因此很容易将原来的目标函数转化为：</p>
<p><img src="https://i.loli.net/2018/10/17/5bc72f6978cbb.png" alt="10.png"></p>
<p>即变为了一个带约束的凸二次规划问题，按书上所说可以使用现成的优化计算包（QP优化包）求解，但由于SVM的特殊性，一般我们将原问题变换为它的<strong>对偶问题</strong>，接着再对其对偶问题进行求解。为什么通过对偶问题进行求解，有下面两个原因：</p>
<pre><code>* 一是因为使用对偶问题更容易求解；
* 二是因为通过对偶问题求解出现了向量内积的形式，从而能更加自然地引出核函数。
</code></pre>
<p>对偶问题，顾名思义，可以理解成优化等价的问题，更一般地，是将一个原始目标函数的最小化转化为它的对偶函数最大化的问题。对于当前的优化问题，首先我们写出它的朗格朗日函数：</p>
<p><img src="https://i.loli.net/2018/10/17/5bc72f9332be7.png" alt="11.png"></p>
<p>上式很容易验证：当其中有一个约束条件不满足时，L的最大值为 ∞（只需令其对应的α为 ∞即可）；当所有约束条件都满足时，L的最大值为1&#x2F;2||w||^2（此时令所有的α为0），因此实际上原问题等价于：</p>
<p><img src="https://i.loli.net/2018/10/17/5bc72f93321c5.png" alt="12.png"></p>
<p>由于这个的求解问题不好做，因此一般我们将最小和最大的位置交换一下（需满足KKT条件） ，变成原问题的对偶问题：</p>
<p><img src="https://i.loli.net/2018/10/17/5bc72f9330967.png" alt="13.png"></p>
<p>这样就将原问题的求最小变成了对偶问题求最大（用对偶这个词还是很形象），接下来便可以先求L对w和b的极小，再求L对α的极大。</p>
<p>（1）首先求L对w和b的极小，分别求L关于w和b的偏导，可以得出：</p>
<p><img src="https://i.loli.net/2018/10/17/5bc72f9333e66.png" alt="14.png"></p>
<p>将上述结果代入L得到：</p>
<p><img src="https://i.loli.net/2018/10/17/5bc72f935ae21.png" alt="15.png"></p>
<p>（2）接着L关于α极大求解α（通过SMO算法求解，此处不做深入）。</p>
<p><img src="https://i.loli.net/2018/10/17/5bc72f9338a9d.png" alt="16.png"></p>
<p>（3）最后便可以根据求解出的α，计算出w和b，从而得到分类超平面函数。</p>
<p><img src="https://i.loli.net/2018/10/17/5bc72f93419ca.png" alt="17.png"></p>
<p>在对新的点进行预测时，实际上就是将数据点x*代入分类函数f(x)&#x3D;w’x+b中，若f(x)&gt;0，则为正类，f(x)&lt;0，则为负类，根据前面推导得出的w与b，分类函数如下所示，此时便出现了上面所提到的内积形式。</p>
<p><img src="https://i.loli.net/2018/10/17/5bc72f9353166.png" alt="18.png"></p>
<p>这里实际上只需计算新样本与支持向量的内积，因为对于非支持向量的数据点，其对应的拉格朗日乘子一定为0，根据最优化理论（K-T条件），对于不等式约束y(w’x+b)-1≥0，满足：</p>
<p><img src="https://i.loli.net/2018/10/17/5bc72f933c947.png" alt="19.png">        </p>
<p>##<strong>6.4 核函数</strong></p>
<p>由于上述的超平面只能解决线性可分的问题，对于线性不可分的问题，例如：异或问题，我们需要使用核函数将其进行推广。一般地，解决线性不可分问题时，常常采用<strong>映射</strong>的方式，将低维原始空间映射到高维特征空间，使得数据集在高维空间中变得线性可分，从而再使用线性学习器分类。如果原始空间为有限维，即属性数有限，那么总是存在一个高维特征空间使得样本线性可分。若∅代表一个映射，则在特征空间中的划分函数变为：</p>
<p><img src="https://i.loli.net/2018/10/17/5bc72f934303e.png" alt="20.png"></p>
<p>按照同样的方法，先写出新目标函数的拉格朗日函数，接着写出其对偶问题，求L关于w和b的极大，最后运用SOM求解α。可以得出：</p>
<p>（1）原对偶问题变为：</p>
<p><img src="https://i.loli.net/2018/10/17/5bc730cc68b3b.png" alt="21.png"></p>
<p>（2）原分类函数变为：<br>​    <img src="https://i.loli.net/2018/10/17/5bc730cc1b673.png" alt="22.png"></p>
<p>求解的过程中，只涉及到了高维特征空间中的内积运算，由于特征空间的维数可能会非常大，例如：若原始空间为二维，映射后的特征空间为5维，若原始空间为三维，映射后的特征空间将是19维，之后甚至可能出现无穷维，根本无法进行内积运算了，此时便引出了<strong>核函数</strong>（Kernel）的概念。</p>
<p><img src="https://i.loli.net/2018/10/17/5bc730cc49adc.png" alt="23.png"></p>
<p>因此，核函数可以直接计算隐式映射到高维特征空间后的向量内积，而不需要显式地写出映射后的结果，它虽然完成了将特征从低维到高维的转换，但最终却是在低维空间中完成向量内积计算，与高维特征空间中的计算等效<strong>（低维计算，高维表现）</strong>，从而避免了直接在高维空间无法计算的问题。引入核函数后，原来的对偶问题与分类函数则变为：</p>
<p>（1）对偶问题：</p>
<p><img src="https://i.loli.net/2018/10/17/5bc730cc173b2.png" alt="24.png"></p>
<p>（2）分类函数：</p>
<p><img src="https://i.loli.net/2018/10/17/5bc730cc05959.png" alt="25.png"></p>
<p>因此，在线性不可分问题中，核函数的选择成了支持向量机的最大变数，若选择了不合适的核函数，则意味着将样本映射到了一个不合适的特征空间，则极可能导致性能不佳。同时，核函数需要满足以下这个必要条件：</p>
<p><img src="https://i.loli.net/2018/10/17/5bc730ccc468c.png" alt="26.png"></p>
<p>由于核函数的构造十分困难，通常我们都是从一些常用的核函数中选择，下面列出了几种常用的核函数：</p>
<p><img src="https://i.loli.net/2018/10/17/5bc730ccc541a.png" alt="27.png"></p>
<p>##<strong>6.5 软间隔支持向量机</strong></p>
<p>前面的讨论中，我们主要解决了两个问题：当数据线性可分时，直接使用最大间隔的超平面划分；当数据线性不可分时，则通过核函数将数据映射到高维特征空间，使之线性可分。然而在现实问题中，对于某些情形还是很难处理，例如数据中有<strong>噪声</strong>的情形，噪声数据（<strong>outlier</strong>）本身就偏离了正常位置，但是在前面的SVM模型中，我们要求所有的样本数据都必须满足约束，如果不要这些噪声数据还好，当加入这些outlier后导致划分超平面被挤歪了，如下图所示，对支持向量机的泛化性能造成很大的影响。</p>
<p><img src="https://i.loli.net/2018/10/17/5bc730ccce68e.png" alt="28.png"></p>
<p>为了解决这一问题，我们需要允许某一些数据点不满足约束，即可以在一定程度上偏移超平面，同时使得不满足约束的数据点尽可能少，这便引出了<strong>“软间隔”支持向量机</strong>的概念</p>
<pre><code>* 允许某些数据点不满足约束y(w&#39;x+b)≥1；
* 同时又使得不满足约束的样本尽可能少。
</code></pre>
<p>这样优化目标变为：</p>
<p><img src="https://i.loli.net/2018/10/17/5bc730cc6c9fe.png" alt="29.png"></p>
<p>如同阶跃函数，0&#x2F;1损失函数虽然表示效果最好，但是数学性质不佳。因此常用其它函数作为“替代损失函数”。</p>
<p><img src="https://i.loli.net/2018/10/17/5bc730cc5e5a9.png" alt="30.png"></p>
<p>支持向量机中的损失函数为<strong>hinge损失</strong>，引入<strong>“松弛变量”</strong>，目标函数与约束条件可以写为：</p>
<p><img src="https://i.loli.net/2018/10/17/5bc7317aa3411.png" alt="31.png"></p>
<p>其中C为一个参数，控制着目标函数与新引入正则项之间的权重，这样显然每个样本数据都有一个对应的松弛变量，用以表示该样本不满足约束的程度，将新的目标函数转化为拉格朗日函数得到：</p>
<p><img src="https://i.loli.net/2018/10/17/5bc7317a4c96e.png" alt="32.png"></p>
<p>按照与之前相同的方法，先让L求关于w，b以及松弛变量的极小，再使用SMO求出α，有：</p>
<p><img src="https://i.loli.net/2018/10/17/5bc7317a6dff2.png" alt="33.png"></p>
<p>将w代入L化简，便得到其对偶问题：</p>
<p><img src="https://i.loli.net/2018/10/17/5bc7317ab6646.png" alt="34.png"></p>
<p>将“软间隔”下产生的对偶问题与原对偶问题对比可以发现：新的对偶问题只是约束条件中的α多出了一个上限C，其它的完全相同，因此在引入核函数处理线性不可分问题时，便能使用与“硬间隔”支持向量机完全相同的方法。</p>
<p>—-在此SVM就介绍完毕。</p>
]]></content>
      <categories>
        <category>AI</category>
        <category>note</category>
      </categories>
      <tags>
        <tag>ML</tag>
      </tags>
  </entry>
  <entry>
    <title>西瓜书3  基础模型分类与选择（base GPT）</title>
    <url>/2023/06/23/MachineLearning/ChatGPT/%E6%A8%A1%E5%9E%8B%E5%88%9D%E6%AD%A5%E5%88%86%E7%B1%BB%E5%92%8C%E9%80%89%E6%8B%A9/</url>
    <content><![CDATA[<h2 id="来自你的消息"><a href="#来自你的消息" class="headerlink" title="来自你的消息:"></a>来自你的消息:</h2><p>逻辑回归适用于什么样的数据</p>
<h2 id="来自ChatAI的消息"><a href="#来自ChatAI的消息" class="headerlink" title="来自ChatAI的消息:"></a>来自ChatAI的消息:</h2><p>逻辑回归（Logistic Regression）适用于解决二分类问题，即数据只有两个类别。它常被应用于各种领域，如金融、医学、社会科学等。在机器学习中，逻辑回归是一种经典的分类模型，常用于预测某个事件是否发生的概率。</p>
<h2 id="来自你的消息-1"><a href="#来自你的消息-1" class="headerlink" title="来自你的消息:"></a>来自你的消息:</h2><p>对数线性回归适用于什么样的数据</p>
<h2 id="来自ChatAI的消息-1"><a href="#来自ChatAI的消息-1" class="headerlink" title="来自ChatAI的消息:"></a>来自ChatAI的消息:</h2><p>对数线性回归（Log-linear Regression）适用于解决多分类问题，即数据有三个以上的类别。与逻辑回归不同的是，对数线性回归是一种广义线性模型，它可以对分类问题进行更加灵活的建模。对数线性回归通常应用于文本分类、图像分类、信号识别等领域。在训练模型时，常使用最大似然估计或贝叶斯估计等方法来确定模型参数。</p>
<h2 id="来自你的消息-2"><a href="#来自你的消息-2" class="headerlink" title="来自你的消息:"></a>来自你的消息:</h2><p>对数几率回归就是逻辑回归？</p>
<h2 id="来自ChatAI的消息-2"><a href="#来自ChatAI的消息-2" class="headerlink" title="来自ChatAI的消息:"></a>来自ChatAI的消息:</h2><p>是的，对数几率回归（Logistic Regression）就是逻辑回归。这两个术语是可以通用的。对数几率回归是一种广义线性模型，通常用于解决二分类问题，特别是在机器学习中被广泛使用。该模型基于输入变量的线性组合，估计一个概率值，表示属于某一类别的可能性。这个概率值被映射到[0,1]之间，用sigmoid函数进行转换，然后用一个阈值来确定分类的决策边界。</p>
<h2 id="来自你的消息-3"><a href="#来自你的消息-3" class="headerlink" title="来自你的消息:"></a>来自你的消息:</h2><p>什么是广义线性模型，通俗的解释</p>
<h2 id="来自ChatAI的消息-3"><a href="#来自ChatAI的消息-3" class="headerlink" title="来自ChatAI的消息:"></a>来自ChatAI的消息:</h2><p>广义线性模型是对传统线性模型的扩展，用于处理非正态分布的响应变量。我们可以这样理解，通常一个问题的解决可以有多种方法，传统线性模型只能处理满足正态分布假设的问题，而广义线性模型就是将线性模型扩展到更多的分布类型中。</p>
<p>广义线性模型通过三个组成要素来描述响应变量和预测变量之间的关系，这三个要素是随机分布、连接函数和系统方程。简单来说，就是响应变量的分布特征、预测变量和响应变量之间的联系方式、以及响应变量的期望与预测变量之间的关系。</p>
<p>广义线性模型的应用范围广泛，可以涵盖几乎所有的自然和社会学科。</p>
<h2 id="来自你的消息-4"><a href="#来自你的消息-4" class="headerlink" title="来自你的消息:"></a>来自你的消息:</h2><p>一元线性也只能解决正态分布问题吗</p>
<h2 id="来自ChatAI的消息-4"><a href="#来自ChatAI的消息-4" class="headerlink" title="来自ChatAI的消息:"></a>来自ChatAI的消息:</h2><p>不准确，简单来说，一元线性回归模型认为，如果我们找到了解释变量x和响应变量y之间的关系，那么我们可以根据该关系来预测响应变量的值。这个模型假设响应变量y的分布符合正态分布，因为正态分布有许多好的性质可以用于建立模型和进行统计推断。</p>
<p>但是有时候，我们的数据可能不完全符合模型假设（也就是响应变量不是正态分布），但是我们仍然可以使用一元线性回归模型来进行建模。例如，我们可以对数据进行对数变换，使得响应变量的值在对数尺度下接近正态分布。在这种情况下，我们仍然可以使用一元线性回归模型来描述解释变量和响应变量之间的关系。</p>
<p>总之，一元线性回归模型是一种基本的线性模型，通常可以应用于许多具体问题中。但是需要注意的是，模型假设必须合理，否则可能会产生错误的结果。如果模型的假设不符合数据特征，则需要考虑使用其他的回归模型或非线性模型来处理数据。</p>
<h2 id="来自你的消息-5"><a href="#来自你的消息-5" class="headerlink" title="来自你的消息:"></a>来自你的消息:</h2><p>怎么确定数据符合正态分布？是先跑各种模型试一试，再确定最终使用哪种模型分析吗</p>
<h2 id="来自ChatAI的消息-5"><a href="#来自ChatAI的消息-5" class="headerlink" title="来自ChatAI的消息:"></a>来自ChatAI的消息:</h2><p>确定数据是否符合正态分布的常用方法有两种，一种是绘制样本数据的直方图或概率密度函数图，看是否呈钟形；另一种是进行正态性检验，例如Shapiro-Wilk检验、Kolmogorov-Smirnov检验等。</p>
<p>绘制概率密度函数图或直方图的方法较为直观。在绘制直方图时，如果数据呈现出一种对称的钟形分布，那么很有可能这组数据符合正态分布。在样本量足够大时，可以通过绘制概率密度函数图来更加准确地判断数据是否符合正态分布。这里需要注意，样本数据呈现钟形分布并不意味着一定符合正态分布，因此需要进行正态性检验。</p>
<p>正态性检验可以使用多种方法，第一种方法是假设检验的方法，如Shapiro-Wilk检验、Kolmogorov-Smirnov检验等。这些方法假设数据符合正态分布，通过计算统计量来判断样本数据是否呈正态分布。如果假设检验结果不拒绝原假设（即样本数据符合正态分布），则可以使用一元线性回归模型等基于正态分布的模型进行分析。</p>
<p>第二种方法是使用图形判断法。数据的正态概率图可以画出数据的QQ图（Quantile-Quantile Plot），并对其进行比较来检验数据是否符合正态分布。如果数据的正态概率图呈现出一条直线，那么可以认为数据适合正态分布。</p>
<p>总而言之，确定数据是否符合正态分布是数据分析中的一个重要环节。如果数据符合正态分布，可以使用基于正态分布的方法来进行分析，例如使用一元线性回归分析。如果数据对正态分布的假设不成立，则需要考虑使用其他方法来分析数据，例如非参数方法等。</p>
<h2 id="来自你的消息-6"><a href="#来自你的消息-6" class="headerlink" title="来自你的消息:"></a>来自你的消息:</h2><p>正常做数据分析，也要先这样判断一下吗？判断过程方便吗？</p>
<h2 id="来自ChatAI的消息-6"><a href="#来自ChatAI的消息-6" class="headerlink" title="来自ChatAI的消息:"></a>来自ChatAI的消息:</h2><p>在实际数据分析中，判断数据是否符合正态分布是一个常见但非必要的步骤，特别是在使用一元线性回归模型分析数据时，需要注意数据是否符合正态分布的假设。对于大多数实际问题而言，并非所有数据都符合正态分布，因此在数据分析中，我们需要针对不同数据类型和具体问题来选择合适的分析方法和模型，而判断数据是否符合正态分布仅是整个分析流程中的一个环节。</p>
<p>判断数据是否符合正态分布的步骤很简单，直方图或概率密度图的绘制非常容易；进行正态性检验的方法也相对容易掌握。在各种统计软件中，这些方法都可以很方便地实现。此外，对于一元线性回归分析而言，如果数据不满足正态分布假设，也可以采用非参数统计方法（如Mann-Whitney U检验等）进行分析，因此即使数据不符合正态分布也不会对数据分析造成太大影响。</p>
<p>总的来说，判断数据是否符合正态分布并不是数据分析中必须的步骤，特别是在实际分析中，数据通常是复杂多样的，不可能仅通过正态分布来描述。在实际应用时，需要结合具体问题选取合适的分析方法，判断数据是否符合正态分布仅仅是数据分析的一个环节，而不是分析必须的步骤。</p>
<h2 id="来自你的消息-7"><a href="#来自你的消息-7" class="headerlink" title="来自你的消息:"></a>来自你的消息:</h2><p>就是说，大部分问题使用线性模型和广义线性模型就能勉强解决了是吗</p>
<h2 id="来自ChatAI的消息-7"><a href="#来自ChatAI的消息-7" class="headerlink" title="来自ChatAI的消息:"></a>来自ChatAI的消息:</h2><p>对于某些问题，线性模型和广义线性模型可以提供很好的结果，但并不是所有问题都可以通过这些模型来解决。在实际数据分析中，需要根据数据类型、研究问题及其背景、研究目的等因素，灵活选择合适的统计方法和模型。</p>
<p>线性模型本身是一种基础的模型，适用于解释变量与因变量之间呈线性关系的情况。但是在实际问题中，很多因素可能同时影响因变量，而且在一些问题中，变量之间可能存在复杂的相互作用。这种情况下，使用线性模型可能难以取得较好的效果。对于这些问题，需要考虑使用其他的线性可加模型或非线性模型。</p>
<p>广义线性模型在一定程度上扩展了线性模型的应用范围，例如可以处理响应变量不符合正态分布假设等情况。但广义线性模型仍然依赖于一些假设，例如假设因变量与解释变量之间存在某种联系，同时模型的形式可以用一定的数学函数来描述。在具体问题中，如果关系很复杂，或者需要考虑非线性关系等因素，广义线性模型也可能无法提供满足需求的结果。</p>
<p>因此，在实际数据分析中，需要根据具体问题和数据特征，综合运用各种统计方法和模型，选择最优的方案来解决问题。如果某个模型完美地契合问题，那么使用它通常会带来最佳的结果，但是这并不是必然的情况；在实际应用中，需要根据数据特征和问题的固有属性，选择合适的统计方法和模型，从而取得更好的效果。</p>
<h2 id="来自你的消息-8"><a href="#来自你的消息-8" class="headerlink" title="来自你的消息:"></a>来自你的消息:</h2><p>还有什么模型</p>
<h2 id="来自ChatAI的消息-8"><a href="#来自ChatAI的消息-8" class="headerlink" title="来自ChatAI的消息:"></a>来自ChatAI的消息:</h2><p>除了常见的线性模型和广义线性模型，还有很多模型可供选择，以下列举部分：</p>
<ol>
<li><p>非线性模型：处理非线性关系，包括多项式回归模型、指数模型、对数模型、幂函数模型等。</p>
</li>
<li><p>非线性可加模型：允许变量之间的相互作用，包括交互作用模型、广义可加模型等。</p>
</li>
<li><p>非参数模型：处理不需要事先确定函数形式的情况，包括核密度估计、局部多项式回归、回归树、支持向量机回归等。</p>
</li>
<li><p>模型选择方法：模型选择的目的通常是挑选一个在训练数据上表现最好的模型，避免过拟合，例如AIC、BIC、交叉验证等。</p>
</li>
<li><p>层次线性模型：用于处理多级结构数据，例如随机截距模型、随机斜率模型等。</p>
</li>
<li><p>时间序列模型：用于处理时间序列数据，例如平稳时间序列的ARMA、ARIMA模型，非平稳时间序列的分散趋势模型等。</p>
</li>
<li><p>聚类分析模型：用于寻找数据中固有的组群性质，例如层次聚类、K均值聚类等。</p>
</li>
<li><p>判别分析模型：用于分类预测，例如线性判别分析、二次判别分析等。</p>
</li>
</ol>
<p>上述模型都有其特定的适用场景，选择正确的模型非常重要，需要根据具体问题和数据特征，选择最优的算法或模型。同时，在实际应用中，不同模型之间也可以进行组合和嵌套，以得到更好的效果。</p>
]]></content>
      <categories>
        <category>AI</category>
        <category>note</category>
      </categories>
      <tags>
        <tag>ML</tag>
      </tags>
  </entry>
  <entry>
    <title>西瓜书3  梯度/偏导/LDA（base GPT）</title>
    <url>/2023/06/23/MachineLearning/ChatGPT/%E7%AB%9E%E8%B5%9B%EF%BC%8C%E6%A2%AF%E5%BA%A6%EF%BC%8C%E5%81%8F%E5%AF%BC%EF%BC%8CLDA/</url>
    <content><![CDATA[<h2 id="来自你的消息"><a href="#来自你的消息" class="headerlink" title="来自你的消息:"></a>来自你的消息:</h2><p>假设你是一个AI和数学方面的专家，请解答我的问题，并在解释所有问题时，把解释中的所有专有名词都加上注释，或者用括号法解释</p>
<h2 id="来自ChatAI的消息"><a href="#来自ChatAI的消息" class="headerlink" title="来自ChatAI的消息:"></a>来自ChatAI的消息:</h2><p>当然，我会尽我所能地解答您的数学问题。请问有什么需要我帮助的吗？</p>
<h2 id="来自你的消息-1"><a href="#来自你的消息-1" class="headerlink" title="来自你的消息:"></a>来自你的消息:</h2><p>什么是梯度</p>
<h2 id="来自ChatAI的消息-1"><a href="#来自ChatAI的消息-1" class="headerlink" title="来自ChatAI的消息:"></a>来自ChatAI的消息:</h2><p>在数学中，梯度是一个向量，它告诉我们函数最快增长的方向，即最陡峭的方向。在多元函数的情况下，梯度是一个向量，包含每个自变量的偏导数，用于衡量自变量的微小变化对函数值的影响。梯度可以被视为向量空间中的一个向量，指向使函数增加最快的方向，其大小是这个变化率的大小。因此，梯度在机器学习中被广泛使用，例如用于优化算法中的参数优化过程，如梯度下降算法。</p>
<h2 id="来自你的消息-2"><a href="#来自你的消息-2" class="headerlink" title="来自你的消息:"></a>来自你的消息:</h2><p>什么是损失函数？怎么求？为什么这么求？</p>
<h2 id="来自ChatAI的消息-2"><a href="#来自ChatAI的消息-2" class="headerlink" title="来自ChatAI的消息:"></a>来自ChatAI的消息:</h2><p>在机器学习中，损失函数表示模型预测的输出与实际结果之间的差距，即模型的误差大小。损失函数的值越小，说明模型的预测结果与实际结果越接近。因此，我们利用损失函数来衡量模型的预测质量，并利用此来推动模型的训练过程。</p>
<p>常见的损失函数有平方损失函数，交叉熵损失函数等。平方损失函数用于回归任务，交叉熵损失函数用于分类任务。</p>
<p>在训练过程中，我们通过梯度下降等算法来最小化损失函数，找到使损失函数达到最小值的模型参数。</p>
<p>求解损失函数通常涉及到对数据进行前向传播计算和反向传播计算。在前向传播计算中，模型根据输入数据进行预测，并将预测结果与实际结果进行比较，计算出损失函数的值。在反向传播计算中，利用链式法则来计算损失函数对模型参数的梯度，在模型参数更新时使用梯度来指导模型更新的方向。</p>
<p>因此，损失函数是机器学习中非常重要的一个概念，对于训练好的模型的准确性和性能具有重要影响。</p>
<h2 id="来自你的消息-3"><a href="#来自你的消息-3" class="headerlink" title="来自你的消息:"></a>来自你的消息:</h2><p>损失函数对每个参数的偏导数代表了什么？为什么能代表这些？</p>
<h2 id="来自ChatAI的消息-3"><a href="#来自ChatAI的消息-3" class="headerlink" title="来自ChatAI的消息:"></a>来自ChatAI的消息:</h2><p>损失函数对每个参数的偏导数表示了在当前参数值下，将该参数增加一个微小量所导致的损失函数变化量。这个微小量通常用符号$\epsilon$表示，通常趋向于0，因为我们只关心微小的变化。</p>
<p>这些偏导数被用来衡量模型在各个参数上的敏感度，即在改变每个参数的值时，损失函数的变化量。这些偏导数可以用于梯度下降等算法中，来进一步优化模型参数，以使损失函数最小化。</p>
<p>梯度代表着函数的导数，也就是在当前点处函数在每个自变量上的变化率。因此，损失函数对每个参数的偏导数可以理解为函数在每个自变量上的变化率，而这种变化率提供了有关参数对模型预测的影响的信息。在机器学习中，通过调整参数使得损失函数最小化可以将模型的预测结果接近于真实标签值。因此，损失函数对每个参数的偏导数提供了关于如何调整参数来优化模型的指导。</p>
<h2 id="来自你的消息-4"><a href="#来自你的消息-4" class="headerlink" title="来自你的消息:"></a>来自你的消息:</h2><p>这些参数就是不同的特征吗？一一对应关系？</p>
<h2 id="来自ChatAI的消息-4"><a href="#来自ChatAI的消息-4" class="headerlink" title="来自ChatAI的消息:"></a>来自ChatAI的消息:</h2><p>在机器学习中，参数通常是模型中的可训练的权重和偏置项，而特征则是与输入数据有关的属性或变量。一般来说，模型的特征和参数是不同的概念。</p>
<p>在监督学习中，特征是输入数据的某些属性或变量，并用于描述和表示输入数据的特征空间。例如，在图像识别任务中，每个像素值可以被视为一个特征，因此图像可以看做是由大量特征组成的。在自然语言处理任务中，可以将每个单词作为一个特征，从而实现文本的表示。特征通常是非常具体和具体的，每个特征与模型参数的一对一对应关系并不总是存在。</p>
<p>参数则是机器学习模型的内部变量，通过对输入数据的组合和处理来生成预测结果。例如，在一个线性回归模型中，参数就是代表每个特征的权重，用于计算预测结果。每个参数通常与模型输入中一个特定的特征相对应，并通过训练通过损失函数和梯度下降等方法进行调整，以使模型最小化损失函数。</p>
<p>总之，特征和参数在机器学习中是指两个不同的概念，它们一般不是一一对应关系。</p>
<h2 id="来自你的消息-5"><a href="#来自你的消息-5" class="headerlink" title="来自你的消息:"></a>来自你的消息:</h2><p>损失函数计算出来的就是衡量误差用的数据。损失函数里必然含有参数字母（比如线性回归中，使用均方误差时，误差函数中的y‘必然含有权重w）。所以可以对参数进行偏导计算。</p>
<h2 id="来自ChatAI的消息-5"><a href="#来自ChatAI的消息-5" class="headerlink" title="来自ChatAI的消息:"></a>来自ChatAI的消息:</h2><p>是的，通常损失函数是关于模型参数的函数，参数在损失函数中的出现是因为模型的预测结果是由输入数据和模型参数组合计算而来的。损失函数通过衡量模型的预测结果与实际结果之间的差异来确定模型预测质量的好坏。而对损失函数求参数的偏导数，则可以得到函数在每个参数处的变化率，提供了一种优化目标函数的方法。</p>
<p>以线性回归为例，均方误差作为损失函数，其中误差函数就包含模型的预测结果和实际标签值，而模型的预测结果又是由输入数据和模型权重计算得来的。因此，在求解导数时，需要对输出值对权重的偏导数进行求解，即$\frac{\partial Loss}{\partial w}$，这样可以得到损失函数关于权重的斜率，从而帮助我们来优化模型。</p>
<p>在深度学习中，损失函数中可能还会包含其他参数，比如神经网络模型的偏置项等，对这些参数求导也可以帮助我们找到使损失函数最小化的最优参数组合。</p>
<h2 id="来自你的消息-6"><a href="#来自你的消息-6" class="headerlink" title="来自你的消息:"></a>来自你的消息:</h2><p>假如对w进行偏导计算，就相当于求出了w所在维度的偏导函数，这个函数能够代表误差函数上升下降的趋势对吗</p>
<h2 id="来自ChatAI的消息-6"><a href="#来自ChatAI的消息-6" class="headerlink" title="来自ChatAI的消息:"></a>来自ChatAI的消息:</h2><p>是的，对损失函数关于某个参数（比如权重w）求偏导数，可以得到在当前参数取值下，该损失函数关于该参数的变化率 or 上升或下降的趋势，也就是损失函数的斜率。这个斜率可以告诉我们，如果沿着该参数的梯度方向更新，会导致误差的增加或减少。若斜率为正，则表示损失函数会随着参数增加而增加；若斜率为负，则表示损失函数会随着参数增加而减少。</p>
<p>以线性回归模型为例，偏导数有助于衡量权重对模型复杂度的影响，一个重要要求是降低模型的复杂度，以防止出现过拟合的情况，即模型过分学习数据的噪声而造成泛化能力不足。在求$w$的偏导时，可以得到在当前$w$的取值下，损失函数所在维度的上升或下降趋势，这个趋势可以用来指示我们在模型训练中是否应该加或减重要的特征以获得更好的泛化能力。</p>
<p>总而言之，偏导数代表了损失函数在某个参数维度的变化率，可以告诉我们沿着梯度方向更新特定参数的方向和速度，进而指导我们进行模型优化和参数调整。</p>
<h2 id="来自你的消息-7"><a href="#来自你的消息-7" class="headerlink" title="来自你的消息:"></a>来自你的消息:</h2><p>所以我就能用这个偏导函数来找到偏导最小的点（误差下降最快的点）</p>
<h2 id="来自ChatAI的消息-7"><a href="#来自ChatAI的消息-7" class="headerlink" title="来自ChatAI的消息:"></a>来自ChatAI的消息:</h2><p>不完全正确。偏导数为0时，代表着函数在该方向上的变化率为0，也就是函数当前变化趋势最缓慢的地方。但是，仅仅因为函数在该点处的偏导数取得了0并不意味着达到了全局最小值。在高维函数中，这个点可能只是局部极小值或鞍点（Saddle Point），但并不是全局最小值。</p>
<p>因此，通常需要在多个维度上使用梯度下降等优化方法来搜索损失函数的最小值。在梯度下降中，我们首先计算损失函数关于参数的偏导数，然后沿着每个参数的偏导数的相反方向移动一定步长，以达到最小化损失函数的目标。</p>
<p>梯度下降的过程是迭代的，每次迭代需要重新计算偏差函数关于参数的导数并更新参数值，以此来逐渐逼近损失函数的最小值。这样做虽然比直接计算偏导数并寻找一个严格的最小值要更加复杂，但是它是可行的并已被证明在许多机器学习模型上是有效的。</p>
<h2 id="来自你的消息-8"><a href="#来自你的消息-8" class="headerlink" title="来自你的消息:"></a>来自你的消息:</h2><p>所以对于一元回归来说，我说的是对的。多元就要多维度考虑对吧。那么怎么多维度考虑？应该用什么算法？</p>
<h2 id="来自ChatAI的消息-8"><a href="#来自ChatAI的消息-8" class="headerlink" title="来自ChatAI的消息:"></a>来自ChatAI的消息:</h2><p>是的，对于一元回归，可以通过求导数来找到损失函数的最小值。而对于多元回归，则需要同时考虑多个参数的变化趋势，因此需要在多个维度上进行求导计算。</p>
<p>对于多维情况，可以使用梯度下降法或其变种算法来迭代更新参数以最小化损失函数。梯度下降法的本质思想是寻找一个迭代序列以更新模型参数，每次迭代步骤中需要根据损失函数在当前模型参数位置的负梯度方向，更新参数向目标方向移动，实现损失函数的最小化过程。</p>
<p>多维情况下，梯度下降法可以像一元回归一样对每个参数进行偏导计算，也可以采用矩阵运算，将所有参数的偏导数组成雅克比矩阵，从而能够同时计算所有参数的偏导数，一次性进行参数更新，加快了模型的训练速度。</p>
<p>此外，为了避免局部最小值和鞍点等问题，在梯度下降的基础上，可以使用优化算法来改进损失函数的优化过程。常用的算法包括随机梯度下降，动量梯度下降，Adagrad，RMSProp和Adam等。这些算法通过改变梯度的计算方式，更新梯度的方向和速度等方法，加速了参数更新的速度，提高了模型的训练效果。</p>
<h2 id="来自你的消息-9"><a href="#来自你的消息-9" class="headerlink" title="来自你的消息:"></a>来自你的消息:</h2><p>线性判别分析是把点映射到几维上？</p>
<h2 id="来自ChatAI的消息-9"><a href="#来自ChatAI的消息-9" class="headerlink" title="来自ChatAI的消息:"></a>来自ChatAI的消息:</h2><p>线性判别分析（Linear Discriminant Analysis, LDA）是一种经典的监督学习算法，主要用于分类问题。它的主要思想是对高维数据进行降维，将数据投影到低维空间中进行分类。因此，LDA将数据点通过一个线性变换映射到一维或多维上。</p>
<p>LDA的基本思想是利用数据中的类别信息来提取能够最好区分不同类别的特征维度。在LDA中，优化目标是使得不同类别之间的距离尽可能大，同时同一类别内部的距离尽可能小。在数学上，LDA将原始n维数据投影到k维（k&lt;n）空间上，其中k是经过优化后的维数。这个投影向量的提取，可以通过计算类间离散度和类内距离计算而来。因此通过LDA，我们能够优化并减少数据维度，同时提高判别准确率。</p>
<p>以二分类任务为例，对于每个样本$x_i$，我们需要将其投影到一个一维线性子空间上，即$LDA(x_i)&#x3D;w^Tx_i$，其中$w$是一个列向量，代表了投影子空间的方向。通过LDA，我们可以找到一个最优的投影方向w，使得不同类别之间的距离尽可能大，同时同一类别内部的距离尽可能小。这个方向w可以通过求解LDA目标函数获得。</p>
<p>总之，LDA通过优化一个最优化问题来选择最好的投影子空间，将高维数据映射到一个低维子空间上，从而实现优化和降维的目的。</p>
<h2 id="来自你的消息-10"><a href="#来自你的消息-10" class="headerlink" title="来自你的消息:"></a>来自你的消息:</h2><p>什么样的数据适合LDA降维？这样的数据还适合什么算法？请用最易懂的话介绍一下LDA是如何降维的？</p>
<h2 id="来自ChatAI的消息-10"><a href="#来自ChatAI的消息-10" class="headerlink" title="来自ChatAI的消息:"></a>来自ChatAI的消息:</h2><p>LDA适用于具有明确类别标签或类别信息的数据。因此，适合使用LDA降维的数据通常是分类问题，特别是在训练样本数量充足的情况下，才能保证LDA的有效性。</p>
<p>相比于其它降维方法如PCA和T-SNE等，LDA更适合于处理线性可分的数据，即不同类别之间的数据点距离较远，同一类别内的数据点距离较近的数据。在LDA中，数据点与投影向量的距离越远，则对于分类的贡献越大，因此数据在投影后得到了更好的分类结果。如果数据在投影后难以区分，LDA可能不会比其它降维方法表现得更好。</p>
<p>当数据量比较大，或者数据的不同类别之间没有强特征时，LDA降维可能非常耗时或效果不佳。相反，当数据量较小，或类别之间的数据存在非常明显的特征时，LDA降维可以得到非常好的效果，因为它能够更好地保留不同类别之间的差异。</p>
<p>LDA的降维过程可以简单地归纳为以下三个步骤：</p>
<ol>
<li>计算类内距离和类间距离</li>
</ol>
<p>首先，我们需要计算数据的类内距离和类间距离，其中类内距离指的是同类样本之间的距离，类间距离指的是不同类样本之间的距离。这些距离可以通过计算数据的协方差矩阵和均值向量来计算。</p>
<ol start="2">
<li>计算投影向量</li>
</ol>
<p>通过计算类内距离和类间距离，我们可以得到一个目标函数。我们需要找到一个投影向量，使得目标函数最大化。这个投影向量同时也可以被用于降维操作。我们可以通过求解广义特征值问题，得到投影向量。</p>
<ol start="3">
<li>投影数据</li>
</ol>
<p>最后，我们可以使用投影向量来将数据映射到降维后的空间中，从而得到一个降维后的结果。在具体实现中，我们也可以通过SVD等方法来实现LDA的降维。</p>
<h2 id="来自你的消息-11"><a href="#来自你的消息-11" class="headerlink" title="来自你的消息:"></a>来自你的消息:</h2><p>请关联并总结一下目前我所提出的所有问题、对应的解答。并推荐给我相关的知识点。</p>
<h2 id="来自ChatAI的消息-11"><a href="#来自ChatAI的消息-11" class="headerlink" title="来自ChatAI的消息:"></a>来自ChatAI的消息:</h2><ol>
<li><p>偏导数和梯度的概念及其在机器学习中的应用：偏导数指的是函数在一个变量上的变化率，而梯度则是一个向量，其每个分量都是函数在对应变量上的偏导数。在机器学习中，梯度是优化损失函数的一个重要指标，可以使用梯度下降等算法来最小化损失函数。相关知识点：微积分、优化算法、机器学习基础知识。</p>
</li>
<li><p>偏导数为零时代表什么，是否一定代表函数达到了全局最小值：偏导数为0时代表函数在对应变量上变化趋势最缓慢的地方，但并不一定表示达到了全局最小值，因为在高维函数中可能存在局部最小值和鞍点等情况。因此，在优化损失函数时需要使用梯度下降等算法来在多个维度上搜索最小值，以保证找到全局最优解。相关知识点：优化算法、机器学习基础知识。</p>
</li>
<li><p>线性判别分析（LDA）的数据适用范围和降维过程：LDA适用于具有明确类别标签或类别信息的数据，主要用于分类问题，并对高维数据进行降维。在LDA中，数据通过协方差矩阵和均值向量的计算，提取出能够最好区分不同类别的特征维度，然后将数据投影到一维或多维上，实现优化和降维的目的。相关知识点：监督学习、降维算法、LDA。</p>
</li>
</ol>
<p>以上问题和解答都涉及到了机器学习中的基础概念和算法，其中包括微积分、优化算法、监督学习和降维算法等。如果你想更深入学习这些知识点，可以通过阅读相关的教材和学习资源，例如《深度学习》、《西瓜书》、《机器学习实战》等。同时，在学习的过程中，建议多进行编程实践，加深理解并掌握实现相关算法的能力。</p>
<h2 id="来自你的消息-12"><a href="#来自你的消息-12" class="headerlink" title="来自你的消息:"></a>来自你的消息:</h2><p>有没有推荐的实战项目</p>
<h2 id="来自ChatAI的消息-12"><a href="#来自ChatAI的消息-12" class="headerlink" title="来自ChatAI的消息:"></a>来自ChatAI的消息:</h2><p>当然有！以下是几个机器学习实战项目的推荐：</p>
<ol>
<li>房价预测</li>
</ol>
<p>房价预测是一个非常典型的机器学习应用，通常使用回归模型进行预测，并可以使用常见的回归算法来实现，例如线性回归、决策树、随机森林等。你可以使用公开数据集如kaggle等，或者使用Web API获取房价数据。然后使用机器学习算法构建模型，预测不同属性房子的价格，并评估模型的性能。</p>
<ol start="2">
<li>图像分类</li>
</ol>
<p>图像分类是一个比较有挑战的机器学习应用，涉及处理大量的图像数据以及更复杂的深度学习网络。你可以使用公共的图像数据集如MNIST、CIFAR等，利用深度学习框架如TensorFlow、PyTorch等来搭建CNN网络，训练模型并对图像进行分类。</p>
<ol start="3">
<li>情感分析</li>
</ol>
<p>情感分析是一个非常常见的自然语言处理任务，旨在确定文本中的情感极性，通常分为正向、负向和中性。你可以使用公开数据集，如IMDB评论数据集等，或者从社交媒体、新闻等获取数据。使用机器学习算法构建模型，对文本进行情感分析，评估模型的准确率。</p>
<p>总之，机器学习的应用场景非常广泛，只要有数据，几乎每个领域都可以应用到机器学习。以上推荐的实战项目只是其中的一小部分。如果你有特定的领域或问题感兴趣，也可以找到相关数据，应用相应的机器学习算法进行探索和分析。</p>
<h2 id="来自你的消息-13"><a href="#来自你的消息-13" class="headerlink" title="来自你的消息:"></a>来自你的消息:</h2><p>有没有开源数据？</p>
<h2 id="来自ChatAI的消息-13"><a href="#来自ChatAI的消息-13" class="headerlink" title="来自ChatAI的消息:"></a>来自ChatAI的消息:</h2><p>有的，以下是一些公开的数据资源和数据集：</p>
<ol>
<li>UCI Machine Learning Repository</li>
</ol>
<p>UCI机器学习数据仓库是一个公开的数据集资源库，包括许多不同的数据集，范围涵盖了多个应用领域。这些数据集可以用于机器学习研究，评估算法性能等。你可以在它的官方网站上找到多个应用场景的数据仓库，例如：<a href="https://archive.ics.uci.edu/ml/index.php">https://archive.ics.uci.edu/ml/index.php</a></p>
<ol start="2">
<li>Kaggle</li>
</ol>
<p>Kaggle是目前机器学习最大的开放式社区之一，提供了众多的数据集。这些数据集涵盖了多个领域，包含数百个数据集，例如房价预测、图像分类、情感分析等。可以在<a href="https://www.kaggle.com/datasets">https://www.kaggle.com/datasets</a> 网站上进行查看和下载。</p>
<ol start="3">
<li>OpenAI Gym</li>
</ol>
<p>OpenAI Gym是一个开源项目，提供了大量应用于强化学习的数据集。包含了各种强化学习环境和数据集，例如视频游戏、机器人控制、自然语言处理等。可以在 <a href="https://gym.openai.com/">https://gym.openai.com/</a> 上进行查看和下载。</p>
<p>总之，这仅仅是一小部分公开数据集资源，你可以查阅相关的开源数据仓库，例如GitHub、Kaggle，或者从公开的数据门户网站中获得数据集。</p>
<h2 id="来自你的消息-14"><a href="#来自你的消息-14" class="headerlink" title="来自你的消息:"></a>来自你的消息:</h2><p>有没有中国大陆能直接看的</p>
<h2 id="来自ChatAI的消息-14"><a href="#来自ChatAI的消息-14" class="headerlink" title="来自ChatAI的消息:"></a>来自ChatAI的消息:</h2><p>当然有，以下是一些适用于中国大陆用户的公开数据资源和数据集：</p>
<ol>
<li>阿里云开放数据集</li>
</ol>
<p>阿里云提供了开放数据集服务，其中包含大量的公共数据集，并可免费使用。其中的数据集涉及金融、医疗、交通、教育等多个领域。你可以在<a href="https://data.aliyun.com/dataSets">https://data.aliyun.com/dataSets</a> 网站上获取。</p>
<ol start="2">
<li>国家数据</li>
</ol>
<p>中国国家统计局提供了一系列的数据资源，其中包括人口统计、经济统计、交通运输、农业等多个领域的数据。网址是<a href="http://data.stats.gov.cn/index.htm">http://data.stats.gov.cn/index.htm</a></p>
<ol start="3">
<li>K-Lab数据开放平台</li>
</ol>
<p>K-Lab是一个数据科学共享平台，该平台收集了各类数据集，包括文本分析、图像识别、生物信息学等。平台通过云端技术为用户提供多种算法模型，支持开发者快速开发、管理与部署算法模型。你可以在<a href="https://www.kesci.com/home/dataset">https://www.kesci.com/home/dataset</a> 网站上获取。</p>
<p>总之，这仅仅是一小部分公开数据集资源，你可以在国内的公共数据门户网站中寻找，例如：国家统计局、科技部、全国人大等。</p>
<h2 id="来自你的消息-15"><a href="#来自你的消息-15" class="headerlink" title="来自你的消息:"></a>来自你的消息:</h2><p>最著名的数据网站是哪个</p>
<h2 id="来自ChatAI的消息-15"><a href="#来自ChatAI的消息-15" class="headerlink" title="来自ChatAI的消息:"></a>来自ChatAI的消息:</h2><p>最著名的数据网站可能是 Kaggle，该网站是面向机器学习和数据科学社区的一个在线平台，可供用户进行比赛和数据科学项目的开发。Kaggle 上有大量的数据集，并提供丰富的机器学习工具和算法，以及来自世界各地数据科学家的竞赛和项目。</p>
<p>Kaggle是业界最著名的数据科学社区之一，它不仅仅是一个公开数据集平台，而且还是机器学习、数据挖掘和人工智能爱好者的重要交流平台。在 Kaggle 上可以找到大量挑战性的数据科学竞赛，并且有来自全球各地的开发者参与其中。Kaggle 的社区还提供了很多优秀的教程和资源，可帮助初学者入门机器学习和数据科学。</p>
<h2 id="来自你的消息-16"><a href="#来自你的消息-16" class="headerlink" title="来自你的消息:"></a>来自你的消息:</h2><p>中国最著名的呢？</p>
<h2 id="来自ChatAI的消息-16"><a href="#来自ChatAI的消息-16" class="headerlink" title="来自ChatAI的消息:"></a>来自ChatAI的消息:</h2><p>中国最著名的数据网站之一是国家数据，由中国国家统计局提供，网站地址是<a href="http://data.stats.gov.cn/index.htm%E3%80%82%E8%BF%99%E6%98%AF%E4%B8%80%E4%B8%AA%E4%B8%AD%E5%A4%AE%E6%94%BF%E5%BA%9C%E5%BC%80%E6%94%BE%E6%95%B0%E6%8D%AE%E7%9A%84%E7%BD%91%E7%AB%99%EF%BC%8C%E6%8F%90%E4%BE%9B%E4%BA%86%E4%B8%B0%E5%AF%8C%E7%9A%84%E4%B8%AD%E5%9B%BD%E5%90%84%E9%A2%86%E5%9F%9F%E7%9A%84%E6%95%B0%E6%8D%AE%E9%9B%86%EF%BC%8C%E5%8C%85%E6%8B%AC%E4%BA%BA%E5%8F%A3%E3%80%81%E7%BB%8F%E6%B5%8E%E3%80%81%E7%8E%AF%E5%A2%83%E5%92%8C%E7%A4%BE%E4%BC%9A%E8%BF%9B%E5%B1%95%E7%AD%89%E6%96%B9%E9%9D%A2%E7%9A%84%E6%95%B0%E6%8D%AE%E3%80%82%E8%BF%99%E4%BA%9B%E6%95%B0%E6%8D%AE%E5%8F%AF%E4%BB%A5%E4%B8%8B%E8%BD%BD%E5%92%8C%E4%BD%BF%E7%94%A8%EF%BC%8C%E6%98%AF%E6%94%BF%E5%BA%9C%E3%80%81%E4%BC%81%E4%B8%9A%E5%92%8C%E5%AD%A6%E6%9C%AF%E7%95%8C%E7%9A%84%E9%87%8D%E8%A6%81%E5%8F%82%E8%80%83%E6%9D%A5%E6%BA%90%E3%80%82">http://data.stats.gov.cn/index.htm。这是一个中央政府开放数据的网站，提供了丰富的中国各领域的数据集，包括人口、经济、环境和社会进展等方面的数据。这些数据可以下载和使用，是政府、企业和学术界的重要参考来源。</a></p>
<p>另一个著名的数据网站是中国大数据研究院，其网站地址为<a href="http://www.bigdata-research.cn/%E3%80%82%E8%BF%99%E4%B8%AA%E7%BD%91%E7%AB%99%E6%8F%90%E4%BE%9B%E4%BA%86%E5%A4%A7%E6%95%B0%E6%8D%AE%E9%A2%86%E5%9F%9F%E7%9A%84%E7%9B%B8%E5%85%B3%E6%95%99%E8%82%B2%E8%B5%84%E6%BA%90%E3%80%81%E6%8A%80%E6%9C%AF%E6%8A%80%E8%83%BD%E5%9F%B9%E8%AE%AD%E3%80%81%E6%94%BF%E7%AD%96%E6%B3%95%E8%A7%84%E5%92%8C%E4%B8%93%E5%AE%B6%E6%84%8F%E8%A7%81%E7%AD%89%EF%BC%8C%E6%97%A8%E5%9C%A8%E4%BF%83%E8%BF%9B%E5%A4%A7%E6%95%B0%E6%8D%AE%E9%A2%86%E5%9F%9F%E7%9A%84%E5%8F%91%E5%B1%95%E5%92%8C%E5%88%9B%E6%96%B0%E3%80%82">http://www.bigdata-research.cn/。这个网站提供了大数据领域的相关教育资源、技术技能培训、政策法规和专家意见等，旨在促进大数据领域的发展和创新。</a></p>
<p>此外，中国还有一些互联网公司提供的公共数据资源，例如腾讯开放平台、阿里云开放数据集等。它们提供了大量的数据集和应用程序接口（API），为开发者提供了数据和开发工具，帮助提高数据分析和应用的效率。</p>
<p>总之，这些数据网站是中国最著名的数据资源之一，它们为政府、企业、学术界和开发者提供丰富的数据和辅助工具，促进了中国数据行业的发展和创新。</p>
<h2 id="来自你的消息-17"><a href="#来自你的消息-17" class="headerlink" title="来自你的消息:"></a>来自你的消息:</h2><p>中国竞赛的人最常用的是哪个</p>
<h2 id="来自ChatAI的消息-17"><a href="#来自ChatAI的消息-17" class="headerlink" title="来自ChatAI的消息:"></a>来自ChatAI的消息:</h2><p>中国竞赛的人最常用的竞赛平台可能是天池（<a href="https://tianchi.aliyun.com/%EF%BC%89%E3%80%82%E5%A4%A9%E6%B1%A0%E6%98%AF%E9%98%BF%E9%87%8C%E4%BA%91%E6%8F%90%E4%BE%9B%E7%9A%84%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E5%92%8C%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD%E7%AB%9E%E8%B5%9B%E5%B9%B3%E5%8F%B0%EF%BC%8C%E7%94%A8%E6%88%B7%E5%8F%AF%E4%BB%A5%E5%9C%A8%E8%BF%99%E9%87%8C%E5%8F%82%E5%8A%A0%E5%90%84%E7%A7%8D%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B%E3%80%81%E6%95%B0%E6%8D%AE%E5%BB%BA%E6%A8%A1%E7%AD%89%E6%B4%BB%E5%8A%A8%EF%BC%8C%E4%BA%89%E5%A4%BA%E5%A5%96%E9%87%91%E5%92%8C%E8%8D%A3%E8%AA%89%E3%80%82%E5%A4%A9%E6%B1%A0%E6%8F%90%E4%BE%9B%E4%BA%86%E5%A4%9A%E4%B8%AA%E7%AB%9E%E8%B5%9B%E8%B5%9B%E9%A2%98%E5%92%8C%E6%95%B0%E6%8D%AE%E9%9B%86%EF%BC%8C%E6%B6%89%E5%8F%8A%E5%9B%BE%E5%83%8F%E8%AF%86%E5%88%AB%E3%80%81%E8%87%AA%E7%84%B6%E8%AF%AD%E8%A8%80%E5%A4%84%E7%90%86%E3%80%81%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E7%AD%89%E5%A4%9A%E4%B8%AA%E9%A2%86%E5%9F%9F%E3%80%82">https://tianchi.aliyun.com/）。天池是阿里云提供的数据科学和人工智能竞赛平台，用户可以在这里参加各种算法竞赛、数据建模等活动，争夺奖金和荣誉。天池提供了多个竞赛赛题和数据集，涉及图像识别、自然语言处理、深度学习等多个领域。</a></p>
<p>同时，天池还提供了基于云的大规模计算和存储服务，为数据科学家和机器学习从业者提供了便利。另外，天池和阿里云提供了一系列的培训和认证计划，帮助用户掌握前沿的数据科学技能和实战开发经验。</p>
<p>除了天池，还有其他一些竞赛平台，例如 Data Castle（<a href="https://www.dcjingsai.com/%EF%BC%89%E3%80%81K-Lab%EF%BC%88https://www.kesci.com/%EF%BC%89%E7%AD%89%E3%80%82%E5%AE%83%E4%BB%AC%E6%8F%90%E4%BE%9B%E4%BA%86%E7%B1%BB%E4%BC%BC%E7%9A%84%E7%AB%9E%E8%B5%9B%E8%B5%9B%E9%A2%98%E5%92%8C%E6%95%B0%E6%8D%AE%E9%9B%86%EF%BC%8C%E5%90%B8%E5%BC%95%E4%BA%86%E5%A4%A7%E9%87%8F%E5%AD%A6%E6%9C%AF%E5%92%8C%E5%95%86%E4%B8%9A%E6%9C%BA%E6%9E%84%E7%9A%84%E5%8F%82%E4%B8%8E%E3%80%82">https://www.dcjingsai.com/）、K-Lab（https://www.kesci.com/）等。它们提供了类似的竞赛赛题和数据集，吸引了大量学术和商业机构的参与。</a></p>
<h2 id="来自你的消息-18"><a href="#来自你的消息-18" class="headerlink" title="来自你的消息:"></a>来自你的消息:</h2><p>入门的有哪些？</p>
<h2 id="来自ChatAI的消息-18"><a href="#来自ChatAI的消息-18" class="headerlink" title="来自ChatAI的消息:"></a>来自ChatAI的消息:</h2><p>一些机器学习比赛赛题通常相对容易入门，例如手写数字识别、图像分类、文本分类等。这些竞赛赛题可以在 Kaggle、天池等平台上找到。此外，在 Kaggle 和其他平台上，还有一些开放数据集比赛，这些竞赛通常不需要对数据进行清洗和预处理，从而使得入门门槛相对较低。</p>
<h2 id="来自你的消息-19"><a href="#来自你的消息-19" class="headerlink" title="来自你的消息:"></a>来自你的消息:</h2><p>推荐一个开放数据及比赛</p>
<h2 id="来自ChatAI的消息-19"><a href="#来自ChatAI的消息-19" class="headerlink" title="来自ChatAI的消息:"></a>来自ChatAI的消息:</h2><p>推荐一个开放数据及比赛：Kaggle上的“房屋价格预测”竞赛。</p>
<p>该竞赛提供了一个开放的房屋销售数据集（包括房屋特征和价格），要求参赛选手开发算法，预测新房屋的销售价格。该竞赛对于想要学习机器学习和数据科学的初学者来说，是一个很好的入门竞赛、数据集和学习资源，同时，对于高级用户来说，该竞赛也可以为他们提供挑战。</p>
<p>在 Kaggle 上参加该竞赛，参赛选手可以获得丰厚的奖金和 Kaggle 点数。同时，在该竞赛的论坛中，参赛选手可以与其他选手交流想法、分享经验，并从中学习到更多关于数据科学和机器学习的技能。</p>
<p>此外，Kaggle 还提供了一系列其他竞赛和公开数据集，包括图像识别、自然语言处理、时间序列分析等多个应用场景。这些赛题和数据集不仅提供了全球最优秀的数据科学家们的解决方案，同时还为初学者提供了学习数据科学和机器学习的绝佳机会。</p>
]]></content>
      <categories>
        <category>AI</category>
        <category>note</category>
      </categories>
      <tags>
        <tag>ML</tag>
      </tags>
  </entry>
</search>
